<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++的未定义,未指定,引用定义等概念是什么</title>
    <link href="/55f19523/"/>
    <url>/55f19523/</url>
    
    <content type="html"><![CDATA[<p>摘录自C++draft第三章</p><span id="more"></span><h2 id="314-条件支持conditionally-supported"><a class="markdownIt-Anchor" href="#314-条件支持conditionally-supported"></a> 3.14 条件支持（conditionally-supported）</h2><p>标准不做出要求的，不一定所有编译器都支持的行为。</p><p>（每个编译期的实现都会有一个文档列出他们支持了哪些）</p><h2 id="316-默认行为default-behavior"><a class="markdownIt-Anchor" href="#316-默认行为default-behavior"></a> 3.16 默认行为（default behavior）</h2><p>在要求的行为的范围内，具体实现提供的明确行为。</p><h2 id="325-非良构程序ill-formed-program"><a class="markdownIt-Anchor" href="#325-非良构程序ill-formed-program"></a> 3.25 非良构程序（ill-formed program）</h2><p>任意一个不是良构（见下文）的程序。</p><h2 id="326-实现定义行为implementation-defined-behavior"><a class="markdownIt-Anchor" href="#326-实现定义行为implementation-defined-behavior"></a> 3.26 实现定义行为（implementation-defined behavior）</h2><p>在一个良构的程序和正确的数据中的，依赖于具体编译期实现和文档的行为。</p><h2 id="330-本地指定行为locale-specific-behavior"><a class="markdownIt-Anchor" href="#330-本地指定行为locale-specific-behavior"></a> 3.30 本地指定行为（locale-specific behavior）</h2><p>依赖于国家，文化，和语言的行为（什么鬼？？）</p><h2 id="365-未定义行为undefined-behavior"><a class="markdownIt-Anchor" href="#365-未定义行为undefined-behavior"></a> 3.65 未定义行为（undefined behavior）</h2><p>在本文档中没有做出任何要求的行为。</p><h2 id="366-未指定行为unspecified-behavior"><a class="markdownIt-Anchor" href="#366-未指定行为unspecified-behavior"></a> 3.66 未指定行为（unspecified behavior）</h2><p>在一个良构的程序和正确的数据中的，依赖于具体编译期实现的行为。</p><h2 id="368-良构程序well-formed-program"><a class="markdownIt-Anchor" href="#368-良构程序well-formed-program"></a> 3.68 良构程序（well-formed program）</h2><p>结构遵守了语法规则和语义规则的<code>C++</code>程序。</p>]]></content>
    
    
    <categories>
      
      <category>细说CPP标准和stl源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录一些带来欢乐的评论</title>
    <link href="/4a3b8a37/"/>
    <url>/4a3b8a37/</url>
    
    <content type="html"><![CDATA[<span id="more"></span>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>搞笑</tag>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>完全使用linux工作</title>
    <link href="/8bb72059/"/>
    <url>/8bb72059/</url>
    
    <content type="html"><![CDATA[<p>作者：王垠</p><p>2004.8.26</p><span id="more"></span><h1 id="完全用linux工作抛弃windows"><a class="markdownIt-Anchor" href="#完全用linux工作抛弃windows"></a> 完全用Linux工作，抛弃windows</h1><p>我已经半年没有使用 Windows 的方式工作了。Linux 高效的完成了我所有的工作。</p><p>GNU/Linux 不是每个人都想用的。如果你只需要处理一般的事务，打游戏，那么你不需要了解下面这些了。</p><p>我不是一个狂热的自由软件份子，虽然我很喜欢自由软件。这篇文章也不是用来推行自由软件运动的，虽然我觉得自由软件运动是非常好的。</p><p>这篇文章也不是用来比较 Linux 和 Windows 内核效率，文件系统，网络服务的。我现在是作为一个用户而不是一个开发者来说话的，我们的讨论是基于操作，应用层面的。是为了告诉大学里还不了解，或者不理解 UNIX 的科学工作者和大学生，UNIX 比 Windows 更适合用于科学研究工作，请大家理解 UNIX 的工作方式，不要用 Windows 的标准来要求 Linux，而要用一个科学工作者的标准来要求自己，用UNIX 的思想来武装自己。</p><p>我显然是反对在大学，特别是理工科专业推广 Windows 的。我也反对在对&quot;娃娃&quot;们的计算机启蒙教育中使用 Windows。因为 Windows 不论从技术上，经济上，思想风格上都是与我们培养高科技人才的目标格格不入的。Windows 的流行属于历史遗留问题，爷爷一级的人当然已经不可救药，但是我们不应该让下一代继续走上歧途。</p><h1 id="unix-不是计算机专家的专利"><a class="markdownIt-Anchor" href="#unix-不是计算机专家的专利"></a> UNIX 不是计算机专家的专利</h1><p>当我建议一些非计算机专业的人用 Linux 的时候，很多人说：“UNIX 是计算机系的人用的，我们不能理解。” “UNIX 是男孩用的，我们女孩不用。”</p><p>但是其实世界上的大多数科学家和工程师几乎用的都是 UNIX 作为他们的电脑工具。就因为它简单，可靠，稳定，强大，有趣。甚至很多时候 UNIX 就是唯一的选择。</p><p>你说：“我们都会用 UNIX 的话，你们计算机专业的人还用来干什么？” 很容幸的告诉你，计算机专业的有一部分人就是专门为你们提供这样强大而方便的计算机工具的。如果他们制造的工具只有自己会用的话，那这个工具还有什么用？</p><p>理解 GNU/Linux 不要用 Windows 的标准来要求 Linux。</p><p>由于GNU/Linux这个词太长，下面如果没有特别指明，“Linux&quot;就是指GNU /Linux”。</p><p>在这个年代，恐怕没有人需要我来介绍 Linux 是什么了吧？如果你觉得&quot;Linux 只不过是跟 DOS 差不多的东西&quot;，那请问问你旁边的 Linux 用户，Linux 到底是什么？</p><p>那为什么我还要写一篇这样的文章？因为，我发现还有很多人不不理解 Linux 和 UNIX，虽然他们也在用它，但是他们有时会问：“为什么 Linux 不能像 Windows 那样 ……？”，“怎么Redhat Linux不能 mount NTFS 分区！”，“Linux 下用什么整理硬盘？”，“什么时候OpenOffice才能完全兼容Word文件啊？”，“现在还有什么Windows能干的事情Linux干不了的？”……</p><p>他们有40G的硬盘，却只为 Linux 分配了2G空间，有时还抱怨&quot;这个东西怎么占这么多硬盘！&quot; 似乎 Windows 该占用大部分硬盘。他们把重要的数据装在Windows的分区，似乎信不过Linux。他们总是到处寻找新奇的，好看的GUI程序，对命令行的东西一概不屑一顾。他们对Drag&amp;Drop，菜单配置，自动升级非常感兴趣。他们如果找到一个很像 Windows 程序的 Linux 程序，一定会很高兴的说：&quot;哈哈！Linux 也能……了！&quot;如果Linux在某种测试中胜过Windows，他们会高兴得跳起来。他们没有办法用Linux 解决问题的时候，甚至用Wine来运行Windows程序。有时实在没办法，只好重起到Windows，或者干脆省得麻烦，在 Windows 下装一个 VMWare 虚拟一个 Linux 玩。</p><p>你如果出现了上面的情况，说明你的思想受到了 Windows 的某种潜移默化的影响和误导。你没有能够从本质上理解存在于 Linux 身上的 UNIX 思想。你支持 Linux，你喜欢 Linux，你能从中感觉到快乐，这非常好。你现在只需要明白的是：Linux 从来就不是一个玩具，它是天才UNIX的后代。UNIX 是自晶体管发明以来最伟大的发明，它从诞生那一天开始就比 Windows 的设计出色。</p><p>你要体会什么叫做&quot;设计&quot;，一个糟糕的设计并不是到后来缝缝补补就可以变好的，而一个出色的设计，不但可以以不变应万变，而且可以影响到后来者。一个出色的设计配上一个出色的实现，那就是非常出色的发明。Linux 就是这样的一个出色的发明。Linux 并不需要追赶 Windows，也不需要打垮微软。它的最终目标是改变整个计算机世界，还人们自由，给人们乐趣和方便。</p><p>Unix 是简单的，你不需要成为一个天才也能理解这种简单。</p><p>UNIX的设计者 Dennis Ritchie 说：“Unix is simple. It just takes a genius to understand its simplicity.” 但是我不这么认为，因为我不是一个天才，但是我却勇敢的把 Windows 完全删除掉，遇到不明白的事情的时候努力用 UNIX 的方式去解决，而不是寻求 Windows 的帮助。现在我体会到了 UNIX 的思想和好处，我可以用比 Windows 高效几倍的效率工作。因为我相信这样的信念：“Windows 能办到的事 Linux 一定能办到，而且办的更好。”</p><p>这小节开头的话应该改成：“Unix 是简单的，你不需要成为一个天才或是计算机专家。但是在这个冲斥着 Windows 错误观念的世界，你需要信念和勇气才能理解它的简单。” 我下面就告诉你一些我理解到的东西。首先，你要知道的是微软在国际科学领域是根本没有地位的。</p><h1 id="微软的地位"><a class="markdownIt-Anchor" href="#微软的地位"></a> 微软的地位</h1><p>微软的名声在欧洲和美国的大学里，特别是在计算机系里之坏，大家可能有所耳闻。我认识的 MIT，Stanford 的教授，贝尔实验室的专家，甚至一个欧洲小国的高中计算机老师都绝口不提微软的名字。在他们眼里，微软只是一个没有真技术，专靠在落后国家商业宣传和垄断经营的小公司。这个&quot;小&quot;并不是说它人少，钱少，而是说它先进技术少。</p><p>我上次和王益合作写了一个算法演示程序，那个算法是贝尔实验室一位科学家Steven Fortune很天才的发明，为了程序能够被身边大多数人使用，我们选择了 VC+MFC 作为平台。我在分析算法时还得到 Fortune 很热情的鼓励，寄给我一份资料，还多次回信耐心的给我讲解了很多细节。但是程序完成之后，我把样品发给 Fortune，他回信说：“对不起。我机器上没有 MFC。” 话说的很客气，但是我已经感觉到了他对 Windows的不屑。然后我把 MFC 静态编译进程序再发给他，他就没有再回信了。他显然不是瞧不起我，而是确实有难处。</p><p>你能感觉到这位科学家对微软和 Windows 是什么态度了吧？不是反感，而是他心里根本没有 Windows 这个东西！微软在高科技领域没有发展，那么它怎么生存呢？到发展中国家去发展一下，他们的人民还对电脑一无所知，我说不定甚至可以打入大学的计算机系呢。我送他们软件，我捐钱盖大楼，我出钱找图灵奖获得者来演讲，让他们觉得我们都是科学家！</p><p>好了，现在全国的大学包括清华，几乎所有人机器必装盗版 Win2000，Office XP，学校的选课系统是非IE不能正确浏览，论文用 Word 编辑，演示用ppt做，email 的通知附件是 doc 文件，你不用 Word 打不开，连 863 项目都用 VC 写程序了。我很久以前就看到一份报纸说，“微软为什么不严厉打击盗版？” 这篇文章说，微软非但不打击中国的盗版行为，而且有放任之趋势。放长线吊大鱼，“以后我要你们加倍的来还我！” 确实如此，它的目的快实现了。</p><h1 id="windows-笼罩下的中国计算机教育"><a class="markdownIt-Anchor" href="#windows-笼罩下的中国计算机教育"></a> Windows 笼罩下的中国计算机教育</h1><p>说句丢脸的话，比尔盖茨很久以前是我的偶像…… //blush</p><p>在中国，比尔盖茨被很多人奉为神圣，“少年电脑天才”，甚至有的人提到他的名字就做出&quot;抱拳对天&quot;的姿势。很多人谈到微软的&quot;新技术&quot;，“高科技” 都是眉飞色舞。各种&quot;VC编程圣经&quot;，&quot;深入了解 Visual C++&quot;之类的书，在开头几页都会出现非常肉麻的字眼，“在那团团的混沌中，一个开天辟地的精灵，Windows 1.0，诞生了……”</p><p>微软的软件被这么多人盗用，那么人们是怎样使用这些盗版程序的呢？先看看电脑培训班，教的都是一些 DOS 命令，打字，Windows 基本操作，Word 文档处理，PowerPoint，高级班可能有 Excel，Access…… 参加各种微软认证考试，MCSE，MSDE 的人络绎不绝。考试辅导班都贴出了&quot;280元，考过为止&quot;之类的字样。考试参考资料更是昂贵，有些电脑书店整整两书架都是&quot;Microsoft Press&quot;的东西。我有个同学参加认证考试，每门考试都要200多元。而且你一次考不过可以再考，又要交钱。他后来还津津乐道跟我说，看我，花了 XXXX(一个四位数)元考过了微软认证，得到一张比尔盖茨亲笔签名的证书和价值6000元的 Windows XP 内部发行版。</p><p>“电脑要从娃娃抓起”，我们再来看看娃娃们学的是什么。大部分家长给孩子买了电脑之后，他们首先就会装一个盗版的 Windows，然后买来盗版的游戏开始玩。如果哪个孩子会用 Delphi 编程序，那可不得了。报社记者，电视台争相报导，说，某某学校的初中生某某，在别人都还在玩电脑游戏这种&quot;初级阶段&quot;的时候就已经用 Delphi 写程序了。镜头还瞄准了他显示器上面的像框中的比尔盖茨头像！</p><p>我刚进入大学计算机系时还不懂得什么是操作系统，因为我以前只用过&quot;中华学习机&quot;。看到新入学的同学们各个谈论的都是 “Windows 95”，“VC”…… 我简直觉得我落后了好几十年一样，整个一土人，根本跟他们答不上话。好不容易找到一个比较熟的同学问了一下：“你们天天谈论的瘟95是什么啊？” 答：“win95就是一个操作系统，跟DOS是一类。”“朵死是什么？” “你连DOS都不知道是什么？别在计算机系混了。” 学校上课当然不讲VC编程之类的东西，但是上 Pascal 的老师有一次就说：“嗨，我们学校真是落后。现在别人都用 C, C++，甚至 VC 了，我们还在讲 Pascal。不知道什么时候才能有VC课啊。你们出去也是要用VC的，只好自学了。” 于是，有些同学很多时候上课都捧着一本很重的&quot;Windows 编程大全&quot;之类的书，根本没有听课。吃饭时就念念有词的跟我说，“代码的优化是无止境的”，“匈牙利命名法真是伟大的发明” …… 这就是中国很多大学计算机系的情况。</p><p>感觉到无知了？这不是偶然的，而是微软长久以来埋下的伏笔。它要让无知的大家都把它奉为神圣，它要让支持UNIX，Xwindow的人一旦说 UNIX 好，Xwindow 好的时候，都被一群人围着说教：“这个 Windows 也能做到”，“你对 Windows 有偏见”，“微软才是主流啊”，“你敢瞧不起 win2k？”，&quot;.NET 就是世界潮流&quot;，“微软的毕竟是新技术”，“有钱就是有技术”…… 甚至在一番论战比较后败下来还是要说：“Windows 性能差点，但是易用性强”，&quot;Windows 是老百姓用的，要求别那么?quot;，“微软那么有钱，以后想超过 UNIX 还不容易吗？”……</p><h1 id="发达国家的计算机教育"><a class="markdownIt-Anchor" href="#发达国家的计算机教育"></a> 发达国家的计算机教育</h1><p>我前段时间在 USENET 发文问有关 Scheme 语言的问题时，认识了一位丹麦人。他解决了我所有的问题，并且建议我阅读一些很&quot;深奥&quot;的有关程序语言语法，文法的书，他告诉我很多网站可以学习 LISP，Scheme，人工智能，算法。他叫我看 Jonathan Rees 的论文 “Syntactic Closures”。他还打包给我寄过来一份 MIT 的 “How to Design Programs”。他说他在自己的 PC 机上装的是 Linux，他用 Emacs 编辑，运行Scheme 程序。他对 Emacs 的了解和爱好真是使人惊讶。他大学本科毕业时做的毕业设计是一个 Scheme 解释器。这对于我来说是望尘末及了。</p><p>他是那么的不厌其烦，我的每一个问题他都详细的回答。我有时都觉得过于详细了，怎么这么耐心啊？我觉得他似乎是我的高中老师。他是什么样的人呢？我好奇的打听了他的情况。原来，他是丹麦一所普通高中的计算机老师。</p><p>他说他在高中里讲授程序设计和算法，计算机语言文法。他说用 Scheme，他的学生不用再为内存泄漏等程序语言本身的问题而烦恼，而专注于问题和算法本身。有利于培养学生解决问题的能力，特别是用计算机解决数学问题的能力。</p><p>天哪！为什么欧洲出现那么多数学家，几何学家？你看看别人重视的是什么！我们的计算机教育如果继续这样下去，只会沿着弯路越走越远！</p><h1 id="微软和它的朋友们的如意算盘"><a class="markdownIt-Anchor" href="#微软和它的朋友们的如意算盘"></a> 微软和它的朋友们的如意算盘</h1><p>下面来看看微软的收入是怎么来的。首先，Windows 98系列操作系统，一个就是 100多美元，每次升级又是几乎同样的价钱。Windows NT 还要贵几倍，而且有用户数目限制，5个用户的，10个用户的…… 以后如果要增加用户数目还要按比例付钱。</p><p>花了如此多钱买来的操作系统就能用了吗？它竟然连压缩程序都没有提供！你装上Windows 之后一般第一件事就是去下载一个 WinZip 吧，“只要 29 美元”。Windows会中病毒啊，马上花 70 美元买一个 Norton AntiVirus 吧。还有黑客呢？再买一个Norton Internet Security 好了，100 美元。系统需要优化，磁盘需要整理，买一个Norton System Works 是你最佳的解决方案，100美元。</p><p>可是你现在还是不能干正事啊！你想要一个 Word, PowerPoint？那就买一套 Office XP 吧，一起买便宜些，$459.90。</p><p>那些程序不会用啊！那些菜单怎么设置，到底有什么功能啊？看&quot;帮助&quot;也学不会。买本书看看吧，我推荐&quot;Special Edition Using Microsoft Office XP&quot;，不贵，$27.99。这本书里面大部分是屏幕抓图，还是买一本旧的比较划算，$17.85。</p><p>你如果只是当个秘书，上面的差不多还凑合了。可是你有更高的追求，你想成为 Windows程序员。首先买一个 Visual <a href="http://Studio.NET">Studio.NET</a> 吧，要不然怎么编译程序。$494.95。</p><p>为了紧跟微软动向，世界潮流，不能不注册个 MSDN 什么的吧？这个贵一点，不过物有所值啊，$2,799。</p><p>嗯，你现在已经是上层阶级，白领人士了。你现在可以像这样&quot;自由&quot;的，&quot;安全&quot;的生活了。</p><h1 id="为什么要反对使用-windows"><a class="markdownIt-Anchor" href="#为什么要反对使用-windows"></a> 为什么要反对使用 Windows</h1><p>很多人都说不应该完全否定 Window，Windows 也有它的长处。不应该骂微软。</p><p>对。Windows 容易操作，适合普通用户。如果微软把它自己定位在 P&amp;G，Philips 那样的地位，能够给我们的百姓提供周到的，完善的，价廉物美的服务。那我肯定是很喜欢它的。但是从上面的种种情况说明，微软是一个野心极大的国际垄断组织！它的产品没有一个是不出问题的：Windows 不稳定，容易中病毒，而微软不为大家免费提供杀毒软件。我就是要让你们花钱买我的朋友 Symantec 的杀毒软件，谁叫你们已经上了我的贼船？这叫什么售后服务啊！</p><p>你买来微软的程序，安装的时候一般都有一个协议，说：“由于微软的程序造成你的数据损坏或丢失，微软概不负责。” 我想很多人肯定觉得这个不合理，不想按那个 “I accept”。但是你的软件买都买来了，钱都花了，现在一按 “I decline”，安装程序马上就会退出。你只好被迫点击了 “I accept”！这不是不平等条约吗？</p><p>我已经目睹了好几个朋友的文档被 Microsoft Word 损坏，有的是编辑了十多天的30多页的论文，有的是费了很大工夫做出来的个人简历，那个朋友为此失去了到自己向往的P&amp;G 工作的机会。就在他要投简历的前一个晚上，就在那一瞬间…… 不知道他痛哭的时候有没有想起要投诉微软，可是谁叫我们用的都是盗版呢，况且你还点击了 “I accept”。</p><p>微软仗势已经占有大部分PC市场，制定不符合国际标准的&quot;微软的标准&quot;，以不合理的方式压制其它公司的软件，这个问题已经在美国司法部闹了很久了。他甚至在 Windows系列操作系统中放置能够通过网络泄漏用户信息的代码，以至于 Windows 刚进入澳大利亚时被澳大利亚政府禁止使用。</p><p>有些人说：“微软毕竟开创了一个历史，造就了今天的 IT 行业。” 但是，如果没有微软，我们今天早就用上非常稳定，非常可靠，非常方便，非常&quot;傻瓜&quot;的软件了！微软是阻挡信息技术发展的罪魁祸首。</p><p>微软的程序的工作方式(注意，我只是说操作方式，病毒的事情另外算)确实适合于一般家庭，上上网，发发邮件，打打游戏都不错。可是微软却要把自己包装成什么&quot;高科技&quot;企业，要在世界各地设置&quot;研究院&quot;，在大学计算机系赠送不适合用于科研的 Windows产品，甚至出钱请图灵奖得主来中国畅谈&quot;二十一世纪的计算&quot;，还在大会上宣传自己的 .NET 技术。非要把别人认为自己是科学的，自己是领导世界高科技的。但是呢？它什么高科技也没有。欧洲，美国，哪一个关键部门在用微软的东西？NASA? DOE? CERN?你仔细想一想，微软的程序对人类到底有什么重大作用？</p><h1 id="什么是-windows-能干而-linux-干不了的事情"><a class="markdownIt-Anchor" href="#什么是-windows-能干而-linux-干不了的事情"></a> 什么是 Windows 能干而 Linux 干不了的事情？—</h1><p>“Windows 能干而 Linux 干不了的事情，那就是不需要干的事情。”</p><p>有个朋友看我半年没有用 Windows，有时就会问我：“你只用 Linux，有没有发现有些Windows 能处理的事情 Linux 干不了？”—</p><p>我回答说：“Windows 能干而 Linux 干不了的事情，那就是不需要干的事情。”</p><h1 id="windows-能做的有益的事情-linux-都能做"><a class="markdownIt-Anchor" href="#windows-能做的有益的事情-linux-都能做"></a> Windows 能做的有益的事情 Linux 都能做—</h1><p>Windows 下的某些功能确实是我们需要的，那么 Linux 的开发者们和用户也需要这种功能，他们就会去实现这种功能，而且比 Windows 的方式好得多。由于大多数科学家，工程师用的都是 Linux 或者某种商业 UNIX, 所以几乎所有商业的科学工程程序，比如Matlab, Mathematica, AutoCAD, Candence的，Synopsys的，Avant! 的……全都是先有UNIX 的版本(包括Linux)，然后再考虑移植给 Windows，甚至根本不移植给Windows，因为 Windows 的机器一般没有足够的能力运行这样的程序。你不要以为只有 Windows 才有 PSpice, UNIX 的 HSpice 要好得多，而且可以运行在大型主机上。当然它们不是免费的，但是它们值那个价钱。</p><p>但是 Windows 下有些东西在 Linux 下没有很相似的，或者你找到很多类似的，但是它们每一个比起 Windows 的那个程序都要差很多，那么原因有两种可能性：</p><p>有一个完全类似的程序，但是由于它乍一看不漂亮，被你忽略了。而其它程序虽然看起来很漂亮，但是它们是一些初学编程的人写的。现在由于 Gtk, Qt 的诞生，Linux 下开发图形界面程序极其简单，很多初中生甚至小学生都可以随手编出一些漂亮不中用的程序。如果你整天寻找这样的程序挑来挑去，永远也找不到你满意的。当然也有一流的程序用 Gtk 和 Qt，比如 GVIM 就可以用 Gtk 作为图形界面，我还知道 Synopsys 一些程序用了 Qt。</p><p>我曾经也犯过这样的错误，从外表区分一切。结果优秀的 FVWM, lftp, Mutt, wget 都被我忽略过。当我找回它们的时候，我是那么的羞愧不已，它们现在都是我的朋友 我第一次看到 FVWM 觉得它只不过是一个有很厚很难看边框的东西。可是现在，我的同学看到 FVWM 都说：“哇！真漂亮。”</p><p>有另一种完全不同的方式可以达到相同的目的，甚至更好。</p><p>很多人很关心 Open Office, Star Office, AbiWord, … 他们多么盼望有一天某一个Linux 程序能够完全兼容的打开一个复杂的 doc 文档。但是你永远也不可能有那一天。为什么呢？因为微软为了占有市场，必定不会让其它系统的程序能够完全兼容它的文档格式。它一定会不断变化 doc 文档的内部结构，隐藏一些秘密，让其它公司的程序打开 doc 文档时总是有某种问题，从而你必需购买 Microsoft Office 和 Windows。</p><p>你应该想一下，那么多的高智商的大学教授，科学家，学生，他们用的都是 Linux 或者其它类型的 UNIX，他们没有 Word 可用，怎么处理文档呢？这么多年没有一个像Open Office 的程序出现，难道大家没有办法写文档吗？</p><p>显然不是这样。你看看那些高水平的学术杂志，论文，那些大学教授的网页，那些漂亮的幻灯片，它们是什么做的？原来 UNIX 用户早就有非常方便的 troff, LaTeX, SGML等东西可以处理文档，而且它们比起 Word 都要高明的多。Word 显然被这些大拿忽略了，以至于很久以来没有人想在 Linux 下开发一个类似 Word 的程序，除非某些公司想抢微软的饭碗。</p><p>很多人留着 Windows 在硬盘上的原因无非是为了用 Word 和 PowerPoint。我见过一个教授，他的 Windows 笔记本电脑上除了 PowerPoint 什么都没有。有一天演示的时候，他指着堆乱字符说：“对不起，这是一个公式……怎么每次都是这样……” 其实有比PowerPoint 好几百倍的东西可以制造幻灯片，你可以用最简单的方法制造世界一流效果的论文和幻灯片。你待会儿可以看看我的TeX网页，你就会知道为什么我可以完全离开 Windows。</p><h1 id="windows-能做的那些没用的事情-linux-永远做不好"><a class="markdownIt-Anchor" href="#windows-能做的那些没用的事情-linux-永远做不好"></a> Windows 能做的那些没用的事情 Linux 永远做不好</h1><h2 id="电脑游戏"><a class="markdownIt-Anchor" href="#电脑游戏"></a> 电脑游戏</h2><p>有些人说 Linux 下不能玩 Windows 下所能得到的所有游戏。的确，Linux 下虽然也有少量的游戏，比如 Quake。但是它没有 Counter Strike, 没有 Star Craft, ……</p><p>并不是说电脑游戏不该玩，但是应该适可而止。电脑是用来处理事务，帮助你学习，解决问题的工具，而不是一个玩具！整天沉迷于电脑游戏中，而不出去感觉外面的世界，你会变得越来越冷酷，越来越缺乏人情味。你与真实的世界越来越远。</p><p>你可以在 CS 里杀人，你可以在 Tomb Raider 里探险，你甚至可以在 Tony Hawk’s Pro Skaters 里滑板…… 但是 It’s not real！你虽然有很高的&quot;反恐技巧&quot;，但是遇到歹徒的时候，你是那么的怯懦；你虽然控制 Laura 伸手敏捷，但是你打篮球的时候怎么总是被人断球？你虽然可以轻易的在 THPS 里作出一个 “360 kickflip to hangten grind to fakie”，但是你踩在自己的滑板上的时候还不会 ollie！</p><p>说回来，如果你偶尔玩一下电脑游戏未尝不可。但是世界上有远比 Windows + PC 更好的游戏方式。Sony 的 PlayStation2, SEGA 的 DreamCast, Nintendo 的 N64，Namco的街机……每一个都比 Windows 游戏精彩，每一个都有如此高的3D性能，以至于Pentium4, Itanium + GForce4 都无法与它们比美！</p><p>Linux 的用户们都是关心解决世界的关键问题的份子，他们哪里有时间用自己的机器来玩游戏啊？他们每天用Linux高效的做完自己的工作就到阳光下享受自然去了。要玩游戏也是玩一些类似推箱子，贪吃蛇之类的智力小游戏。所以，你知道为什么 Linux 几乎没有游戏了吧？</p><h2 id="整理硬盘优化系统"><a class="markdownIt-Anchor" href="#整理硬盘优化系统"></a> “整理硬盘，优化系统”</h2><p>这是一个非常有意思的话题，仅次于有关&quot;病毒&quot;的话题。相信很多 Windows 用户都有整理硬盘的经历。在很多 Windows 用户眼里，“硬盘用久了，会出现碎片，速度会减慢，需要一个程序来整理，整理硬盘的时候不要做其它工作”，这好像是天经地义的事情。</p><p>我也曾经津津有味的看着 Norton Defrag 一点一点的把我的硬盘排序，调整，用图形的方式显示出来，然后报告?quot;100% 没有碎片。你的硬盘现在已经达到最佳状态。&quot; 我现在才发觉我那时是多么的幼稚。</p><p>Linux 和 UNIX 用户似乎从来没有&quot;整理硬盘&quot;这种说法呢？你觉得很奇怪吗？如果你觉得很奇怪，那说明你的思想在某种程度上被微软的垃圾程序禁锢了。你需要明白，UNIX 的大型主机很多必须是一天24小时，一年365又1/4天不停运转的，要是每个星期都要整理一次硬盘，在整理的时候几乎不能干任何事情，那是绝对行不通的！</p><p>Linux 机器根本不用整理硬盘，这就是为什么没有看到过 Linux 用户整理硬盘。Linux 的文件系统是比 Windows 的 FAT, FAT32, NTFS 高明得多的文件系统，它们不但可以对文件设置权限，实施完全的保护，而且可以&quot;越用越整齐&quot;，“越用碎片越少”！你应该把文件大部分放在 Linux 的分区，而不是 Windows 分区，因为它比 Windows分区可靠得多。</p><p>还有更滑稽的事情就是有很多&quot;Norton System Doctor&quot;，“Windows 优化大师”，“超级兔仔注册表魔法” 之类的程序存在，而且价格昂贵。似乎一个操作系统本来应该有很多问题，需要别的厂商做程序来&quot;优化&quot;它，而且为了得到优化，你需要付钱！这些问题 Linux 根本就没有，所以不需要什么优化。Linux 内核本身就是高度优化的。</p><h1 id="ide"><a class="markdownIt-Anchor" href="#ide"></a> IDE</h1><p>有些人在抱怨为什么 Linux 没有一个良好的 IDE 开发环境。Linux 现在已经有一些IDE 了，但是总是有很多问题。你是不是正在寻找，正在期望 Linux 某一天可以有一个VC那样的开发环境？你有没有发现你正在进入微软给你设下的怪圈？你为什么一定要用 IDE？你说：“IDE 开发迅速，调试方便，适合大型程序……” 那说明微软的程序在你脑子里已经比较根深蒂固，你需要好好清醒一下了，看看我来告诉你。</p><p>高明的 UNIX 程序员不用 IDE，IDE 从来就是给初级 Windows 程序员用的。</p><p>你看看大型的 UNIX 程序，包括 Linux 内核，各种网络服务程序，Xwindow 程序在内，哪一个是 IDE 搞出来的？我们实验室的 EDA 程序也没有一个是 IDE 弄的，我还知道Candence, Synopsys，Mentor 的高性能的图形界面 EDA 程序也都不是 IDE 写的。你信不信，微软的人在写 Windows 本身的时候也根本不用 IDE。微软内部程序员最喜欢的编辑器其实是 VIM，用 VIM 的微软程序员上次向乌干达的可怜儿童捐助了1000多美元，这是值得称赞的。</p><p>有一次某杂志采访一些出名的 Linux 内核程序员，包括 Linus 在内，没有一个人用IDE，有的人用 VIM，有的用 Emacs，只有 Linus 说&quot;GNU Emacs is evil&quot;，但是其实他用的是一种跟 Emacs 有同样键绑定功能的 MicroEmacs。大家都是用编辑器编辑了程序文件，然后用 make 这样的自动工具调用 gcc 编译器完成编译工作的。甚至高级的 Windows 程序员也不用 IDE，他们可以从命令行调用 cl，nmake 来编译自己的程序。虽然这样的 Windows 程序员很少，但是他们却是最了解 Windows，最高明的Windows 程序员。</p><p>为什么 UNIX 程序员不用 IDE？明白了这个道理你就能体会到 UNIX 的设计思想了。首先，一个 IDE 集成了编辑器，编译器，汇编器，调试器，跟踪器…… 这个编辑器功能肯定比不上 VIM 或 Emacs，编译器比不上 GCC，汇编器比不上 as，调试器比不上 gdb，ddd, 跟踪器比不上 strace, ltrace, truss。你得到的是一套整合的低能的程序。如果你对调试器的功能不满意，你只好换用另外一套 IDE，但是这套 IDE 的热键，菜单，编辑器功能，按钮…… 跟原来那个有很大不同。你不得不花很多时间来熟悉新的环境，而不能保持原来的某些东西。</p><p>而在 UNIX 下就不一样了。你可以用你最喜欢的 VIM 编辑程序，你在 VIM 里可以调用GNU make，make 可以调用 gcc, ld, … make 的出错信息可以被 VIM 捕获，VIM 能帮你在源程序里定位。你如果喜欢 icc, 你可以让 make 用 icc 而不是 gcc。你如果觉得 gdb 跟踪变量时比较麻烦，你可以用 ddd 来显示各种数据结构之间的关系。你还可以在 Emacs 里调用 gdb，那样就可以同步显示源代码了。而且 VIM 和 Emacs 还可以编辑很多其它东西，比如信件，LaTeX 文档，HTML，配置文件…… 你不用另外找一个什么编辑器来干这些杂活了。很多程序比如 Mutt, tin 都可以在内部使用 VIM，这样就更方便了。实际上 make 在其它方面还能帮你很多忙，我的每一个比较大型的 LaTeX文档都是用 make 维护的。</p><h1 id="linux-能干的高精尖的事情-windows-都干不了"><a class="markdownIt-Anchor" href="#linux-能干的高精尖的事情-windows-都干不了"></a> Linux 能干的高精尖的事情 Windows 都干不了</h1><p>当然有很多事情是Linux/UNIX的专利了。因为 Windows 只能装在 PC 机上，好像以前也有 Alpha 可以使用 Windows NT，但是就是没见到有人用。PC 机的能力是很低的，像我们编程序处理 NP-Hard 问题的人，用 Windows 的机器显然速度不够，而且有时一个问题算上几天甚至几个星期，Windows 机器是以&quot;死机&quot;著称的，我们怎么能放心？所以几乎所有科学计算程序，EDA 程序，高性能图像处理程序都不是 Windows 的。他们有时也会移植一些给 Windows，但是常常降低那些程序的能力。你比较过 Windows 版本的 Mathematica 和 Linux 的有什么区别吗？</p><p>IBM 制造的最大的并行计算机有 8000 多个处理器，Windows 不可能有能力管理这么多处理器，它用的是什么操作系统？答案是 Linux。</p><p>《泰坦尼克号》电影里的三维动画，那么细腻逼真，Windows机器能做出来吗？不行。那也是 Linux 机器做的。</p><p>民航总局用来训练地情人员的虚拟现实训练设备，Windows 当然无能为力。那都是商业的 IRIX 机器。</p><p>UNIX 是最早支持 TCP/IP 网络协议的系统。它上面有很多可以互相协作的网络服务程序，它们经过多年的使用和修订，已经达到比较完善的程度。而就在1997年，微软的比尔盖茨还在扬言：“Internet 是没有前途的。” 微软的这个&quot;远见卓识&quot;大家应该都已见识，它后来加上的网络服务程序IIS漏洞之多，让公安部都频频发出警报，大家也是见识了的。</p><p>其实你知道了，Windows 没有一样有用的事情能比 UNIX 干的更好。</p><h1 id="linux-干不了的有用的事情-windows-照样干不了"><a class="markdownIt-Anchor" href="#linux-干不了的有用的事情-windows-照样干不了"></a> Linux 干不了的有用的事情 Windows 照样干不了</h1><p>当然 Linux 不是万能的。它也有不能干的事情，电脑也有干不了的事情。但是 Linux干不了的事情，Windows 肯定也干不了。这些事情就是我们需要探索，需要努力的事情了。在你探索的过程中，Linux 必定是你的好伙伴。</p><h1 id="不要把linux和xwindow掩盖起来"><a class="markdownIt-Anchor" href="#不要把linux和xwindow掩盖起来"></a> 不要把Linux和Xwindow掩盖起来！</h1><p>不要把我们的用户当成傻瓜。</p><p>什么？你早就知道 Windows 是垃圾？噢！你怎么不早说呢！害我废话这么多。嘿嘿。</p><p>“好了。你知道 Windows 是垃圾，你现在用什么?”</p><p>“Linux + Xwindow”</p><p>“那我问你，Xwindow 是什么样的？”</p><p>“不就是跟 Windows 差不多吗？只不过 ‘Start’ 按钮比较方，而且上面不是一个Windows 标志，而是一个脚丫子。点击一下居然还有很漂亮的中文菜单。我喜欢！”</p><p>“你知道什么是’根窗口’吗？”</p><p>“不知道。从来没听说过呢？”</p><p>“根窗口就是遮盖整个屏幕的那个最大的窗口。”</p><p>“哪儿有什么窗口啊！我没有看到呢？”</p><p>你发现了问题吗？这些 Linux 用户说是在用 Linux 和 Xwindow，但是他们对 Linux和 Xwindow 几乎完全不了解。很多人用了那么久 Xwindow 都不知道根窗口是什么东西，不知道其实按钮也是窗口，不知道窗口管理器和其它程序有什么关系，大家都以为窗口上面的按钮是程序自己放上去的，不知道窗口?quot;class name&quot;，&quot;resource name&quot;是什么东西。他们也不知道 .Xdefaults 是用来干什么的。特别是他们很多人都不知道 Xwindow 的字体是如何命名的，什么是 fontset，有了一个新的字体也不知道怎么安装。</p><p>他们被遮在 Linux 之上的一层一层的包装迷惑了，他们等待有图形界面的工具来帮助完成一切事情，他们认为 Linux 跟 Windows 一样，只是麻烦一点。他们知道 Linux内核很好，但是他们感觉不到 Linux 和 Xwindow 在操作层面的天生的先进性，随后不久就把 Linux 完全删除掉了。你发现没有，要用户理解 UNIX 和 Xwindow 的操作层面的先进性，才是留住用户的最好办法。如果用户体会不到操作时的方便和高效，内核再好他们也不会理会。</p><p>但是用摹仿 Windows 的作法来吸引用户，永远会失败的。因为 Linux 如果摹仿Windows那一套低效率的方式，那么 Linux 的这套&quot;低效率方式&quot;永远比不上Windows 的那一套&quot;低效率方式&quot;。那么用户就会说：“这个 Linux，没有一样比的上 Windows。”</p><p>Linux 天生就是继承了 UNIX 的高效的工作方式，为什么我们要把它掩盖起来？我们为什么只告诉用户 KDE 的菜单怎么用？我们为什么不能像早期的 Xwindow 书籍那样第一节就告诉用户什么是 X server, 什么是 X client，什么是 Window Manager, 什么是根窗口。第二章就告诉用户窗口有哪些属性，什么是 classname, resource name, hint，怎样使用 .Xdefaults, xrdb ……</p><p>在这里我又不得不说一下那些 Linux 的发行公司和写书的人，他们把 Linux 和Xwindow 包装起来，却没有从基本上告诉用户 Xwindow 的工作原理。很多书籍讲授的层次就是在Gnome, KDE 的菜单操作的层次，靠大量抓图来占篇幅，&quot;繁荣&quot;Linux 书籍市场。</p><p>现在很多人已经把能够利用别人的库写出一个好看的程序作为自己编程水平的象征。在这?quot;图形化&quot;，“可视化” 的年代，你如果还在用 troff, LaTeX 写文档，你还在用VIM 自己编辑 HTML，用 Mutt 处理邮件，你还在用文本模式的 gdb 调试程序，你还在用Xlib 写程序, 你还在用 tin 上 USENET，你还在自己写 Makefile，写机器代码，你还在玩 Clossal Cave 这样的字符模式冒险游戏，那你就是老古董。</p><p>其实这种思想是错误的。虽然你是一个坚决的 Linux 支持者，但是你的思想是 Windows的思想。你认为图形界面，菜单，按钮就可以解决一切问题，就可以给你高效方便。你还是没能摆脱微软给你的潜移默化的东西。你其实离不开 Windows 那样的环境，你迟早会删掉自己的 Linux。</p><h1 id="gui-vs-cli-做一个坚定不移的两面派"><a class="markdownIt-Anchor" href="#gui-vs-cli-做一个坚定不移的两面派"></a> GUI vs. CLI 做一个坚定不移的&quot;两面派&quot;</h1><p>大家看到这个标题是不是热血沸腾？两派大虾都可以围攻我了：</p><p>GUI派用户：“哇！我一看你这小子就是 CLI 的。要不然自己写什么 Makefile？用什么Mutt？”</p><p>CLI派用户：“切～ 你还用 X！高手都不用 X。你是 GUI 那边的。”</p><p>可怜的我：“555～～ 你们都不要我～～ GUI 和 CLI 就那么水火不容吗？”</p><p>计算机界这样的门派之分还很多。很有特点的就是 CLI 和 GUI 了。CLI (Command LIne)的狂热份子声称永远不用 X。我上次在实验室看到一个同学用一个 SecureCRT 登录到Sun 机器，然后用一个 vanilla vi 编辑程序，我建议他启动一个 GVIM 过来显示在Exceed 上可以有语法加亮。但是他坚决反对，说：“高手不用X。你想想，要是我在一个很慢的网络连接怎么用 X？而且好多服务器没有装 X 程序。”</p><p>但是我们实验室的网速可够快，Windows 机器都有 Exceed 啊，而且 Sun 机器有全套X 客户程序包括 GVIM。他说他是 CLI 的坚决拥护者，但是他却在用 Windows，他后来打开了好几个 SecureCRT，每次从文本框输入地址，用户名和密码，从下拉菜单选择&quot;SSH2&quot;，然后点击&quot;Connnect&quot;。他还不断的夸SecureCRT 是&quot;网络管理员投票选出的最受欢迎的登录方式&quot;。老天，SecureCRT 本身就是个 GUI 啊，他其实没有明白Xwindow 的好处。</p><p>你说我是 GUI 的？我虽然很少在 console 下工作。但是我对 bash, VIM 很熟悉，我可以让 bash 按照我的键绑定方式来工作。我可以在 rxvt 里使用 Mutt 来收发 email。我的每个桌面上都常常堆放着一打不同大小的 rxvt。我用 VIM 编辑 LaTeX。我自己写Makefile 来维护 LaTeX 文档。我有时用 mpg321 来放 mp3。我上BBS用的我自己写的expect 脚本。 好了，CLI 派的朋友可以收我做盟友了</p><p>你说我是 CLI 的老古董？我的 FVWM 被我配置为可以&quot;手写操作&quot;，我只要画一个&quot;r&quot;就可以启动 rxvt，我只要画一个 “U” 就可以启动 GVIM，…… 我用 GVIM 语法加亮模式编辑程序，我用 Mozilla 浏览网页，…… GUI 派的现在好像认我做朋友了</p><p>好了。CLI 派的朋友，虽然我很喜欢命令行，但是我有时在屏幕上左右画一下就可以执行:</p><p>Module FvwmConsole -terminal rxvt -geometry 45x5-0+0 -bg gold -fg midnightblue -fn “-adobe-courier-medium-r-<em>-</em>-14-<em>-</em>-<em>-</em>-<em>-</em>-*”</p><p>你是不是现在又想把我逐出师门？</p><p>GUI 派的朋友，虽然我很喜欢窗口。但是我可以在 FvwmConsole 里输入：</p><p>All (rxvt) MoveToDesk</p><p>把我所有的 rxvt 移动到我现在工作的桌面。“这家伙，怎么这么快就叛变了！”</p><p>其实何必分什么 GUI 和 CLI，UNIX 和 Xwindow 都是工业标准，它们从设计那天开始就有非常灵活的用法，各个程序，不管是 GUI 还是命令行的都可以互相协作。UNIX 和X 是一家，何必搞的那么偏激，非此即彼？你从我上面的行为可以看出 GUI 和 CLI的模糊界线吗？我就是坚定不移的&quot;两面派&quot;。</p><h1 id="unix-是简单的"><a class="markdownIt-Anchor" href="#unix-是简单的"></a> UNIX 是简单的</h1><p>“我相信简单就是最好，如果太复杂，我是不能理解的。” -Seymour Cray</p><p>很多第一次用 Linux 的人会惊奇的发现，Linux 的程序居然不?quot;安装&quot;就可以运行，程序拷贝到随便那个目录都可以用，而不是一定要占用你第一个分区的空间。程序的设置只是一些简简单单的文本文件。你根本不需要什么&quot;注册表修改器&quot; 就可以改变系统的设置。这就叫做简单，但是简单就是美。虽然这只是 UNIX 简单性的一个肤浅的认识，你已经体会到了某些东西。</p><p>但是简单并不意味着功能弱，并不意味着落后。相反，简单意味着强大，意味着生命力。</p><p>我不会再继续阐述我理解到的&quot;UNIX 的简单&quot;，因为这个需要自己去体会。</p><h1 id="unix-是永恒的"><a class="markdownIt-Anchor" href="#unix-是永恒的"></a> UNIX 是永恒的</h1><p>有人说：“Plan9 会取代 UNIX，Mach 会取代 Linux 内核。”</p><p>但是你如果是一个深入体会了 UNIX 的人，你就会知道：UNIX 的思想是永恒的，不管时过境迁，Plan9 是否代替 UNIX，UNIX 的灵魂都会在 Plan9 身上现形！</p><p>我为同一个设备写过 Linux 内核和 Windows VxD 驱动程序。写 Linux 驱动程序时，我对 UNIX 设计的完美的一致性，远见性所折服。UNIX 用同样界面的 read(), write()系统调用就可以对不同的对象：普通文件，设备文件，管道，管道文件，socket，……进行统一的读写操作。我跟本不需要写一个测试用的应用程序就可以对我的设备驱动进行测试，因为 cat, cp, dd, 它们也使用了同样的 read(), write()，设备和普通文件在应用程序眼里没有区别。在那个还没有 Smalltalk, 没有 C++ 的年代，UNIX 的设计者已经使用了所谓的 “面向对象方法”。对，C 语言也可以实现面向对象。</p><p>UNIX 的系统调用几十年都没有很大变化，这非但不是顽固，不进步的象征，反而是UNIX 的远见卓识的体现！这就跟 TeX 程序几十年都不变的情况差不多。这些才是真正的永恒的 master piece! 你应该改变所有软件都必需从 0.1, 1.0, 1.1, 1.2, 2.0,…, 3.0, 3.1, 95, 98, 2000, XP, … 不断升级的想法。</p><p>Windows 就不同了，它在最开头只是一个 DOS 之上的图形包装而已。后来为了兼容以前的糟糕设计，不得不加上很多累赘。我写 VxD 驱动程序的时候就深有体会，Windows 95 程序对设备的操作只有用 DeviceIoControl，我不得不写了两个应用程序来对设备驱动进行测试。Windows 内核的不一致性和隐密性使我非常恼火。不过 Windows WDM驱动程序现在也有了 ReadFile, WriteFile，…… 那说明什么？那说明 Windows 在向UNIX 学习，或者有可能是某个 UNIX 设计人员在微软打了几天临工，顺手加了几个UNIX 的东西进去。这样做是没有用的，Windows 从一开始就是非常糟糕的设计，它的历史的包袱太沉重了，缝缝补补有什么用？它只能永远的被 UNIX 甩在身后！</p><h1 id="unix-是强大的"><a class="markdownIt-Anchor" href="#unix-是强大的"></a> UNIX 是强大的</h1><p>让聪明人干任何他们想干的事情。</p><p>UNIX 的一个特点就是非常高的灵活性，Xwindow 也具有这种灵活性。这种灵活性体现在哪里呢？</p><p>UNIX 的程序一般都有很多参数，不管你现在用的着用不着，总有人需要某些参数。它们的行为很多都可以用配置文件来改变。比如 GNU bash, 通常缺省的命令行输入方式是 Emacs 方式，但是只要我编辑一个 .inputrc 文件，就可以把它变成 vi 的输入方式，而且我还可以自己绑定键序列到某些操作。我可以用 shopt 来设置它的很多特点，比如是否进行通配符扩展，是否可以把一个变量当作一个目录来cd，是否可以自动纠正某些明显的目录名打字错误 ……</p><p>UNIX 程序设计的思想是提供给用户&quot;机制&quot;，而不限制用户制定&quot;政策&quot;。这是一个重要的尊重用户的作法。</p><p>我们再来看看 Xwindow。Xwindow 是一个出色的设计，它把显示服务器和客户程序分开。一个显示上既可以显示本机上的程序，也可以显示别的机器上的 X 程序，而它们都遵守你的窗口管理器的统一指挥，它们之间可以方便的传送剪贴版数据，各种事件 …… 比如有时我的 XFree86 上会出现四个不同机器上的 XTerm，两个不同机器上的 GVIM，…… 它们统一受本机上的 FVWM 指挥。</p><p>Xwindow 程序都具有很多很多命令行参数和 resource 参数。你可以随意的在命令行或者 .Xdefaults 文件设置所有的颜色，字体，尺寸…… 而且如果你用 xrdb 把 .Xdefaults 导入到根窗口，那么其它机器上没有经过配置的同样的程序，显示到你的机器上的时候也会遵守同样的外观规定。</p><p>Xwindow 的窗口具有 Property, 也就是一些可以自己定义的共享数据(原子)。正是因为这些 Property 的存在，使得 Xwindow 具有无比强大的生命力。X 的窗口管理器和其它客户程序之间并没有统一的协议，但是后来出现了 ICCCM(客户程序间通信规范)，这个规范就是通过 property 定义的。现在又有人定义了一套&quot;扩展的窗口协议(EWM Hints)&quot;，使得Xwindow 可以具有某些 Windows 的特征，比如一个工具条程序可以告诉窗口管理器：“这个屏幕下面被我占据了24个像素的空间，你最大化程序的时候不要越过这个界线。”</p><p>一个强大的窗口管理程序比如 FVWM，它收到这样的提示时，可以答应工具条程序的这个要求，也可以不答应。一切选择的权力在于谁？当然是用户了！</p><p>你想想，是不是有些 Windows 程序常常弹出一个窗口要你选择 “Yes or No”？你不点击它它就不下去。你觉不觉得你的程序在侵犯你的尊严？你是一个人，一个智慧的生物，怎能受到一个程序如此的待遇？</p><p>还有就是很多 Windows 程序把人当成傻瓜，而它是&quot;智能程序&quot;。比如，有一个程序就是喜欢把你的每句话第一个字母都变成大写，我不说它是谁了，你遇到的时候就知道了。</p><p>如果连&quot;一句话开头一个字母要大写&quot;这么明显的问题都需要程序帮你纠正的话，人脑还用来干什么？况且如果你故意想要不大写的话，那就更麻烦了，我楞是没有从它那一大堆菜单里找到怎么关闭这个愚蠢的选项。</p><p>只有符号才能完全操纵计算机。</p><p>我们来说说很多初学 Linux 的用户。虽然他们在用 Linux，但是他们打心眼儿里是觉得Windows 的工作方式好，他们希望 Linux 有一天能&quot;像Windows那样&quot;。你说：“我的鼠标一点，我菜单一拉，…… 就可以完成我的操作。” 但是我要告诉你：&quot;Linux 从来没有摹仿 Windows，将来也不会。Linux 从诞生之日起，它的工作方式就比 Windows 的先进。</p><p>Linux 属于能勇敢面对符号的人。只有符号才能完全操纵计算机。&quot;</p><p>看看优秀的 UNIX 程序，XFree86, FVWM, VIM, Emacs, proftpd, Mutt, wget, tin, … 没有一个不是用配置文件来设置选项的。为什么这些程序没有方便的菜单可以用来配置？难道它们的设计者就那么低能，连个图形配置界面也写不出来？</p><p>当然不是。因为图形界面配置方式的能力是极其有限的，而配置文件和程序语言的表达能力却是无限的。用图形界面配置这些程序的话，如果你想达到配置文件的效果，你需要成百上千的菜单，checkbox, radio button, … 到时候你根本没办法找到你需要修改的地方了！而各个程序的配置文件的语法都有很多相似之处，一般就是一些命令，设置一些变量，参数，…… 一旦用会了一个，其它的也就容易理解了。如果你用惯了 awk, sed, Perl，你会觉得那才是真正的自动化啊。</p><p>鼠标虽然是很好的工具，但是它的表达能力是有限的。你不可能光用鼠标就让电脑完全明白你的意思，它毕竟只有3个按钮。看看我的MetaPost页你就能体会到鼠标的这一弱点。所以我们虽然很喜欢鼠标，但是却不能完全依赖它。</p><p>各个小程序的完美配合</p><p>这就是UNIX最重要的特点了，它就是UNIX设计的思想。让每个程序只具有一项专门的能力，然后让它们合作。Xwindow也继承了这种好传统。这恐怕就是Windows和其它操作系统望尘末及的地方了。UNIX 程序设计之统一，配合之完美，真使我难以置信！shell, grep, find, awk, sed, make, Perl, Emacs, vi, tin, Mutt, … 它们是那么的具有一致性！你一旦学会了 sed 的正则表达式，其它程序基本上都能用了。你一旦学会了vi 和 VIM, 你会发现它的操作是那么的有规律性，似乎vi的设计者在几十年前就已经设计好了 VIM 在今天的完美而统一的操作方式！而且vi的操作还体现在 Mutt, tin 等很多程序中。你甚至可以把 bash 设置为 vi 的输入方式来输入命令行，我就是这么做的。一个程序可以调用另外一个程序来得到数据，可以把数据交给它处理后返回来，可以在自己的窗口里&quot;嵌入&quot;另外一个程序。</p><p>在 Windows 和其它非 UNIX 操作系统中，这种合作是非常困难的。我曾经在Windows下使用 Perl来进行一些自动工作。但是 Windows 的文件操作，管道是如此的不稳定，程序之间基本不能合作。你别想在 Visual Studio 窗口里面嵌入 UltraEdit 编辑器，你别想用一个 expect 脚本来控制 telnet 到水木清华BBS。</p><p>Windows 的程序都是大而全，大而杂，所有的电子邮件程序都需要自己提供编辑器，自己发送和收取邮件，自己显示邮件的附件。每一个BBS程序都提供自己的 Virtual Terminal, 自己的通讯代码。每一个 IDE 都自己提供编辑器，编译器，汇编器，调试器。人们为了使用一种新的程序，需要适应所有这些它提供的界面，而不能使用自己喜欢的编辑器的键绑定，菜单组织…… 不能 DIY！</p><p>你要知道，最高级的电脑是定做的，自己想要什么什么CPU，什么主板，多少内存，什么硬盘，键盘，鼠标，显示器都是自己选择的。最高级的滑板，自己想要什么牌子的版面，什么牌子的沙，什么桥，什么轮子，什么轴承，也都是自己选的。最高级的古球拍，木板，胶皮，海绵，胶水都是可以自己选择…… 而用 Windows 程序，你得到的是大杂烩，就像你去买&quot;品牌机&quot;，只有那么几种配置，而且附带很多你不需要的软件和服务；就像你去买组装好的滑板，你想要大一点的轮子和窄一点的板子，但是你没有这种选择余地！Windows 程序就相当于最廉价，最次的滑板。但是它却会花你更多的钱，因为一旦一个部件坏了，或者你不喜欢了，你不能另外找一个好的换掉它，你必需重新买全套配件！</p><p>而 UNIX 和 Xwindow 就是高档的&quot;组装货&quot;。比如我用 Mutt 的时候，我可以用 VIM也可以用 pico 来编辑邮件，我可以用 ImageMagick 也可以用 xv 来显示附件里的图片，我可以用 lynx 把 HTML 附件转成文本嵌入窗口中，我也可以把 HTML 附件交给Mozilla 图形显示。我可以让 GnuPG 帮我把邮件进行数字签名和加密，我也可以用其它 PGP 程序。</p><p>我想让 Postfix 而不是 sendmail 帮我发出邮件，我想让 fetchmail 帮我收邮件，转发给 postfix，然后被我自己写的Perl过滤器处理…… 这一切我都可以办到！我可以选择我最喜欢的专门的程序来完成专门的工作，然后把它们结合在一起，我也可以分别得到它们的好处。</p><h1 id="学-unix-绝对不是浪费时间"><a class="markdownIt-Anchor" href="#学-unix-绝对不是浪费时间"></a> 学 UNIX 绝对不是浪费时间</h1><p>有人告诉我：“你看我用 Windows 什么都不用学。而用 Linux，光是安装就花了我一个星期！”</p><p>首先，我要告诉你的是，你装 Linux 花了一个星期，不是因为 Linux 不好装，而是因为你已经习惯了 Windows，对 Linux 最初难以理解而已。你想一想你最初安装Windows的时候呢？你花了多少时间搞明白什么是硬盘分区？什么是盘符？什么是目录？你认为Windows 就是那么容易可以学会的吗？虽然你觉得没花时间学，但是你以前在用别人的机器的时候已经耳濡目染，自然就了解了。而且由于你想要 Linux 和 Windows 并存于硬盘上，又增加了安装难度。而且你肯定没有得到有经验的 Linux 用户的帮助，否则他们会在20分种之内帮你搞定。一个星期也太夸张了.</p><p>如果一开始用的就是Linux就没有这个问题。你想想如果你没有用过 windows，你肯定会很习惯 /etc, /usr, /usr/local ,… 而不是 C:, D:, E:, … 是不是？如果你只用过Linux，你第一次用 windows 时恐怕也会问：&quot;/bin 目录哪里去了啊？&quot;</p><p>最重要的是，你用惯了的UNIX工具，它们可以伴随你一生，而不会那么容易变化或消失。你可以永远不用再换另外的工具了。除非那个工具比你这个好的太多，而且可以完全模拟你现在的工具。</p><p>我们实验室一个60多岁的老师，用vi, cc, make, …都几十年了，他以前的经验绝对没有白费，而且教会了我们一批又一批的学生。vi 伴随着 UNIX 的最初发行而诞生，直到今天还是世界上头两号编辑器之一！有些人的 FVWM 配置文件已经用了 10 多年，现在完全不经修改还可以用。</p><p>看看 Windows 的工具，你从 Borland C++ 换到 VC, 就必需适应新的环境：菜单不同了，颜色不同了，按钮不同了，帮助信息不同了，热键不同了，编译器参数，调试器功能也不同了，…… 那个时候恐怕花要花你很多时间去适应。当你刚刚适应了 VC, 你又要换成VJ, PowerBuilder, C++Builder, …</p><p>很多windows程序员都是这样，开头在dos下用Turbo C, 然后是 Borland C, VC, C++ Builder, …不断追赶微软的潮流。而且微软的SDK, MFC, .NET …… 什么都在不断变化，不断出问题，又不断的在修改…… Windows 程序员不得不买又厚又重的 Microsoft Press 的书籍，看了才一个月，又过时了。今天你才学会了写 VxD，明天你就必须用WDM 了。你不得不注册 MSDN 才能赶上 Microsoft 的步伐。很多人说：“计算机是贵族的专业。” 这就是微软一手造成的。</p><p>这些东西才是没完没了的浪费大家的时间和金钱的。这是是浪费生命！我们为什么不使用从诞生就那么一致和完美的 UNIX？你需要理解先进工具的设计理念。UNIX 的工具就像我们用的汽车，它的离合器，油门，刹车，方向盘，后视镜，永远都在同样的位置。用惯了的话，你对你的汽车的每一个部件都会了如指掌，甚至你自己都可以修车了。这难道不好吗？</p><p>有人说：“你说我们需要了解 UNIX，难道你要开车还必须了解汽车的结构吗？” 你去问问开车的司机，哪一个不了解汽车的结构的，那他的驾照就是混来的。你难道想要傻瓜型的&quot;微软牌汽车&quot;吗？我们来看看：</p><p>你买的微软牌汽车最开头只有一个座位，每加一个座位你得向汽车公司付钱。车上的防撞气囊不时会冒出来，说是为了你的安全。每开100英里要大修一次，每过一年要换一次引擎。附带的，你还必须换用由微软汽车公司指定的石油公司提供的新型号的机油。你的车出了问题，但是法律规定，你不准私自拆开你的汽车来修理，你必需到微软汽车公司指定的维修点去，需要付相当多的钱才能修好一个小毛病。</p><p>最可气的是，你每换一个型号的微软牌汽车，它的刹车和离合器都在不同的位置，你需要重新去考驾驶执照。如果这辆汽车在途中刹车失灵，你受了重伤，你也不能状告微软汽车公司，因为你买来汽车之后必须签一个合同，说&quot;由于微软牌汽车对你和家人造成的一切死伤，微软概不负责。&quot;</p><p>怎样完全用 GNU/Linux 工作</p><p>说了这么多 Windows 的不好。我还没有告诉你我怎么用 Linux 处理有些必要的事情。半年以前我由于中文老是配置不好，一直是双系统，不时需要重起到 Win2k 来处理汉字。后来我找到了 miniChinput, XSIM 和 SCIM 输入法。这下可以处理汉字了。而且 VIM 和Emacs 对汉字支持越来越好。我的大部分文本是用 VIM 编辑的，包括程序，信件，网页，LaTeX 论文，MetaPost 绘图语言。</p><p>我不用 Word 这样的程序写论文，而是用 LaTeX，因为这是世界上效果最好，最方便的论文工具，是大多数学术杂志要求的格式。幻灯都是用 ConTeXt 做的，用起来很简单，而且效果非常漂亮。你可以看看我的TeX介绍。</p><p>至于绘图，你可以用很多可视化的工具，比如 xfig，dia。但是对于我来说，任何可视化的工具都不能完成某些任务，我需要一种可以精确描述图形的语言。我找到了MetaPost。它简单又好用，而且效果是世界一流的。我的插图，如果不是图像，都是MetaPost 画出来的。</p><p>我曾经抱怨 mozilla-mail 经常突然消失，损坏我好几封快要完成的信件。后来我发现mozilla 的邮件处理程序确实是不稳定的，功能又弱，有经验的 UNIX 用户都不用这样的程序。Mutt 是一个非常稳定可靠的 UNIX 邮件处理程序，而且功能非常强大。我曾经为 Gnome 和 KDE 的不稳定而烦恼。现在我找到了非常强大的 FVWM。KDE，Gnome也能和 FVWM 一起工作。虽然 Gnome 和 KDE 总体不稳定，但是某些部件程序还不错，很多 gtk, Qt 的程序也很不错，它们很多都是可以独立于这些桌面环境运行的。</p><p>Linux 有很多强大方便的工作方式是 Windows 没有的，或者有类似的东西，但是很差劲或者用起来不方便。比如 ssh 服务，rsync，cvs，expect ……</p><h1 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论</h1><p>我写这么多的目的是什么？我希望喜欢 Linux 的朋友，完全清除微软和 Windows 灌输在你脑子里的谬论，别再相信它们所谓的&quot;新技术&quot;，别再追赶 Windows，因为追赶Windows ＝ 倒退。马克思有一个思想很重要，“新生事物并不一定是在最近出现的。”</p><p>UNIX，Xwindow, TeX 虽然都比 Windows 先出现，但是它们才是先进生产力的代表。我们要清楚的认识到什么才是真正的现代化，什么才是真正的自动化。</p><p>消除学计算机很难的幻觉，勇敢的拿起像 bash, FVWM, TeX, VIM, Emacs, Mutt ……这样强大的程序，勇敢的面对符号。不要再埋怨&quot;Linux 为什么不能像 Windows 那样&quot;，不要再浪费时间试用这样那样的程序，不要再忙着升级。你需要理解 UNIX 的工作方式，因为那是大多数科学家的工作方式。Linux 可以成为你的好朋友，你需要认识它，了解它，信任它，才能完全的靠它来高效的工作。当然，在游戏机，手机，掌上电脑里，或者在用电脑来娱乐的时候，用一些&quot;傻瓜软件&quot;还是不错的.</p><p>我希望小学，中学的计算机老师能够提高自己的素质，在孩子们的启蒙教育中充分利用Linux 神秘的特点，引起孩子们对数学，对符号的好奇心。诱导他们用计算机来解决世界上的有趣问题，而不要把教学的范围局限于计算机的操作和它自身的问题。</p><h1 id="附录-我用来处理日常事务的-linux-程序"><a class="markdownIt-Anchor" href="#附录-我用来处理日常事务的-linux-程序"></a> 附录: 我用来处理日常事务的 Linux 程序</h1><p>好了好了。我知道你发现自己应该转向 Linux，你很后悔当初为什么中了微软的邪。但是不要着急。因为这些东西本来只是工具，它们是用来完成你的主要任务的辅助而已。你以前选错了工具，这不要紧。你还是拥有你自己原来的专业技能，那才是最重要的。工具的东西只有慢慢适应转换，不能一蹴而就，否则你会感到非常没意思，甚至放弃。</p><p>如果你只想做一个像我这样的普通用户，主要目的是用 Linux 来完成自己的任务，那就可以不用系统管理员或者网络管理员的标准来要求自己，因为当一个系统和网络管理员确实很辛苦。这里我对实验室的网管同学鞠一躬，谢谢你的指点和帮助. 不用把你的机器当成网络服务器，不用开放没有必要的服务，设置好 ssh, ftp 已经足够了。这样会省去了解很多没必要了解的东西的时间。不用过度考虑&quot;安全&quot;，因为 Linux 缺省已经很安全了。不过你有兴趣了解更多那也无妨。</p><p>下面给出一些推荐使用的可以处理一般事情的程序。至于你的专业上要用到的科学和工程软件比如 Matlab, Mathematica, Maple, HSpice, Design Compiler, …… 还有其它物理上的，化学上的，生物上的 …… 都必然有 Linux 和 UNIX 的版本。当然他们很多不是免费的，不要总是觉得什么都应该免费，自由不等于免费。它们是经过很多人辛勤劳动的产物，是可靠的程序，它们物有所值。</p><p>下面列出我常用的一些 Linux 程序。一个列表里可能有很多，那是为了方便你来选择，我列出了比较信得过的。但其实很多只有第一个是我真正在用的，我不喜欢试用程序。我不是一个合格的网络管理员，我的服务器都只设置了我自己需要的功能，那样可以省去我很多麻烦。</p><p>Shell: bash。它结合了 csh 和 ksh 的优点，并且有 readline 功能，你可以随意绑定自己的键盘。</p><p>编辑器： VIM, Emacs。</p><p>程序开发： GCC, make, ld, Scheme48, j2sdk, Perl, Python, Tcl/Tk …</p><p>论文，幻灯工具：LaTeX, ConTeXt</p><p>绘图工具：MetaPost。这个语言太强了，以至于我只用它了。你不熟悉的话可以用 xfig, dia 来画一些流程图之类的图片。</p><p>图像处理：ImageMagick。其中的 import 程序可以屏幕抓图，convert 程序可以转换图像格式，display 可以显示图片和简单编辑(缩放，换质量，转格式，简单绘图，简单虑镜)。通常我就这么点需要。如果你要更强大的图像工具可以用 Gimp, 它几乎和Photoshop差不多。</p><p>自动管理工具：make。我可以用make来自动编译程序，自动编译文档，自动更新插图…… 全自动，而且不会重复劳动。</p><p>数值计算程序：SciLab。这个程序基本上可以代替 Matlab。</p><p>代数计算程序：MAXIMA。这个程序基于世界上最老的计算机代数系统之一: 由美国能源部(DOE)发行的 MIT Macsyma 系统。它是用 Common Lisp 实现的。很多现在的符号计算程序比如 Maple 都从 MAXIMA 身上学到很多东西。它现在经过 DOE 批准以GPL发行，永远是一个自由软件。</p><p>加密程序：GnuPG。我的 PGP 密钥就是它搞出来的。</p><p>打包，压缩程序。什么都有: tar, gzip, bzip2, zip, rar, …</p><p>虚拟光驱程序。Linux 不需要虚拟光驱程序，直接 mount 就行了。</p><p>ftp 服务器：proftpd, vsftpd。proftpd 功能很强，但是我只用了最简单的一种设置。</p><p>WWW 服务器：apache。(我一般没有开)</p><p>ftp 客户程序：lftp，ncftp。它们都是文本方式操作的，但是比起图形界面的方便的多。比如 lftp 几乎具有 bash 的所有方便功能，Tab 补全，bookmark, queue, 后台下载，镜像…… Linux 也有图形界面的 ftp 客户程序，但是大多不稳定，有很多问题。这就是很多人抱怨 Linux 不如 Windows 的一个小原因。还有很多人用 Wine 模拟 Windows 的leapftp，其实 lftp 比 leapftp 好很多，你需要的只是适应一下。</p><p>自动下载工具：wget。它非常稳定，有一次我下载一个程序，用 IE 和 Mozilla 下载回来的文件都是坏的，最后还是 wget 可靠的传输了数据。用它甚至可以镜像整个网站，比起WebZip 这样的 Windows 程序强多了，而且不会因为你不付钱就在下载回来的网页里强制插入广告。</p><p>虚拟终端：rxvt, xterm, gnome-terminal, mlterm, …</p><p>X server: XFree86</p><p>窗口管理器：FVWM。编译加入了 libstroke。</p><p>中文输入：XSIM。被我修改过以适应 FVWM 的需要。另外推荐你还可以用 SCIM。</p><p>email 处理：Mutt + Postfix + fetchmail</p><p>看 PDF, PS, DJVU 文件：Acrobat Reader, xpdf, GhostScript, gv, djvu工具包和netscape 插件。</p><p>看CAJ文档。我从来不看CAJ之类的文档，如果找不到PDF或PS，直接去图书馆借最好。</p><p>看网页：Mozilla, Phoenix, lynx。Mozilla-Xft 的显示效果比IE 好很多。</p><p>英汉字典：IBM智能词典，星际译王。</p><p>编辑网页：我用VIM 直接写 HTML。你如果想要图形方式的可以用其它的比如screem, BlueFish。</p><p>登录其它 UNIX, Linux 机器：openSSH, telnet。 我喜欢用 openSSH 把其它机器的X 程序通过 ssh 加密的隧道传到我机器上显示。</p><p>登录 Windows2000 server 的 display service: rdesktop，…我有一天试了一下，不错。后来就没有用过了。</p><p>同步程序：rsync。我用 rsync 通过 ssh 来跟某些机器同步数据，或者做自己机器上不同目录间的同步。</p><p>上BBS：rxvt(或任何一种终端) + telnet + chatbot(helloooo 机器人的程序)</p><p>QQ, ICQ: 我没有 QQ 或 ICQ。不过你可以用 Gaim, 它同时支持 QQ, ICQ 和很多其它的即时通信方式。ICQ 用户也可以用 Licq。</p><p>放录像：MPlayer, RealPlayer。MPlayer 太好了，直接就可以放 VCD, DVD, divx, wma, wmv … 用 Windows 的同学都很羡慕我，说 Windows 要放这个需要大堆插件。rm 最好还是用 realplayer 放，它也是免费的。</p><p>放音乐： xmms(mp3,ogg都可以), mpg321(放mp3), ogg123(放ogg)。mpg321 不如xmms管理音乐文件那么方便，但是有时我还是用 mpg321 放 mp3 作为背景音乐，因为懒得开一个xmms窗口:-)</p><p>游戏：我觉得 KDE 的那个 ksokoban(推箱子)，很好玩 😃</p><p>看 Word 文档。请 Word 用户把文档全部转为 PDF 或 PS 再给我，文档里没有特殊的格式干脆就用文本吧，何必那么麻烦。以前很奇怪的是，通知里本来没有什么特殊的格式居然还要发doc附件的email。现在好了，我们系发通知都用文本，PDF，甚至图片了。</p><p>其它程序：还有很多我需要用而你不一定用得着的。比如，Doctor Scheme,</p><p>Scheme48, Scsh, kawa…这些程序只有 Doctor Scheme 有Windows版本。还有很多幕后工作但是你一般不察觉的：xinetd, telnetd, sshd, crond, atd, lpd, … 他们都比 Windows 的对应者强的多，或者根本没有对应者。</p><h1 id="附-写给支持和反对完全用linux工作的人们"><a class="markdownIt-Anchor" href="#附-写给支持和反对完全用linux工作的人们"></a> 附: 写给支持和反对《完全用Linux工作》的人们</h1><p>作者：王垠</p><p>在一阵阵唾骂和欢呼声中，《完全用linux工作》被转载到了天涯海角。很多人支持我，也有很多人唾骂我。我不知道它是怎样流传到那么多地方，其实我不知道它都被转到哪里去了…… 我知道现在这篇文章又会罗里罗索写很长（因为我计划写这样一个东西已经很久了，坐在Emacs前面总是有一种巫师在炼丹的感觉……），所以先提出中心思想吧。中心思想就是：</p><p>我只是一个傻瓜。看《完全用Linux 工作》的时候请用你们自己的判断力。</p><p>几乎所有人都承认，那篇文章很偏激。当时的情况是这样，我用 Linux 的时候被一个同学鄙视了，说：“你怎么用像 DOS 一样落后的东西，真土！看我漂亮的 Win2000…” 这跟当面嘲笑别人老婆或者妈妈有什么区别？我义愤填膺啊，就几乎跟他吵起来。然后就写出了这篇文章放在主页上，叫了几个人来看。接着我珍爱的 TeX 又受到众人鄙视，于是我又写了一篇文章打击 Word，然后把 TeX 捧上了天。道理很简单，鄙视我喜欢的东西的人就是敌人 --邪教徒或者恐怖分子–他支持的我就反对，他反对的我就支持。为了使人信服，举例必用大科学家，世界一流大学，一流实验室的名号，虽然我不跟其中任何一种沾边。还好那时候我还不认识上帝，要不就打他的名字了。论据不管是实际经历还是自己推测的，先写上去再说。扬眉吐气啊！隔壁微软研究院的哥们居然都被我打动了，开始写 Linux 程序，学用 LaTeX 和 Emacs。不过几天之后我就把它删掉了，因为我自己都感觉到偏激。</p><p>于是就没管那篇文章了。可是没想到它竟然已经被转载到那么多地方，似乎引起不小的波澜。有段时间每天都收到十几封email，国内的，国外的，问技术问题的，夸我的，骂我的，讲道理的，鄙视我的，想交朋友的，语重心长的，号称要删掉机器上的 Windows 的…… 我的主页居然也占据了&quot;王垠&quot;在 Google 上的首选位置，把那个日本的什么王公贵族&quot;李王垠殿下&quot;都挤下去了。大家似乎都知道我天花乱坠的本事了，有人就想找我写文章向别人推荐商业软件，我很后悔没有趁机狠狠赚一笔。走到图书馆，亮出借书证，管理员张大了嘴说：“哇！你就是那个 Linux 牛人啊！”，也不知道他是褒是贬。甚至有人把他的 BBS 昵称都改成了&quot;坚决拥护精神领袖花生&quot; （花生是我的外号）。为此还骗到了好几顿报告?quot;报告&quot;是清华专用动词，意思是请客吃饭）。虽然我觉得自己身上没有什么值得自豪的东西，但是又有点为自己兴风作浪的本事感到惊讶。虽然我一再告诫自己要谦虚，但是不由的有一种毛泽东，甘地，甚至摩西的感觉。我更加体会到&quot;网络上没有人知道你是一头猪&quot;的真理性。其实，不但网络上没有人知道我是一头猪，实际生活中也没有人知道，其实我是一头笨猪。</p><p>这么长的时间之后，还有人写信给我说&quot;深受鼓舞&quot;，“提壶灌顶”，“对不起我还在用 Windows 给你写信”，“真想删掉Windows 啊” …… 我很好奇，我的文章真的有那么大的威力？我再看这篇文章，觉得有点惨不忍睹，看了开头就不忍心再看下去。我告诉同学我很后悔写了一篇这么偏激的文章，可是他?quot;徼枉必须过正，你没有错&quot;，所以我也搞不清楚自己这样写对不对，这样自责对不对。就像我从来不敢看自己照片，却有时被人称为帅哥，就让我无法判断自己是否帅一样。所以现在我就开始怀疑我自己是否真是一头笨猪。也许多年以后，我会正确的评价我的想法。就像我现在觉得我15岁的照片挺养眼一样，也许我会发现自己其实是一头聪明猪？</p><p>写这篇文章不是为了让自己免得被骂，也不是为了显示高深的猪的哲理。只是因为我深深的感到人应该有自己的判断力，不要简单的接受别人说的 DO’s 和 DONT’s。怀疑一切，同时又敞开心扉去了解一切。</p><p>看过《完全用Linux工作》的朋友，请仔细检查里面的 DO’s 和 DONT’s。</p>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件幻灭（译）</title>
    <link href="/e4be2a87/"/>
    <url>/e4be2a87/</url>
    
    <content type="html"><![CDATA[<p>Translated from English by 江成.</p><p><a href="https://tonsky.me/blog/disenchantment/zh/">转载自tonsky.me</a></p><span id="more"></span><p>我编程已经15年了。但是现在，我们的行业越来越不关注效率、简单性和卓越性，这让我对我的职业和整个IT行业感到沮丧。</p><p>作为对比，现代汽车工作效率可以达到当前引擎设计的98%的效率。现代建筑使用刚好的材料来搭建完成并且在一定条件下保持安全稳固。所有的飞机都收敛到最优的尺寸/形状/负载上，看上去基本一样。</p><p>反过来，只有软件行业，大家似乎普遍接受程序运行在1%甚至0.1%理论效率上。有人甚至对程序运行的多么低效而感到自豪，“我们为什么要担心程序低效，计算机有足够的计算能力。“</p><blockquote><p>@tveastman: 我有一个每天都要运行的Python程序，每次运行需要1.5秒。我花了六个小时用rust重写了这个程序，现在这个程序运行一次只需要0.06秒了。41年零24天以后，效率提升节约下来的时间补偿了我重写程序的六个小时。😃</p></blockquote><p>你可能听过这样的说辞：“程序员的时间比计算机时间宝贵多了“。这句话基本上反映出我们现在在极大的浪费计算资源。你会买百公里耗油100升，甚至1000升的汽车吗？在软件行业，我们一直这么做。</p><h1 id="所有软件都难以忍受的慢"><a class="markdownIt-Anchor" href="#所有软件都难以忍受的慢"></a> 所有软件都难以忍受的慢</h1><p>看看周围，现在笔记本电脑的性能是第一次登月载人航天飞船上电脑的几千倍。然后在最新的Macbook Pro电脑上，所有的网页都不能保持60帧的平滑滚动。我能用笔记本电脑流畅的玩游戏，看4K视频，但是不能平滑的滚动网页。这怎么能接受？</p><p>谷歌邮箱，谷歌旗下的网页应用，在谷歌自己开发的Chrome浏览器上，<a href="https://twitter.com/nikitonsky/statuses/968882438024941568">需要花费13秒的时间打开一个中等大小的电子邮件</a></p><p>它为邮件展开添加了动效，但是应用动效的是一个空白区域而不是邮件内容。为什么呢？因为只有这样动效才能达到一个不错的效果。不，不错的效果并不意味着每秒60帧，而只是意味着“尽可能的快“。我迫切想知道当120hz显示器成为主流的时候，Web社区会怎么回答动画效果的问题。现在连60hz刷新率都很难做到。</p><p>Windows10需要<a href="https://grumpy.website/post/0PeXr1S7N">花费30分钟来更新系统</a>，怎么可能需要这么长的时间呢？30分钟都够我完全格式化我的SSD硬盘，下载一个全新安装镜像，安装5次系统了。</p><blockquote><p>Pavel Fatin: 在编辑器里面输入文字是一个相对简单的过程，所以即使是285的主机都能够比较顺畅的输入文字。</p></blockquote><p>现代的编辑器的输入延迟比42年前开发的Emac编辑器高很多。编辑器啊！还有比编辑器更简单的吗？每敲击一次键盘，你所需要做的仅仅是更新一个小小的方形区域，但是现代的编辑器却不能在16毫秒内完成一次键入。16毫秒可是很多时间，一个3D游戏可以在这个时间内刷新整个屏幕，渲染成千上万的多边形。同时还处理用户输入，重新计算环境世界，动态加载或释放资源。为什么会有这么大差距？</p><p>一个普遍的趋势是，我们并没有得到更快且更多功能的软件。我们的硬件越来越快，但是软件越来越慢，同时功能并没有增加。所有的软件的运行速度都远低于理想值。你有没有想过为什么你的智能手机需要30到60秒的时间来启动。为什么它不能在1秒内启动？这里并没有硬件限制，我非常想看看是不是真的可以做到。我非常想知道如果我们尽力挖掘每个比特的性能，我们能达到什么样的极限，我们能探索出什么样的极限。</p><h1 id="所有软件都巨巨巨巨大无比"><a class="markdownIt-Anchor" href="#所有软件都巨巨巨巨大无比"></a> 所有软件都巨巨巨巨大无比</h1><p>软件体积在膨胀。仅仅是屏蔽所有的网页广告，网页应用的打开速度就能提升10倍。谷歌恳求大家不要再用AMP来搬起石头砸自己的脚了——这是一个不需要任何技术，只要一点点常识就能解决问题的技术解决方案。如果你去除掉膨胀，Web应用会变得非常快，这需要多聪明才能理解？</p><p>一个没有安装任何其他APP的安卓系统需要差不多6GB的存储空间。请停下来想一下，这是个多么巨大的数字。这里面到底有什么，高清电影吗？我猜大部分应该是代码：系统内核，驱动，字符串和资源等等，但是这些资源都不会很大。所以，一部智能手机到底有多少驱动程序系统才能撑这么大？</p><p>Windows95的大小是30MB。今天有些网页的都比这个大！Windows10大小是4GB，是Windows95的133倍大。但是Windows10比Windows95高级133倍吗？我的意思是，它们的基本功能是一样的。是的，我们有Cortana（Windows下的私人智能助理），但是它也不可能需要3970MB。我们先不管Windows10有哪些功能，难道安卓比它还复杂1.5倍？</p><p>谷歌的键盘应用需要150MB空间。一个绘制在屏幕上绘制30个键的程序的复杂程度真的是Windows95复杂程度的五倍吗？谷歌应用，基本上就是谷歌网页搜索的封装，需要350MB空间！谷歌Play服务，我基本不用，需要300MB空间，而且不能删除。</p><p>当我安装完必须的应用（社交，聊天，地图，打车，银行应用），我的手机只剩下差不多1GB的空间了。这里面完全没有游戏，没有音乐！回忆一下，当年一张磁盘就能存储操作系统，系统应用和你所有的数据内容。</p><p>你桌面的todo应用可能是基于Electron写的，所以它包含了一个<a href="https://josephg.com/blog/electron-is-flash-for-the-desktop/">Xbox 360控制器的用户态驱动</a>在里面，这个驱动能渲染3D图像，播放音频，用你的网络摄像头拍照。</p><p>一个简单的文本聊天应用因为其启动速度和内存消耗而被人诟病。是的，你应该将Slack划分为资源消耗型应用。但是我的意思是，聊天室和简单的文本编辑工具，这些应该都不是资源消耗型的应用才对。欢迎来到2018。</p><p>你可能会说，至少它能正常运行。是的，但是越大并不意味着越好。越大意味着有人失去控制了；越大意味着我们不知道到底在发生什么；越大意味着额外的复杂性，额外的性能开销，额外的不稳定性。这不是常态，也不应该成为常态。体积过大的应用应该是一种危险信号，应该避而远之。</p><h1 id="所有软件都在腐烂"><a class="markdownIt-Anchor" href="#所有软件都在腐烂"></a> 所有软件都在腐烂</h1><p>3年前，16GB存储空间的安卓手机能良好运行使用，但是到了今天，16GB在搭载安卓8.1的手机已经显得不够用了，因为安卓8.1的系统已经膨胀了至少两倍大。而且安卓8.1并没有带来明显的变化和功能提升，并没有变得更快或者优化更好，看上去也差不多。它就是这么膨胀了？</p><p>iPhone 4s发布时搭载最新的iOS5系统，但是很难运行iOS9系统。基本上来说，iOS9和iOS5其实是差不多的，iOS9并没有变得更高级，而且新的iPhone的硬件变得更强大了，所以事实上是软件变得越来越慢了。别担心—你得到了一个重要的能力…以相同的速度运行相同的应用！我就是不明白为什么。</p><p>从iOS 11开始，系统将不再支持32位的应用，这意味着，如果开发者没有赶在iOS11 发布之前修改好应用，或者开发者根本没有意愿去去修改已经完美运行很久的应用，那么这些应用将从应用商店消失。</p><blockquote><p>@jckarter: 在80年代，一个DOS程序不需要任何修改就能在大部分的计算机上运行。但是现在，Chrome的一次更新，就会可能让Javascript应用不能正常运行。</p></blockquote><p>现在能正常运行的网页，<a href="http://tonsky.me/blog/chrome-intervention/">可能10年</a>（或者更短时间内）后就不能兼容当时的浏览器了。</p><p>“你需要拼命的奔跑，才能保持呆在原地“。但是这有什么意义呢？是的，买了新手机或者新的MacBook我也会感到高兴，但是换上新设备只是为了运行变得越来越慢的应用吗？</p><p>我觉得，我们可以也应该做得更好。大家都只忙着应对现在的需求来构建软件，很少考虑长远。但是如果一个软件能运行更长久一些，不也是好事吗。</p><h1 id="差即是好"><a class="markdownIt-Anchor" href="#差即是好"></a> “差即是好”</h1><p>现在，没人知道，也没人有意愿知道。我们只是满怀希望的把几乎没用的东西丢出去，还美其名曰：“创业智慧“。</p><p>如果网页出现什么问题，只会提示你去刷新页面。谁有时间去研究到底什么地方出问题了？</p><p>即使在兼容的浏览器上，Web应用都会报出大量的“随机”JS错误。</p><p>整个网页/SQL 数据库的架构都建立在当用户浏览渲染出来的网页时不会去操作任何数据的假设（或者说希望）上。</p><p>大多数协作功能的实现都只是“尽力”保持数据一致和安全，然而在很多正常用户使用场景下都会丢失数据。你一定见过“你要保留哪个版本“的对话框。如今整个行业的标准如此之低，你的用户会感到高兴，至少你提供了一个这样的对话框。</p><p>不，对我来说，这个对话框的意思是：“我准备要删除某个文件了，你想要删除哪个？“，这对我来说，这是不可接受的。</p><p>Linux被设计成会随机销毁进程。然而它是现在最流行的服务端操作系统。</p><p>我所有的设备，总会出现这样或那样的问题。我的戴尔显示器经常要重启，因为里面运行着软件。隔空推送？如果你运气好，它能检测到你的设备，如果没检测到，你能做什么？蓝牙？蓝牙的协议如此复杂以至于<a href="https://thewirecutter.com/blog/understanding-bluetooth-pairing-problems/">蓝牙设备之间是不会互相通信的</a>，而且<a href="http://time.com/4358533/bluetooth-fix-how/">定时重启是解决问题的最佳方法。</a></p><p>而且我还没有提到<a href="https://twitter.com/internetofshit">物联网</a>。它有太多槽点了，我都不知道如何吐槽它。</p><p>我想为我的工作感到自豪。我想交付可以工作，稳定的东西。要做到这一点，我们需要了解我们正在构建的东西，包括内部和外部，而这在臃肿、过度设计的系统中是不可能做到的。</p><h1 id="编程也是一团糟"><a class="markdownIt-Anchor" href="#编程也是一团糟"></a> 编程也是一团糟</h1><p>现在好像没有人有兴趣构建高质量，快速，高效，持久，基础的东西了。就算多年前已经有高效的解决方案了，我们还在努力解决同样的问题：包管理，构建系统，编译器，编程语言设计，集成开发环境。</p><p>构建系统本质上就不可靠。即使所有的失效信息都在那里，还是需要时不时完全清理一下。我们完全可以让构建过程变得可靠，可预测，百分百可重现，只是没人觉得这很重要。多年来，NPM一直是“有时候可用”的状态。</p><blockquote><p>@przemyslawdabek: 对我来说，开发Node.js/Javscript项目，rm -rf node_modules 一直是我工作过程不可或缺的部分。</p></blockquote><p>提到编译时间，没人认为编译十几分钟甚至几小时是什么问题。不是说“程序员的时间更重要“吗？几乎所有的编译器，在没有带来明显的好处的情况下，都会在预编译和后编译阶段都会加上巨大的，有时甚至是灾难性的额外时间损耗。</p><p>你期望程序员做出理性的决定，然而有时候他们正好相反。例如，<a href="https://www.chrisstucchio.com/blog/2013/hadoop_hatred.html">即便在笔记本电脑上运行相同的任务比在Hadoop上更快的情况下，依然选择使用Hadoop。</a></p><p>当大多数电脑还不可靠的时候，机器学习和“人工智能（AI）”又将软件推向了靠猜测的阶段。</p><blockquote><p>@rakhim: 当某个APP或者服务宣称是“人工智能驱动”或“基于机器学习“的时候，我把它理解为“不可靠，不可预测，行为不可解释“。我尽量避免使用”AI“，因为我希望电脑是可靠的，可预测的，可解释的。</p></blockquote><p>我们在Linux上构建虚拟机，然后在虚拟机上构建Docker容器，就因为没人可以理清楚程序，编程语言和运行环境的混乱状况。我们用毯子盖在狗屎上，而不去处理。“Single binary”依然是Go语言的大卖点。不混乱 == 成功。</p><p>提到依赖关系。人们总是很轻松的加上过度工程化的“完整解决方案”去解决最简单的问题，而不去考虑代价。这些依赖关系又带来其他的依赖关系。最后你的依赖树会介于恐怖故事（天呐，这么大，而且到处是冲突）和喜剧（没道理我们需要依赖这些，但是<a href="https://medium.com/@jdan/i-peeked-into-my-node-modules-directory-and-you-wont-believe-what-happened-next-b89f63d21558">他们就是在依赖关系上</a>）之间。</p><p>如果不重启，程序就不能长时间正常工作。有时，<a href="https://docs.gitlab.com/ee/administration/operations/unicorn.html#unicorn-worker-killer">甚至都无法正常工作几天的时间</a>。程序经常出现随机的问题，但是没人知道为什么。</p><p>更糟糕的是，没人有时间停下来，仔细分析到底发生了什么。既然你又简单的方法，为什么要花费精力去寻根究底。增加AWS的实例，重启进程，重置整个数据库，添加看门狗程序，每20分钟重启应用，<a href="https://blog.timac.org/2017/0410-analysis-of-the-facebook-app-for-ios-v-87-0/">多次引用相同的资源</a>，压缩打包然后交付。快速迭代交付，不要修复。</p><p>这不是工程化，这是懒惰。工程化是深入理解性能，深入理解结构，深入理解你构建的局限性。在粗制滥造上粗制滥造正是背道而驰。如果要进步，我们需要理解我们在做什么，为什么要这么做。</p><h1 id="我们被困住了"><a class="markdownIt-Anchor" href="#我们被困住了"></a> 我们被困住了</h1><p>所有的软件都是在之前几乎不能工作的代码上叠上几乎不能工作的代码。代码量和复杂性持续增加，改正的可能性越来越小。</p><p>要想构建健康的生态，你需要倒回去完全重构。有时候你需要有所放弃，然后用更好的替换掉。</p><p>但是谁有时间这么做呢？我们应该有25年没有开发新的操作系统内核了吧？内核太复杂了，以至于没有办法重新写一个。浏览器充满了边缘情况和历史遗留问题，以至于现在没有人敢重头写一个布局引擎。</p><p>现如今进步的定义就像火上浇油：</p><blockquote><p>@sahrizv:</p></blockquote><blockquote><p>2014 - 为了解决单例应用的问题，我们一定要引入#微服务。</p></blockquote><blockquote><p>2016 - 为了解决微服务的问题，我们一定要引入#docker容器。</p></blockquote><blockquote><p>2018 - 为了解决docker容器的问题</p></blockquote><p>或是重复造轮子：</p><blockquote><p>@dr_c0d3:</p></blockquote><blockquote><p>2000: 写100行XML来声明式的配置servlets和EJBs。</p></blockquote><blockquote><p>2018: 写100行YAML来声明式的配置你的微服务。至少XML有结构模式</p></blockquote><p>我们被我们自己困住了，而且没人会拯救我们。</p><h1 id="业务并不关心"><a class="markdownIt-Anchor" href="#业务并不关心"></a> 业务并不关心</h1><p>用户同样不关心。用户只是学会只期待我们能提供的。我们（工程师）声称安卓应用需要350MB的空间？好吧，用户他们接受。我们声称我们没办法提供平滑的滚动？好吧，用户他们接受不流畅的手机。我们指导：“如果它不工作了，试着重启“？用户就会重启。毕竟，用户并没有其他选择。</p><p>行业也没有竞争。大家都在构建同样很慢，体积膨胀的，不可靠的产品。偶尔出现了高质量的产品马上就带了了竞争上的优势（iPhone/iOS对比其他智能手机，Chrome浏览器对比其他浏览器），也激励所有人向他们靠齐，但是这种情况持续不了很久。</p><p>所以，向世界展示以今天的计算机在性能，可靠性，质量，可用性上能达到什么程度，是我们工程师的使命。如果我们关注，人们也会学习到。而且也只有我们才能展示这是很有可能的，只要我们关注。</p><h1 id="并不是所有的都糟糕"><a class="markdownIt-Anchor" href="#并不是所有的都糟糕"></a> 并不是所有的都糟糕</h1><p>行业还是有一些亮点，也表明超越最先进的技术并不是不可能。</p><p>Martin Thompson 的工作（LMAX Disruptor, SBE, Aeron）就令人印象深刻，简单且高效，令人眼前一亮。</p><p>Raph Levien开发的Xi 编辑器 看起来有着正确的设计原则。</p><p>Jonathan Blow 自己开发给自己游戏开发用的编程语言，在笔记本上每秒可以编译50万行代码。而且是全新编译，没有中间缓存，没有增量编译。</p><p>编写高效的程序不需要你是天才。这并不需要什么魔法。只是不要在现在的臃肿不堪的工具链上去构建就行。</p><h1 id="更好世界宣言"><a class="markdownIt-Anchor" href="#更好世界宣言"></a> 更好世界宣言</h1><p>我希望看到进步。我希望改变。我希望最先进的软件开发技术得到提升，而不是停滞不前。我不希望看到不停的重复构建同一样东西，而且每次性能更差，体积更庞大。我希望有值得相信的目标，一个有价值的终极目标，一个比现在更好的未来，一个有相同愿景的工程师社区。</p><p>今天我们拥有的不是进步，我们用简陋的工具构建勉强符合业务需求的软件。我们被困在局部的最佳状态，没人愿意离开。这不是一个好地方，这里体积膨胀而且低效。我们只是习惯了而已。</p><p>所以我想提出：我们今天所在的地方是糟糕的。作为工程师，我们有能力也应该做得更好。我们应该有更好的工具，我们应该构建更好的应用，更快，更可预测，更可靠，资源消耗更低（低几个数量级！）。我们应该深入理解我们在做什么以及为什么要做。我们可靠、可预测、最高质量的交付。我们有能力也应该为我们的工作感到自豪。我们不应该只是“交付我们已有的。。。“，没有但是！</p><p>我希望我不孤单。我希望有更多的人也想这么做。如果我们现在能够开始讨论软件行业的现状有多糟糕，我也会感到欣慰。或许我们能找到出路。</p>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>互联网现状实录</title>
    <link href="/173106f8/"/>
    <url>/173106f8/</url>
    
    <content type="html"><![CDATA[<p>持续记录中</p><span id="more"></span><ol><li><p>傻逼在视频网站上的发的都是XX学习路线分享和XX软件分享,没有任何有学习价值的内容.其中XX学习路线通常需要加公众号获取,之后公众号每天就是转载B乎爆款文和培训班广告.</p></li><li><p>傻逼竖屏视频,进度条没的拖动,而且强制循环播放.</p></li><li><p>傻逼平台发布内容有字数限制,长文只能发成图片.阅读过程中误触一下图片就各种放大缩小.</p></li><li><p>傻逼手机安装自己的apk文件要扫描一年,然后告诉你不准安装或者引导你去应用商店下载特供版.</p></li><li><p>傻逼app把下载的文件藏到隐秘的角落里.除了他自己谁都不知道存到哪了.</p></li><li><p>傻逼平台要求各种复杂难记密码,但是最终是他们自己把密码泄漏出去而不是弱密码被破解.</p></li><li><p>傻逼群聊每天都是一群人在说那些一样的话,孜孜不倦的每天输出一样的字符串,像是进入了一个什么循环节.好像一群呼吸道疾病病友,每天都要聚在一起高强度吐痰,吐一样的痰.</p></li><li><p>傻逼网游要求每天登陆上去做什么日常活动,在你不想玩的时候强迫你.同时又每天有体力限制,在你非常想玩的时候只能玩一下子.</p></li><li><p>傻逼敏感词屏蔽词,屏蔽了之后网友只会把更多正常的词语变成脏话.</p></li><li><p>傻逼网友把一些毫不相关的词语都拿来当脏话用,包括当不限于:伞兵,逆天,导管,打胶.</p></li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>变长数组在栈上的内存分布</title>
    <link href="/2d6cc7c5/"/>
    <url>/2d6cc7c5/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h2><p>在编译期间,编译器会计算出一个函数中的所有局部变量需要使用多少的内存.这段内存称为函数的栈.</p><p>在执行一个函数的时候,会在两个寄存器中分别存有两个指针.</p><ol><li><p>栈底指针,指向这段内存的起始位置.在riscv指令集,这个指针通常存在寄存器<code>s0</code>中.</p></li><li><p>栈顶指针,指向这段内存的结束位置.在riscv指令集,这个指针通常存在寄存器<code>sp</code>中.</p></li></ol><p>这个栈是从高地址往低地址数的,也就是说栈顶指针的值其实比栈底指针小.他们的关系是</p><blockquote><p>栈底指针 - 栈大小 = 栈顶指针</p></blockquote><p>假如有函数<code>fun1()</code>调用了<code>fun2()</code>.</p><p>那么当执行到<code>fun2()</code>的时候,<code>fun2()</code>的栈底指针等于<code>fun1()</code>的栈顶指针.</p><p>也就是有这样的关系(假设<code>fun1</code>的栈底指针是<code>x</code>):</p><table><thead><tr><th>地址</th><th>含义</th></tr></thead><tbody><tr><td><code>x</code></td><td><code>fun1</code>的栈底指针</td></tr><tr><td><code>x-fun1的栈大小</code></td><td><code>fun1</code>的栈顶指针</td></tr><tr><td><code>x-fun1的栈大小</code></td><td><code>fun2</code>的栈底指针</td></tr><tr><td><code>x-(fun1的栈大小+fun2的栈大小)</code></td><td><code>fun2</code>的栈顶指针</td></tr></tbody></table><h2 id="疑惑"><a class="markdownIt-Anchor" href="#疑惑"></a> 疑惑</h2><h3 id="变长数组存储在哪"><a class="markdownIt-Anchor" href="#变长数组存储在哪"></a> 变长数组存储在哪</h3><p>我在刚学习编译原理的时候,错误地认为每个栈的大小都是在编译期就已经计算好固定了的.</p><p>所以我一直对C99的变长数组感到疑惑.</p><p>如果栈的大小是编译期确定的,也就是变长数组不能存储在栈上,那么它在哪?</p><p>如果变长数组位于栈上,那么它在栈上是怎么分布的,如何被计算出来?难道是在运行期间才能确定栈的大小吗?</p><h3 id="为什么编译器翻译出来的汇编常常使用栈底指针来表示变量的地址"><a class="markdownIt-Anchor" href="#为什么编译器翻译出来的汇编常常使用栈底指针来表示变量的地址"></a> 为什么编译器翻译出来的汇编常常使用栈底指针来表示变量的地址</h3><p>如果我们阅读汇编代码,会发现编译器翻译出来的汇编代码常常使用<code>栈底指针+偏移</code>的方式来指出栈上变量的位置.</p><p>只有在刚进入函数的时候,会用<code>栈顶指针+偏移</code>的方式保存上一个函数的信息到当前栈上.</p><p>我曾经非常困惑,如果统一使用<code>栈顶指针+偏移</code>不是更加便于理解吗?</p><h2 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论</h2><p>通过对变长数组的汇编代码的阅读, 我发现:</p><ol><li>变长数组确实在栈上.</li><li>栈的大小会在运行期改变.这个时候会修改栈顶指针.</li><li>编译器在翻译的时候会先计算栈的大小<code>x</code>(这个大小不包含变长数组).最初进入函数时,会先分配一个大小为<code>x</code>的栈.</li><li>刚进入函数时,<code>栈顶指针 = 栈底指针 - x</code></li><li>分配了这个大小为<code>x</code>的栈之后,会计算变长数组的大小<code>y</code>.然后直接以新的栈顶指针为变长数组的起始位置,向后再扩张<code>y</code>字节的内存.</li><li>最终,<code>栈顶指针 = 栈底指针 - (x + y)</code></li><li>栈底指针在这个过程中保持不变,因此我们可以一直用栈底指针来找到栈上变量.</li></ol><p>也就是:</p><table><thead><tr><th>地址区间</th><th>内容</th></tr></thead><tbody><tr><td><code>[栈底指针-x, 栈底指针)</code></td><td>函数中所有的局部变量(不包含变长数组)</td></tr><tr><td><code>[栈底指针-(x+y), 栈底指针-x)</code></td><td>函数中的局部变长数组(此时的地址区间<code>[栈顶指针,栈顶指针+元素大小)</code>是第0个元素的位置)</td></tr></tbody></table><h2 id="汇编句读"><a class="markdownIt-Anchor" href="#汇编句读"></a> 汇编句读</h2><h3 id="c语言"><a class="markdownIt-Anchor" href="#c语言"></a> C语言</h3><p>一开始我们写下这样的C程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><br>&#123;<br>    <span class="hljs-type">int</span> a[x];<br>    a[x<span class="hljs-number">-1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> a[x<span class="hljs-number">-1</span>];<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>    fun(x);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="汇编"><a class="markdownIt-Anchor" href="#汇编"></a> 汇编</h3><p>如果使用命令<code>riscv64-linux-gnu-gcc a.c -S -O0</code>生成<code>a.s</code>文件,会发现这个文件里有一些让人难以理解的无用计算(计算的结果直接被覆盖,没有用于任何用途).</p><p>例如这一段,大概可以猜测这里做了一个<code>128</code>位的乘法,但是计算出来的结果直接被覆盖.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asm"># 如果元素大小位2的k次方字节,那么这些数字将会是61-k, 3+k, k<br>srlia0,t1,59# a0 = t1 &gt;&gt; 59取t1(也就是数组长度x)的最高5位,保存到a5的最低5位上<br>sllia3,t2,5# a3 = t2 &lt;&lt; 5取t2(也就是0)的最低59位,保存到a3的最高59位上<br>ora3,a0,a3# a3 = a3 | a0将上面a5(最低5位有值)和a3(最高59位有值)组合起来,形成一个64位数字<br>sllia2,t1,5# a2 = t1 &lt;&lt; 5取t1(也就是数组长度x)的最低59位,保存到a2的最高59位上<br>mva3,a1# a3 = a1a3被数组长度x覆盖?<br>mva6,a3# a6 = a3<br>lia7,0# a7 = 0<br>srlia3,a6,59# a3 = a6 &gt;&gt; 59取a6(也就是数组长度x)的最高5位,保存到a3的最低5位上<br>sllia5,a7,5# a5 = a7 &lt;&lt; 5取a7(也就是0)的最低59位,保存到a5的最高59位上<br>ora5,a3,a5# a5 = a3 | a5将上面a3(最低5位有值)和a5(最高59位有值)组合起来,形成一个64位数字<br>sllia4,a6,5# a4 = a6 &lt;&lt; 5取a6(也就是数组长度x)的最低59位,保存到a4的最高59位上<br>mva5,a1# a5 = a1a5被数组长度x覆盖?<br></code></pre></td></tr></table></figure><p>如果使用命令<code>riscv64-linux-gnu-gcc a.c -S -Og</code>生成<code>a.s</code>文件,产生的汇编就会精简这些意义不明的运算,同时又不会过于精简.</p><p>所以下面我们使用加上<code>-Og</code>选项的汇编来讲解.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs asm"># 文件的信息:<br>.file&quot;a.c&quot;<br>.option pic<br># fun1的描述信息:<br>.text<br>.align1<br>.globlfun<br>.typefun, @function<br># fun1的汇编:<br>fun:<br>addisp,sp,-32<br>sdra,24(sp)<br>sds0,16(sp)<br>addis0,sp,32<br>laa4,__stack_chk_guard<br>lda5, 0(a4)<br>sda5, -24(s0)<br>lia5, 0<br>sllia5,a0,2<br>addia5,a5,15<br>andia5,a5,-16<br>subsp,sp,a5<br>addiwa0,a0,-1<br>sllia0,a0,2<br>adda0,sp,a0<br>lia5,1<br>sda5,0(a0)<br>lda3, -24(s0)<br>lda5, 0(a4)<br>xora5, a3, a5<br>lia3, 0<br>bnea5,zero,.L4<br>lia0,1<br>addisp,s0,-32<br>ldra,24(sp)<br>lds0,16(sp)<br>addisp,sp,32<br>jrra<br>.L4:<br>call__stack_chk_fail@plt<br># fun1的描述信息:<br>.sizefun, .-fun<br>.section.rodata.str1.8,&quot;aMS&quot;,@progbits,1<br>.align3<br># 字符串&quot;%d&quot;的信息:<br>.LC0:<br>.string&quot;%d&quot;<br># main的描述信息:<br>.text<br>.align1<br>.globlmain<br>.typemain, @function<br>main:<br>addisp,sp,-32<br>sdra,24(sp)<br>sds0,16(sp)<br>las0,__stack_chk_guard<br>lda5, 0(s0)<br>sda5, 8(sp)<br>lia5, 0<br>addia1,sp,4<br>llaa0,.LC0<br>call__isoc99_scanf@plt<br>lwa0,4(sp)<br>callfun<br>lda4, 8(sp)<br>lda5, 0(s0)<br>xora5, a4, a5<br>lia4, 0<br>bnea5,zero,.L8<br>lia0,0<br>ldra,24(sp)<br>lds0,16(sp)<br>addisp,sp,32<br>jrra<br>.L8:<br>call__stack_chk_fail@plt<br># main的描述信息:<br>.sizemain, .-main<br>.ident&quot;GCC: (Ubuntu 11.2.0-16ubuntu1) 11.2.0&quot;<br>.section.note.GNU-stack,&quot;&quot;,@progbits<br><br></code></pre></td></tr></table></figure><p>我们摘出<code>fun1()</code>的内容来看:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs asm">fun:<br>addisp,sp,-32<br>sdra,24(sp)<br>sds0,16(sp)<br>addis0,sp,32<br>laa4,__stack_chk_guard<br>lda5, 0(a4)<br>sda5, -24(s0)<br>lia5, 0<br>sllia5,a0,2<br>addia5,a5,15<br>andia5,a5,-16<br>subsp,sp,a5<br>addiwa0,a0,-1<br>sllia0,a0,2<br>adda0,sp,a0<br>lia5,1<br>swa5,0(a0)<br>lda3, -24(s0)<br>lda5, 0(a4)<br>xora5, a3, a5<br>lia3, 0<br>bnea5,zero,.L4<br>lia0,1<br>addisp,s0,-32<br>ldra,24(sp)<br>lds0,16(sp)<br>addisp,sp,32<br>jrra<br>.L4:<br>call__stack_chk_fail@plt<br></code></pre></td></tr></table></figure><h4 id="第一次分配栈内存"><a class="markdownIt-Anchor" href="#第一次分配栈内存"></a> 第一次分配栈内存</h4><p>首先,一进入函数就执行以下指令为栈分配了<code>32</code>字节的空间.并且保存了上一级函数的信息</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">addi</span>sp,sp,-<span class="hljs-number">32</span>   # sp = sp - <span class="hljs-number">32</span>  栈顶向下扩展<span class="hljs-number">32</span>字节, <span class="hljs-number">32</span>字节是一个预计的大小,<br><span class="hljs-attribute">sd</span>ra,<span class="hljs-number">24</span>(sp)       # *(sp+<span class="hljs-number">24</span>) = ra保存返回地址到[sp+<span class="hljs-number">24</span>, sp+<span class="hljs-number">32</span>), 也就是将来的[s0-<span class="hljs-number">8</span>, s0)<br><span class="hljs-attribute">sd</span>s0,<span class="hljs-number">16</span>(sp)       # *(sp+<span class="hljs-number">16</span>) = s0 保存上一级函数的栈底指针到[sp+<span class="hljs-number">16</span>, sp+<span class="hljs-number">24</span>), 也就是将来的[s0-<span class="hljs-number">16</span>, s0-<span class="hljs-number">8</span>)<br><span class="hljs-attribute">addi</span>s0,sp,<span class="hljs-number">32</span>    # s0 = sp + <span class="hljs-number">32</span>  计算出当前函数的栈底<br></code></pre></td></tr></table></figure><p>目前栈上的内存如下:</p><table><thead><tr><th>位置</th><th>内容</th></tr></thead><tbody><tr><td><code>[s0-8,s0)</code></td><td>返回地址</td></tr><tr><td><code>[s0-16, s0-8)</code></td><td>上一级函数的栈底指针</td></tr><tr><td><code>[sp, s0-16)</code></td><td>未使用</td></tr></tbody></table><h4 id="设置栈溢出标记"><a class="markdownIt-Anchor" href="#设置栈溢出标记"></a> 设置栈溢出标记</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">laa4,__stack_chk_guard    # 取出栈溢出标记的地址,放到寄存器a4<br>lda5, 0(a4)               # 取出存放在a4中的地址所指向的8个字节内容,存到a5<br>sda5, -24(s0)             # 将a5中的标记保存到[s0-24,s0-16),<br></code></pre></td></tr></table></figure><p>详情见另一篇文章<a href="/97bef05c/" title="stack_chk_guard避免栈溢出攻击">stack_chk_guard避免栈溢出攻击</a></p><p>目前栈上的内容如下:</p><table><thead><tr><th>位置</th><th>内容</th></tr></thead><tbody><tr><td><code>[s0-8,s0)</code></td><td>返回地址</td></tr><tr><td><code>[s0-16, s0-8)</code></td><td>上一级函数的栈底指针</td></tr><tr><td><code>[s0-24, s0-16)</code></td><td>栈溢出标记</td></tr><tr><td><code>[sp, s0-24)</code></td><td>未使用</td></tr></tbody></table><h4 id="计算变长数组大小"><a class="markdownIt-Anchor" href="#计算变长数组大小"></a> 计算变长数组大小</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">lia5, 0           # a5 = 0<br>sllia5,a0,2     # a5 = a0 &lt;&lt; 2(相当于a5=a0*4) 计算出数组大小,每个元素4字节<br>addia5,a5,15    # a5 = a5 + 15<br>andia5,a5,-16   # a5 = a5 &amp; (-16) 这两步是一个位运算的技巧,作用是将a5变为16的倍数(向上取整)<br></code></pre></td></tr></table></figure><p>这里的寄存器<code>a0</code>保存了参数<code>x</code>,这是riscv函数调用的习惯.</p><p>计算出数组的大小按照<code>16</code>字节对齐.</p><h4 id="第二次分配栈内存"><a class="markdownIt-Anchor" href="#第二次分配栈内存"></a> 第二次分配栈内存</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">subsp,sp,a5    # sp = sp - a5 <br></code></pre></td></tr></table></figure><p>栈顶指针再向下扩张<code>a5</code>个字节的大小.</p><p>目前栈上的内容如下:</p><table><thead><tr><th>位置</th><th>内容</th></tr></thead><tbody><tr><td><code>[s0-8,s0)</code></td><td>返回地址</td></tr><tr><td><code>[s0-16, s0-8)</code></td><td>上一级函数的栈底指针</td></tr><tr><td><code>[s0-24, s0-16)</code></td><td>栈溢出标记</td></tr><tr><td><code>[sp+数组大小, s0-24)</code></td><td>未使用</td></tr><tr><td><code>[sp, sp+数组大小)</code></td><td>变长数组</td></tr></tbody></table><h4 id="操作变长数组"><a class="markdownIt-Anchor" href="#操作变长数组"></a> 操作变长数组</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm">addiwa0,a0,-1    # a0 = a0 - 1 32位加法,计算x-1<br>sllia0,a0,2     # a0 = a0 &lt;&lt; 2(相当于a5=a0*4) 计算出第x-1个元素相对于数组起点的偏移<br>adda0,sp,a0        # a0 = sp + a0 计算出第x-1个元素的地址,也就是[sp+a0,sp+a0+元素大小)<br>lia5,1            # a5 = 1<br>sda5,0(a0)        # *(a0) = a5    给第x-1个元素赋值<br></code></pre></td></tr></table></figure><h4 id="检查栈溢出标记"><a class="markdownIt-Anchor" href="#检查栈溢出标记"></a> 检查栈溢出标记</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm">lda3, -24(s0)     # 取出之前的标记<br>lda5, 0(a4)       # 获取一个新的标记<br>xora5, a3, a5      # 将原本的标记和新的标记对比,从而检查就标记是否被修改<br>lia3, 0           <br>bnea5,zero,.L4     # 如果被修改,那么跳转到.L4<br></code></pre></td></tr></table></figure><p>可以认为地址<code>__stack_chk_fail@plt</code>存有一个处理检查异常的函数.</p><p>一旦检查不通过就会调用他来处理.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">.L4:<br>call__stack_chk_fail@plt<br></code></pre></td></tr></table></figure><h4 id="返回"><a class="markdownIt-Anchor" href="#返回"></a> 返回</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asm">lia0,1            # a0 = 1<br>addisp,s0,-32   # sp = s0 - 32 恢复第一次分配栈内存时的sp<br>ldra,24(sp)       # 取出之前保存的返回地址<br>lds0,16(sp)       # 取出之前保存的上一级函数的栈底地址<br>addisp,sp,32    # 恢复sp指针到进入函数之前<br>jrra              # 跳转到回上一级函数<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C语言与riscv汇编阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>riscv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flex和bison入门并且编写一个计算器</title>
    <link href="/3f5950fe/"/>
    <url>/3f5950fe/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="flex"><a class="markdownIt-Anchor" href="#flex"></a> flex</h2><p>flex是一个生成词法分析器的工具.</p><p>我们可以编写flex程序,输入到flex.</p><p>flex会输出一个c代码,这个c代码能够对我们在flex程序中描述的词法做词法分析.</p><p>编译这个c代码,可以得到一个可执行文件,这就是词法分析的程序.</p><p>如果我们把文本输入到这个可执行文件,就会得到输入文本的词法分析的结果.</p><h3 id="flex程序"><a class="markdownIt-Anchor" href="#flex程序"></a> flex程序</h3><p>一个flex程序通常包含三部分,形如</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode">&lt;声明部分&gt;<br><span class="hljs-meta">%</span><span class="hljs-meta">%</span><br>&lt;装换规则&gt;<br><span class="hljs-meta">%</span><span class="hljs-meta">%</span><br>&lt;辅助函数&gt;<br></code></pre></td></tr></table></figure><p>这三个部分用<code>%%</code>分割.</p><h4 id="声明部分"><a class="markdownIt-Anchor" href="#声明部分"></a> 声明部分</h4><p>声明部分包含了名称声明和选项设置.</p><p>其中<code>%&#123;</code>和<code>%&#125;</code>之间的内容会被原样复制到生成的C代码的开头,可以编写任意合法的C代码.就像这样</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-meta">%</span>&#123;<br><span class="hljs-comment">/*C代码*/</span><br><span class="hljs-meta">%</span>&#125;<br></code></pre></td></tr></table></figure><p>选项设置的语法如下:</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haml"><span class="hljs-tag">%<span class="hljs-selector-tag">option</span></span> yylineno noyywrap<br></code></pre></td></tr></table></figure><p>以<code>%option</code>开头.</p><p><code>yylineno</code>表示flex生成一个变量<code>yylineno</code>保存当前行号.</p><p><code>noyywrap</code>表示flex不使用<code>yywrap()</code>函数.</p><p>名称声明的语法如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">名字</span>&gt;</span> (<span class="hljs-tag">&lt;<span class="hljs-name">正则表达式</span>&gt;</span>)<br></code></pre></td></tr></table></figure><p>这个就是给正则表达式起一个别名.</p><p>关于正则表达式我找到一个<a href="https://support.google.com/analytics/answer/1034324?hl=zh-Hans">不错的文档</a>.</p><h4 id="装换规则"><a class="markdownIt-Anchor" href="#装换规则"></a> 装换规则</h4><p>每个规则包含模式和动作.</p><p>当词法分析器识别出某个模式时,将执行相应的动作.</p><p>形如:</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"><span class="hljs-variable">&lt;模式&gt;</span><br><span class="hljs-variable">&lt;模式&gt;</span> |<span class="hljs-string"></span><br><span class="hljs-string">&lt;模式&gt; </span>|<br><span class="hljs-variable">&lt;模式&gt;</span> &#123; <span class="hljs-variable">&lt;动作&gt;</span> &#125;<br></code></pre></td></tr></table></figure><p>这里<code>&lt;模式&gt;</code>是一个正则表达式,如果这一行后面没跟东西,那么就没有动作.</p><p>如果后面是一个<code>|</code>,那么表示这个模式和下一行的模式采取相同的动作.</p><p>动作本身用<code>&#123;&#125;</code>括起来.</p><p>在匹配的过程中,会尽量匹配长的字符串</p><p>如果可以匹配多个模式,则使用较早出现的模式.</p><h4 id="辅助函数"><a class="markdownIt-Anchor" href="#辅助函数"></a> 辅助函数</h4><p>可以包含任意合法的C代码,该部分的内容会被复制到生成的C代码中.</p><h2 id="bison"><a class="markdownIt-Anchor" href="#bison"></a> bison</h2><p>语法分析器,根据给定的语法规则将flex生成的token转换成抽象语法树(AST).</p><p>bison的输入是一个<code>.y</code>文件,输出C代码和一个头文件.</p><p>如果把bison和flex输出的C代码编到一起,就能得到一个用于将语言转换成语法树的可执行文件.</p><h3 id="bison语法"><a class="markdownIt-Anchor" href="#bison语法"></a> bison语法</h3><p>bison的输入<code>.y</code>文件包含以下内容.</p><h4 id="定义段"><a class="markdownIt-Anchor" href="#定义段"></a> 定义段</h4><p>在<code>%&#123;</code>和<code>%&#125;</code>之间,以C语法写的一些定义和声明,例如文件包含,宏定义,全局变量定义,函数声明.</p><p>对语法的终结符和非终结符做一些相关声明,形如</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">%<span class="hljs-tag">&lt;<span class="hljs-name">选项</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">值1</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">值2</span>&gt;</span> ...<br></code></pre></td></tr></table></figure><p>越后定义的终结符优先级越高.</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td><code>%token</code></td><td>定义词法中使用的终结符</td></tr><tr><td><code>%left</code></td><td>左结合</td></tr><tr><td><code>%right</code></td><td>右结合</td></tr><tr><td><code>%nonassoc</code></td><td>不可结合</td></tr><tr><td><code>%union</code></td><td>声明终结符的类型</td></tr><tr><td><code>%type</code></td><td>非终结符的类型</td></tr><tr><td><code>%start</code></td><td>声明起始规则,如果不声明,那就是第一个规则作为起始规则</td></tr></tbody></table><h4 id="语法规则段"><a class="markdownIt-Anchor" href="#语法规则段"></a> 语法规则段</h4><p>形如这样</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-built_in">exp</span> : <span class="hljs-built_in">exp</span> <span class="hljs-string">&#x27;+&#x27;</span> <span class="hljs-built_in">exp</span> &#123; <span class="hljs-symbol">$</span><span class="hljs-symbol">$</span> = newast(<span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-symbol">$</span><span class="hljs-number">1</span>, <span class="hljs-symbol">$</span><span class="hljs-number">3</span>)；&#125;<br>    | <span class="hljs-built_in">exp</span> CMP <span class="hljs-built_in">exp</span> &#123; <span class="hljs-symbol">$</span><span class="hljs-symbol">$</span> = newast(<span class="hljs-symbol">$</span><span class="hljs-number">2</span>, <span class="hljs-symbol">$</span><span class="hljs-number">1</span>, <span class="hljs-symbol">$</span><span class="hljs-number">3</span>)；&#125;<br>| <span class="hljs-string">&#x27;(&#x27;</span> <span class="hljs-built_in">exp</span> <span class="hljs-string">&#x27;)&#x27;</span> &#123; <span class="hljs-symbol">$</span><span class="hljs-symbol">$</span> = newast(<span class="hljs-symbol">$</span><span class="hljs-number">1</span>)；&#125;<br></code></pre></td></tr></table></figure><p>这里表示exp的几种形式,如果满足其中一种,那么就执行这种模式同一行的行为.</p><h4 id="辅助函数段"><a class="markdownIt-Anchor" href="#辅助函数段"></a> 辅助函数段</h4><p>可以包含任意合法的C代码,该部分的内容会被复制到生成的C代码中.</p><h2 id="实现计算器"><a class="markdownIt-Anchor" href="#实现计算器"></a> 实现计算器</h2><p>我觉得,如果使用bison和flex,应该是先写<code>calc.y</code>文件,再写<code>calc.l</code>文件.</p><p>因为<code>calc.y</code>文件经过bison处理之后,会产生一个<code>calc.tab.h</code>文件</p><p><code>calc.l</code>文件需要包含这个<code>calc.tab.h</code>文件.</p><p>也就是先写语法分析再写词法分析.</p><h3 id="语法分析"><a class="markdownIt-Anchor" href="#语法分析"></a> 语法分析</h3><p><code>calc.y</code>文件需要做以下事情</p><h4 id="定义段-2"><a class="markdownIt-Anchor" href="#定义段-2"></a> 定义段</h4><p>在定义段需要</p><ol><li><p>用<code>%&#123; &lt;C语言&gt; %&#125;</code>包含辅助函数所需的头文件.这里我们只需要<code>stdio.h</code>和<code>stdlib.h</code></p></li><li><p>用<code>%&#123; &lt;C语言&gt; %&#125;</code>声明函数<code>yylex()</code>和<code>yyerror()</code>.(<code>yylex()</code>不需要我们自己实现,flex会生成他的C代码,<code>yyerror()</code>我们需要在辅助函数段实现).其实不声明也可以,gcc能够自己找到他们的定义,但是会警告.</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">%&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">yylex</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">yyerror</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span></span>;<br>%&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>用<code>%union</code>定义我们要用到的类型,并给他们命名.这个例子里面我们只需要用到<code>double</code>,我们给他起名为<code>double_value</code>.</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">%union &#123;<br>  <span class="hljs-built_in">double</span> <span class="hljs-built_in">double</span>_value;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>用<code>%token</code>定义终结符,有一些终结符需要定义类型,定义类型使用上面<code>%union</code>中命名的类型.这里<code>DOUBLE_LITERAL</code>需要定义类型为上面的<code>double_value</code>.</li></ol><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haml"><span class="hljs-tag">%<span class="hljs-selector-tag">token</span></span> &lt;double_value&gt; DOUBLE_LITERAL<br><span class="hljs-tag">%<span class="hljs-selector-tag">token</span></span> ADD SUB MUL DIV CR LP RP<br></code></pre></td></tr></table></figure><p>这里的<code>ADD SUB MUL DIV CR LP RP</code>分别是加号,减号,乘号,除号.换行,左括号,右括号.</p><p>他们在词法分析中也有出现.</p><ol start="5"><li>用<code>%type</code>定义非终结符的类型,定义类型使用上面<code>%union</code>中命名的类型.</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-meta">%type</span> &lt;double_value&gt; expression term primary_expression<br></code></pre></td></tr></table></figure><p>这里的<code>expression</code>是只含加减操作和<code>term</code>的表达式.<code>term</code>是只含乘除操作和<code>primary_expression</code>的表达式.<code>primary_expression</code>是一个数字或带符号和括号的表达式.</p><p>显然这些表达式的结果都是<code>double</code>.</p><h4 id="语法规则段-2"><a class="markdownIt-Anchor" href="#语法规则段-2"></a> 语法规则段</h4><p>语法规则段则是定义各个符号由其他什么符号组成,匹配到之后采取什么行动.</p><p>默认第一个规则是起始规则,也就是输入的内容的整体,会被看作是第一个符号.</p><p>输入通常有多行,所以第一个规则定义一个<code>line_lists</code>,他可能是一个<code>line</code>,也可能是多行(也就是<code>line_lists</code>本身加上一个<code>line</code>)</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino">line_list<br>    : line<br>    | line_list line<br>    ;<br></code></pre></td></tr></table></figure><p>这个计算器中,一行放一个表达式,所以<code>line</code>由一个<code>expression</code>和一个换行组成.一旦匹配到<code>line</code>,那就输出<code>line</code>的值.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl">line<br>    : expression CR<br>    &#123;<br>        <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;&gt;&gt;%lf\n&quot;</span>, $1);<br>    &#125;<br></code></pre></td></tr></table></figure><p>其他的表达式定义如下,这里的<code>$$</code>代表这个符号本身的值,<code>$&lt;数值&gt;</code>代表组成这个符号的各个部分的值.</p><p>由<code>$&lt;数值&gt;</code>可以得到<code>$$</code>,你可以类比通过参数算出返回值.</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs powershell">expression<br>    : term<br>    | expression ADD term<br>    &#123;<br>        <span class="hljs-variable">$</span><span class="hljs-variable">$</span> = <span class="hljs-variable">$1</span> + <span class="hljs-variable">$3</span>;<br>    &#125;<br>    | expression SUB term<br>    &#123;<br>        <span class="hljs-variable">$</span><span class="hljs-variable">$</span> = <span class="hljs-variable">$1</span> - <span class="hljs-variable">$3</span>;<br>    &#125;<br>    ;<br>term<br>    : primary_expression<br>    | term MUL primary_expression<br>    &#123;<br>        <span class="hljs-variable">$</span><span class="hljs-variable">$</span> = <span class="hljs-variable">$1</span> * <span class="hljs-variable">$3</span>;<br>    &#125;<br>    | term DIV primary_expression<br>    &#123;<br>        <span class="hljs-variable">$</span><span class="hljs-variable">$</span> = <span class="hljs-variable">$1</span> / <span class="hljs-variable">$3</span>;<br>    &#125;<br>    ;<br>primary_expression<br>    : DOUBLE_LITERAL<br>    | SUB primary_expression<br>    &#123;<br>        <span class="hljs-variable">$</span><span class="hljs-variable">$</span> = -<span class="hljs-variable">$2</span>;<br>    &#125;<br>    | <span class="hljs-built_in">LP</span> expression <span class="hljs-built_in">RP</span><br>    &#123;<br>        <span class="hljs-variable">$</span><span class="hljs-variable">$</span> = <span class="hljs-variable">$2</span>;<br>    &#125;<br>   ;<br></code></pre></td></tr></table></figure><h4 id="辅助函数段-2"><a class="markdownIt-Anchor" href="#辅助函数段-2"></a> 辅助函数段</h4><p>这里实现<code>yyerror()</code>,用来打印一些信息.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">yyerror</span><span class="hljs-params">(<span class="hljs-type">char</span> <span class="hljs-type">const</span> *str)</span><br>&#123;<br>    <span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> *yytext;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;parser error near %s\n&quot;</span>, yytext);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个<code>yytext</code>在词法分析产生的代码中定义,应该就是当前扫到的文本.</p><p>生成的代码中没有<code>main()</code>,我们这里自己定义一个<code>main()</code>,以便后面可以编译成一个可执行文件.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">yyparse</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br>    <span class="hljs-keyword">extern</span> FILE *yyin;<br>    yyin = <span class="hljs-built_in">stdin</span>;<br>    <span class="hljs-keyword">if</span> (yyparse())<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Error ! Error! Error!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>yyparse</code>定义在bison生成的C代码中,他就是这一套操作下来生成的最关键的函数,负责语法分析的主要功能.</p><p>执行之后程序就会开始获取输入,直到遇到输入错误.</p><p>遇到错误会返回非<code>0</code>值.</p><h4 id="代码本体"><a class="markdownIt-Anchor" href="#代码本体"></a> 代码本体</h4><p>我们将它命名为<code>mycalc.y</code></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">%&#123;<br><span class="hljs-meta">#include &lt;stdio.h&gt;</span><br><span class="hljs-meta">#include &lt;stdlib.h&gt;</span><br><br><span class="hljs-type">int</span> yylex();<br><span class="hljs-type">int</span> yyerror(const <span class="hljs-type">char</span> *s);<br>%&#125;<br><br>%<span class="hljs-keyword">union</span> &#123;<br>  <span class="hljs-type">double</span> double_value;<br>&#125;<br><br>%token &lt;double_value&gt; DOUBLE_LITERAL<br>%token <span class="hljs-keyword">ADD</span> SUB MUL DIV CR LP RP<br><span class="hljs-meta">%type</span> &lt;double_value&gt; expression term primary_expression<br><br>%%<br><br>line_list<br>    : <span class="hljs-type">line</span><br>    | line_list <span class="hljs-type">line</span><br>    ;<br><span class="hljs-type">line</span><br>    : expression CR<br>    &#123;<br>        printf(&quot;&gt;&gt;%lf\n&quot;, <span class="hljs-meta">$1</span>);<br>    &#125;<br>expression<br>    : term<br>    | expression <span class="hljs-keyword">ADD</span> term<br>    &#123;<br>        $$<span class="language-pgsql"> = <span class="hljs-meta">$1</span> + <span class="hljs-meta">$3</span>;</span><br><span class="language-pgsql">    &#125;</span><br><span class="language-pgsql">    | expression SUB term</span><br><span class="language-pgsql">    &#123;</span><br><span class="language-pgsql">        $$</span> = <span class="hljs-meta">$1</span> - <span class="hljs-meta">$3</span>;<br>    &#125;<br>    ;<br>term<br>    : primary_expression<br>    | term MUL primary_expression<br>    &#123;<br>        $$<span class="language-pgsql"> = <span class="hljs-meta">$1</span> * <span class="hljs-meta">$3</span>;</span><br><span class="language-pgsql">    &#125;</span><br><span class="language-pgsql">    | term DIV primary_expression</span><br><span class="language-pgsql">    &#123;</span><br><span class="language-pgsql">        $$</span> = <span class="hljs-meta">$1</span> / <span class="hljs-meta">$3</span>;<br>    &#125;<br>    ;<br>primary_expression<br>    : DOUBLE_LITERAL<br>    | SUB primary_expression<br>    &#123;<br>        $$<span class="language-pgsql"> = -<span class="hljs-meta">$2</span>;</span><br><span class="language-pgsql">    &#125;</span><br><span class="language-pgsql">    | LP expression RP</span><br><span class="language-pgsql">    &#123;</span><br><span class="language-pgsql">        $$</span> = <span class="hljs-meta">$2</span>;<br>    &#125;<br>   ;<br><br>%%<br><br><span class="hljs-type">int</span> yyerror(<span class="hljs-type">char</span> const *str)<br>&#123;<br>    extern <span class="hljs-type">char</span> *yytext;<br>    fprintf(stderr, &quot;parser error near %s\n&quot;, yytext);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> main()<br>&#123;<br>    extern <span class="hljs-type">int</span> yyparse(<span class="hljs-type">void</span>);<br>    extern FILE *yyin;<br>    yyin = stdin;<br>    <span class="hljs-keyword">if</span> (yyparse())<br>    &#123;<br>        fprintf(stderr, &quot;Error ! Error! Error!\n&quot;);<br>        <span class="hljs-keyword">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="词法分析"><a class="markdownIt-Anchor" href="#词法分析"></a> 词法分析</h3><h4 id="声明部分-2"><a class="markdownIt-Anchor" href="#声明部分-2"></a> 声明部分</h4><ol><li>用<code>%&#123; &lt;C&gt; %&#125;</code>包含后面用到的头文件,这里需要<code>stdio.h</code>和上面bison生成的<code>mycalc.tab.h</code>.</li></ol><p>这里的<code>mycalc.tab.h</code>定义了各种符号的枚举值,词法分析的作用就是根据读到的内容,返回一个在<code>mycalc.tab.h</code>中定义的枚举值.</p><p>执行<code>bison -d mycalc.y</code>可以产生这个头文件和C文件.</p><ol start="2"><li>定义一个函数<code>yywrap()</code>.</li></ol><p><code>yywrap()</code>函数的作用是将多个输入文件打包成一个输入，当<code>yylex()</code>函数读入到一个文件结束时，它会向<code>yywrap</code>函数询问，<code>yywrap</code>函数返回<code>1</code>的意思是告诉<code>yylex</code>函数后面没有其他输入文件了，此时<code>yylex</code>函数结束, <code>yywrap</code>函数也可以打开下一个输入文件，再向<code>yylex</code>函数返回<code>0</code>，告诉它后面还有别的输入文件，此时<code>yylex</code>函数会继续解析下一个输入文件。总之，由于我们不考虑连续解析多个文件，因此此处返回<code>1</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">%&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mycalc.tab.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">yywrap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<br>%&#125;<br></code></pre></td></tr></table></figure><h4 id="转换规则"><a class="markdownIt-Anchor" href="#转换规则"></a> 转换规则</h4><p>这里主要是各种正则表达式,以及匹配到之后的操作.</p><p>这里匹配到运算符就直接返回一个枚举.</p><p>如果匹配到一个数值,就赋值给<code>yylval</code>.然后返回枚举<code>DOUBLE_LITERAL</code>.</p><p><code>yylval</code>其实就是上面定义的联合体,里面有<code>double_value</code>.</p><p>遇到空白符号无操作.</p><p>其他所有字符(正则表达式<code>.</code>),就报错并且<code>exit(1)</code>.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-string">&quot;+&quot;</span>    &#123; <span class="hljs-keyword">return</span> ADD;&#125;<br><span class="hljs-string">&quot;-&quot;</span>    &#123; <span class="hljs-keyword">return</span> SUB;&#125;<br><span class="hljs-string">&quot;*&quot;</span>    &#123; <span class="hljs-keyword">return</span> MUL;&#125;<br><span class="hljs-string">&quot;/&quot;</span>    &#123; <span class="hljs-keyword">return</span> DIV;&#125;<br><span class="hljs-string">&quot;(&quot;</span>    &#123; <span class="hljs-keyword">return</span> LP; &#125;<br><span class="hljs-string">&quot;)&quot;</span>    &#123; <span class="hljs-keyword">return</span> RP;&#125;<br><span class="hljs-string">&quot;\n&quot;</span>   &#123; <span class="hljs-keyword">return</span> CR;&#125;<br>[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]*(\.[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]+)? &#123;<br>    double temp;<br>    sscanf(yytext, <span class="hljs-string">&quot;%lf&quot;</span>, &amp;temp);<br>    yylval.double_value = temp;<br>    <span class="hljs-keyword">return</span> DOUBLE_LITERAL;<br>&#125;<br>[ \t] ;<br>. &#123;<br>    fprintf(stderr, <span class="hljs-string">&quot;lexical error.\n&quot;</span>);<br>    exit(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="辅助函数-2"><a class="markdownIt-Anchor" href="#辅助函数-2"></a> 辅助函数</h4><p>不需要</p><h4 id="代码本体-2"><a class="markdownIt-Anchor" href="#代码本体-2"></a> 代码本体</h4><p>把这个文件命名为<code>mycalc.l</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp">%&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mycalc.tab.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">yywrap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<br>%&#125;<br><br>%%<br><br><span class="hljs-string">&quot;+&quot;</span>    &#123; <span class="hljs-keyword">return</span> ADD;&#125;<br><span class="hljs-string">&quot;-&quot;</span>    &#123; <span class="hljs-keyword">return</span> SUB;&#125;<br><span class="hljs-string">&quot;*&quot;</span>    &#123; <span class="hljs-keyword">return</span> MUL;&#125;<br><span class="hljs-string">&quot;/&quot;</span>    &#123; <span class="hljs-keyword">return</span> DIV;&#125;<br><span class="hljs-string">&quot;(&quot;</span>    &#123; <span class="hljs-keyword">return</span> LP; &#125;<br><span class="hljs-string">&quot;)&quot;</span>    &#123; <span class="hljs-keyword">return</span> RP;&#125;<br><span class="hljs-string">&quot;\n&quot;</span>   &#123; <span class="hljs-keyword">return</span> CR;&#125;<br>[<span class="hljs-number">0</span><span class="hljs-number">-9</span>]*(\.[<span class="hljs-number">0</span><span class="hljs-number">-9</span>]+)? &#123;<br>    <span class="hljs-type">double</span> temp;<br>    <span class="hljs-built_in">sscanf</span>(yytext, <span class="hljs-string">&quot;%lf&quot;</span>, &amp;temp);<br>    yylval.double_value = temp;<br>    <span class="hljs-keyword">return</span> DOUBLE_LITERAL;<br>&#125;<br>[ \t] ;<br>. &#123;<br>    <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;lexical error.\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br>%%<br></code></pre></td></tr></table></figure><h3 id="编译"><a class="markdownIt-Anchor" href="#编译"></a> 编译</h3><p>执行这个命令生成语法分析代码</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">bison </span>-dv mycalc.y<br></code></pre></td></tr></table></figure><p><code>-d</code>表示生成头文件,<code>-v</code>表示同时生成一个<code>.output</code>文件,这里面有一些详情.</p><p>执行这个命令生成词法分析代码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex</span> mycalc<span class="hljs-selector-class">.l</span><br></code></pre></td></tr></table></figure><p>这时候会得到<code>lex.yy.c</code>(词法分析), <code>mycalc.tab.c</code>(语法分析), <code>mycalc.tab.h</code>(头文件).</p><p>用以下命令,把他们编译可执行文件<code>mycalc</code>.</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">cc</span> -o mycalc mycalc.tab.<span class="hljs-keyword">c</span> lex.yy.<span class="hljs-keyword">c</span><br></code></pre></td></tr></table></figure><p>然后可以手动测试一下这个可执行文件.</p>]]></content>
    
    
    <categories>
      
      <category>经验和总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>bison</tag>
      
      <tag>flex</tag>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stack_chk_guard避免栈溢出攻击</title>
    <link href="/97bef05c/"/>
    <url>/97bef05c/</url>
    
    <content type="html"><![CDATA[<ul><li>__stack_chk_guard的作用;</li></ul><span id="more"></span><h2 id="栈溢出攻击"><a class="markdownIt-Anchor" href="#栈溢出攻击"></a> 栈溢出攻击</h2><p>如果了解riscv的函数调用,会知道这样一件事:</p><p>进入一个函数之后,程序会把返回地址和原本的<code>s0</code>寄存器的值,存到栈的开头.</p><p>就像这样</p><table><thead><tr><th>地址</th><th>内容</th></tr></thead><tbody><tr><td><code>[sp+24, sp+32)</code></td><td>返回地址寄存器<code>ra</code>的值</td></tr><tr><td><code>[sp+16, sp+24)</code></td><td>进入函数之前,寄存器<code>s0</code>的值</td></tr><tr><td><code>[sp,sp+16)</code></td><td>其他内容</td></tr></tbody></table><p>着看起来没啥毛病,但是黑客不这么认为.</p><p>如果这个函数有一个读取输入的语句,并且可以输入很长的内容.</p><p>比如你让用户输入一个字符串,并存到栈上,但是没有对字符串的长度做限制.</p><p>那么输入的字符串就会把栈前面的数据也覆盖掉.</p><p>这时候攻击者可以输入一个超长的字符串,覆盖掉栈上记录的返回地址.</p><p>从而使函数返回时,跳转到攻击者想要的位置.</p><h2 id="gcc的手段"><a class="markdownIt-Anchor" href="#gcc的手段"></a> gcc的手段</h2><p>如果我们在一个函数获取输入,并且存到一个局部变量中.</p><p>那么编译器除了会生成功能相关的代码之外,还会一些额外的代码,对一个叫做<code>__stack_chk_guard</code>的符号进行操作.</p><p>例如以下代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们使用<code>riscv64-linux-gnu-g++</code>编译,会产生以下汇编代码(节选)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp">main:<br>addisp,sp,<span class="hljs-number">-32</span> # 栈顶指针<span class="hljs-number">-32</span><br>sdra,<span class="hljs-number">24</span>(sp) <span class="hljs-meta"># ra存到sp+24</span><br>sds0,<span class="hljs-number">16</span>(sp) # s0存到sp+<span class="hljs-number">16</span><br>addis0,sp,<span class="hljs-number">32</span> # 计算新的栈底地址,s0=sp+<span class="hljs-number">32</span><br>laa5,__stack_chk_guard # 加载__stack_chk_guard的地址到寄存器a5<br>lda5,<span class="hljs-number">0</span>(a5) # 加载寄存器a5中所存的地址指向的内容到寄存器a5<br>sda5,<span class="hljs-number">-24</span>(s0) # 把寄存器a5中的内容存到s0<span class="hljs-number">-24</span>(也就是sp+<span class="hljs-number">8</span>)<br>swzero,<span class="hljs-number">-28</span>(s0) # 下面是输入的操作,不再多说<br>addia5,s0,<span class="hljs-number">-28</span><br>mva1,a5<br>llaa0,.LC0<br>call__isoc99_scanf@plt<br>lia5,<span class="hljs-number">0</span> # 把返回值传到寄存器a3中<br>mva3,a5<br>laa5,__stack_chk_guard # 再次加载__stack_chk_guard的地址到寄存器a5<br>lda4,<span class="hljs-number">-24</span>(s0) # 把之前存到sp+<span class="hljs-number">8</span>的内容拿出来,放到寄存器a4<br>lda5,<span class="hljs-number">0</span>(a5) # 加载寄存器a5中所存的地址指向的内容到寄存器a5<br>beqa4,a5,.L3 # 对比寄存器a4,a5的内容,如果相同就跳转到.L3<br>call__stack_chk_fail@plt # 否则报错<br>.L3<br>mva0,a3 # 返回值传到寄存器a0<br>ldra,<span class="hljs-number">24</span>(sp) # 取出之前的ra<br>lds0,<span class="hljs-number">16</span>(sp) # 取出之前的s0<br>addisp,sp,<span class="hljs-number">32</span> <span class="hljs-meta"># sp恢复到-32前</span><br>jrra # 跳转到返回地址ra<br></code></pre></td></tr></table></figure><p>很显然,这个栈的布局是这样的</p><table><thead><tr><th>地址</th><th>内容</th></tr></thead><tbody><tr><td><code>[sp+24, sp+32)</code></td><td>返回地址寄存器<code>ra</code>的值</td></tr><tr><td><code>[sp+16, sp+24)</code></td><td>进入函数之前,寄存器<code>s0</code>的值</td></tr><tr><td><code>[sp+8,sp+16)</code></td><td><code>__stack_chk_guard</code></td></tr><tr><td><code>[sp+4,sp+8)</code></td><td>栈上定义的变量</td></tr></tbody></table><p>另外多出一点,因为需要对齐.</p><p>我们在进入函数之前把一个数值<code>__stack_chk_guard</code>存到了栈上定义的变量之前.</p><p>在返回前,又把之前存的数值拿出来,和原本的<code>__stack_chk_guard</code>进行对比.</p><p>如果没有发生变化,就说明输入的时候没有没有影响到<code>sp+8</code>之前的值.</p><p>因为输入操作的影响通常是连续的,我们可以认为只要<code>sp+8</code>没有变化,前面的值就没有被影响.</p><p>因为<code>__stack_chk_guard</code>是一个随机值,攻击者应该无法将一模一样的值写回去.</p><p>这时候可以认为返回地址是安全的.</p>]]></content>
    
    
    <categories>
      
      <category>C语言与riscv汇编阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>riscv</tag>
      
      <tag>栈溢出</tag>
      
      <tag>汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于全局变量的地址总是在变这件事</title>
    <link href="/40b27038/"/>
    <url>/40b27038/</url>
    
    <content type="html"><![CDATA[<ul><li>fPIC;</li><li>fno-pic;</li></ul><span id="more"></span><h2 id="起因"><a class="markdownIt-Anchor" href="#起因"></a> 起因</h2><p>如果我们写这样的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* a.cpp */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, &amp;a);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后用命令<code>g++ a.cpp</code>编译.</p><p>会发现每次执行都输出了不同的地址.</p><p>这是因为默认开启了pic,则会让程序产生位置无关的代码.</p><p>程序每次执行,会把各段数据放到一个随机的位置.只保证text段,rodata段等等内容的相对位置确定.</p><p>也就是说每次执行,text段的地址不确定,那么取地址的相关指令所在的位置也不确定.</p><p>执行到取地址的指令时,pc寄存器所存的地址也不确定.</p><p>但是由于各段数据的相对位置是确定的,我们可以知道pc所在的text段,和全局变量所在的rodata段的距离.</p><p>这时候只需要求<code>pc+偏移</code>,就可以知道全局变量所在的地址.</p><p>这时候就会每次执行输出不同的地址.</p><h2 id="汇编代码对比"><a class="markdownIt-Anchor" href="#汇编代码对比"></a> 汇编代码对比</h2><p>我们对比<code>riscv64-linux-gnu-gcc</code>编译上面的代码,生成的汇编代码.</p><p>我们只能用<code>-S</code>参数编译,而不能链接.</p><p>因为关闭pic之后,链接会报错.</p><p>前者是关闭pic,也就是加上<code>-fno-pic</code>参数.</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">.file<span class="hljs-string">&quot;a.cpp&quot;</span><br>.option <span class="hljs-keyword">nopic</span><br><span class="hljs-keyword"></span><span class="hljs-meta">.text</span><br><span class="hljs-meta">.section</span>.sdata,<span class="hljs-string">&quot;aw&quot;</span><br><span class="hljs-meta">.align</span><span class="hljs-number">2</span><br>.type_ZL1a, @object<br>.size_ZL1a, <span class="hljs-number">4</span><br><span class="hljs-symbol">_ZL1a:</span><br><span class="hljs-meta">.word</span><span class="hljs-number">1</span><br><span class="hljs-meta">.section</span>.rodata<br><span class="hljs-meta">.align</span><span class="hljs-number">3</span><br><span class="hljs-symbol">.LC0:</span><br>.string<span class="hljs-string">&quot;%p\n&quot;</span><br><span class="hljs-meta">.text</span><br><span class="hljs-meta">.align</span><span class="hljs-number">1</span><br>.globlmain<br>.typemain, @function<br><span class="hljs-symbol">main:</span><br><span class="hljs-symbol">.LFB0:</span><br>.cfi_startproc<br><span class="hljs-keyword">addi</span><span class="hljs-built_in">sp</span>,<span class="hljs-built_in">sp</span>,-<span class="hljs-number">16</span><br>.cfi_def_cfa_offset <span class="hljs-number">16</span><br>sd<span class="hljs-built_in">ra</span>,<span class="hljs-number">8</span>(<span class="hljs-built_in">sp</span>)<br>sd<span class="hljs-built_in">s0</span>,<span class="hljs-number">0</span>(<span class="hljs-built_in">sp</span>)<br>.cfi_offset <span class="hljs-number">1</span>, -<span class="hljs-number">8</span><br>.cfi_offset <span class="hljs-number">8</span>, -<span class="hljs-number">16</span><br><span class="hljs-keyword">addi</span><span class="hljs-built_in">s0</span>,<span class="hljs-built_in">sp</span>,<span class="hljs-number">16</span><br>.cfi_def_cfa <span class="hljs-number">8</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">lui</span><span class="hljs-built_in">a5</span>,%hi(_ZL1a)<br><span class="hljs-keyword">addi</span><span class="hljs-built_in">a1</span>,<span class="hljs-built_in">a5</span>,%lo(_ZL1a)<br><span class="hljs-keyword">lui</span><span class="hljs-built_in">a5</span>,%hi(.LC0)<br><span class="hljs-keyword">addi</span><span class="hljs-built_in">a0</span>,<span class="hljs-built_in">a5</span>,%lo(.LC0)<br>callprintf<br>li<span class="hljs-built_in">a5</span>,<span class="hljs-number">0</span><br>mv<span class="hljs-built_in">a0</span>,<span class="hljs-built_in">a5</span><br>ld<span class="hljs-built_in">ra</span>,<span class="hljs-number">8</span>(<span class="hljs-built_in">sp</span>)<br>.cfi_restore <span class="hljs-number">1</span><br>ld<span class="hljs-built_in">s0</span>,<span class="hljs-number">0</span>(<span class="hljs-built_in">sp</span>)<br>.cfi_restore <span class="hljs-number">8</span><br>.cfi_def_cfa <span class="hljs-number">2</span>, <span class="hljs-number">16</span><br><span class="hljs-keyword">addi</span><span class="hljs-built_in">sp</span>,<span class="hljs-built_in">sp</span>,<span class="hljs-number">16</span><br>.cfi_def_cfa_offset <span class="hljs-number">0</span><br><span class="hljs-keyword">jr</span><span class="hljs-built_in">ra</span><br>.cfi_endproc<br><span class="hljs-symbol">.LFE0:</span><br>.sizemain, .-main<br>.ident<span class="hljs-string">&quot;GCC: (Ubuntu 10.3.0-8ubuntu1) 10.3.0&quot;</span><br><span class="hljs-meta">.section</span>.note.GNU-stack,<span class="hljs-string">&quot;&quot;</span>,@progbits<br><br></code></pre></td></tr></table></figure><p>后者是默认的</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-class">.file</span><span class="hljs-string">&quot;a.cpp&quot;</span><br><span class="hljs-selector-class">.option</span> pic<br><span class="hljs-selector-class">.text</span><br><span class="hljs-selector-class">.data</span><br><span class="hljs-selector-class">.align</span><span class="hljs-number">2</span><br><span class="hljs-selector-class">.type</span>_ZL1a, @<span class="hljs-selector-tag">object</span><br><span class="hljs-selector-class">.size</span>_ZL1a, <span class="hljs-number">4</span><br>_ZL1a:<br><span class="hljs-selector-class">.word</span><span class="hljs-number">1</span><br><span class="hljs-selector-class">.section</span><span class="hljs-selector-class">.rodata</span><br><span class="hljs-selector-class">.align</span><span class="hljs-number">3</span><br><span class="hljs-selector-class">.LC0</span>:<br><span class="hljs-selector-class">.string</span><span class="hljs-string">&quot;%p\n&quot;</span><br><span class="hljs-selector-class">.text</span><br><span class="hljs-selector-class">.align</span><span class="hljs-number">1</span><br><span class="hljs-selector-class">.globl</span><span class="hljs-selector-tag">main</span><br><span class="hljs-selector-class">.type</span><span class="hljs-selector-tag">main</span>, @function<br><span class="hljs-selector-tag">main</span>:<br><span class="hljs-selector-class">.LFB0</span>:<br><span class="hljs-selector-class">.cfi_startproc</span><br>addisp,sp,-<span class="hljs-number">16</span><br><span class="hljs-selector-class">.cfi_def_cfa_offset</span> <span class="hljs-number">16</span><br>sdra,<span class="hljs-number">8</span>(sp)<br>sds0,<span class="hljs-number">0</span>(sp)<br><span class="hljs-selector-class">.cfi_offset</span> <span class="hljs-number">1</span>, -<span class="hljs-number">8</span><br><span class="hljs-selector-class">.cfi_offset</span> <span class="hljs-number">8</span>, -<span class="hljs-number">16</span><br>addis0,sp,<span class="hljs-number">16</span><br><span class="hljs-selector-class">.cfi_def_cfa</span> <span class="hljs-number">8</span>, <span class="hljs-number">0</span><br>llaa1,_ZL1a<br>llaa0,<span class="hljs-selector-class">.LC0</span><br>callprintf@plt<br><span class="hljs-selector-tag">li</span>a5,<span class="hljs-number">0</span><br>mva0,a5<br>ldra,<span class="hljs-number">8</span>(sp)<br><span class="hljs-selector-class">.cfi_restore</span> <span class="hljs-number">1</span><br>lds0,<span class="hljs-number">0</span>(sp)<br><span class="hljs-selector-class">.cfi_restore</span> <span class="hljs-number">8</span><br><span class="hljs-selector-class">.cfi_def_cfa</span> <span class="hljs-number">2</span>, <span class="hljs-number">16</span><br>addisp,sp,<span class="hljs-number">16</span><br><span class="hljs-selector-class">.cfi_def_cfa_offset</span> <span class="hljs-number">0</span><br>jrra<br><span class="hljs-selector-class">.cfi_endproc</span><br><span class="hljs-selector-class">.LFE0</span>:<br><span class="hljs-selector-class">.size</span><span class="hljs-selector-tag">main</span>, .-<span class="hljs-selector-tag">main</span><br><span class="hljs-selector-class">.ident</span><span class="hljs-string">&quot;GCC: (Ubuntu 10.3.0-8ubuntu1) 10.3.0&quot;</span><br><span class="hljs-selector-class">.section</span><span class="hljs-selector-class">.note</span><span class="hljs-selector-class">.GNU-stack</span>,<span class="hljs-string">&quot;&quot;</span>,@progbits<br></code></pre></td></tr></table></figure><p>主要区别在<code>main</code>函数中:</p><p>前者向<code>printf</code>传参的语句如下</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">lui</span><span class="hljs-built_in">a5</span>,%hi(_ZL1a)<br><span class="hljs-keyword">addi</span><span class="hljs-built_in">a1</span>,<span class="hljs-built_in">a5</span>,%lo(_ZL1a)<br><span class="hljs-keyword">lui</span><span class="hljs-built_in">a5</span>,%hi(.LC0)<br><span class="hljs-keyword">addi</span><span class="hljs-built_in">a0</span>,<span class="hljs-built_in">a5</span>,%lo(.LC0)<br>callprintf<br></code></pre></td></tr></table></figure><p>后者向<code>printf</code>传参的语句如下</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">lla</span><span class="hljs-built_in">a1</span>,_ZL1a<br><span class="hljs-keyword">lla</span><span class="hljs-built_in">a0</span>,.LC0<br>callprintf@plt<br></code></pre></td></tr></table></figure><p><code>lla a1, _ZL1a</code>等同于相当于以下指令</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">auipc a<span class="hljs-number">5</span>,<span class="hljs-meta">%</span>hi<span class="hljs-comment">(_ZL1a)</span><br>addi a<span class="hljs-number">1</span>,a<span class="hljs-number">5</span>,<span class="hljs-meta">%</span>lo<span class="hljs-comment">(_ZL1a)</span><br></code></pre></td></tr></table></figure><p>所以后者可以翻译为</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">auipc a5,%<span class="hljs-built_in">hi</span>(_ZL1a)<br>addi a1,a5,%<span class="hljs-built_in">lo</span>(_ZL1a)<br>auipc a5,%<span class="hljs-built_in">hi</span>(.LC0)<br>addi a0,a5,%<span class="hljs-built_in">lo</span>(.LC0)<br>callprintf<span class="hljs-keyword">@plt</span><br></code></pre></td></tr></table></figure><p><code>lui rd,imm</code>的作用是把立即数<code>imm</code>左移<code>12</code>位,放到寄存器<code>rd</code>的高<code>20</code>位上.</p><p><code>auipc rd,imm</code>的作用是把立即数<code>imm</code>左移<code>12</code>位+寄存器<code>pc</code>的结果,放到寄存器<code>rd</code>的高<code>20</code>位上.</p><p><code>addi rd1,rd2,imm</code>的作用是把寄存器<code>rd2</code>+立即数<code>imm</code>的结果存到寄存器<code>rd1</code>.</p><p>有人会问,这里为什么需要用两条指令来做这个移动.</p><p>首先riscv的指令长度都是32位,这个32位中,需要用5位来表示rd寄存器,7位表示操作类型.</p><p>那么就只剩下20位了,所以一条指令只能给寄存器传20位的立即数.</p><p>所以这里采用了先传20位到寄存器的高位,再用加法把低12位加进去的方法.</p><p>指令如下:</p><table><thead><tr><th></th><th>立即数</th><th>寄存器</th><th>操作符号</th></tr></thead><tbody><tr><td>auipc</td><td>20位立即数</td><td>5位寄存器地址</td><td><code>0010111</code></td></tr><tr><td>lui</td><td>20位立即数</td><td>5位寄存器地址</td><td><code>0110111</code></td></tr></tbody></table><p>这里就可以发现,前者每次给<code>printf</code>传入的参数都是固定的数值,后者传入的参数是<code>pc+固定数值</code>.</p><p>这个固定数值就是<code>pc</code>相对于目标的偏移.</p><p>因为每次text段被加载到不同的地址,所以每次执行,寄存器<code>pc</code>的值都不同,输出就不同了.</p>]]></content>
    
    
    <categories>
      
      <category>C语言与riscv汇编阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>riscv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>细说std源码</title>
    <link href="/ad8a0b77/"/>
    <url>/ad8a0b77/</url>
    
    <content type="html"><![CDATA[<ul><li>《细说std源码》前言和目录;</li></ul><span id="more"></span><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>为了搞懂std究竟做了什么,我常会阅读源码.</p><p>既然我想要知道,那么就会有其他人也想要知道.</p><p>所以我尽量写出类似读后感的玩意,或许有人会来看.</p><p>这里用的代码是<code>g++ 11.2</code>版本的,或许以后<code>g++</code>更新了我就会看更新版本的代码.</p><h2 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h2><ol><li><a href="/ef6ea057/" title="C++模板元编程初步">C++模板元编程初步</a></li><li><a href="/87a42267/" title="c++标准draft翻译">c++标准draft翻译</a> (未完成)</li><li><a href="/3b391a6f/" title="C++的各种宏和属性">C++的各种宏和属性</a> (未完成)</li><li><a href="/51d9423d/" title="C++atomic源码分析">C++atomic源码分析</a> (未完成)</li><li><a href="/6ed806ff/" title="C++chrono源码分析">C++chrono源码分析</a> (未完成)</li><li><a href="/770726c0/" title="C++thread源码分析">C++thread源码分析</a> (老版本)</li><li><a href="/ae6bf35b/" title="C++ type traits 源码分析">C++ type traits 源码分析</a> (未完成)</li></ol>]]></content>
    
    
    <categories>
      
      <category>细说CPP标准和stl源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++标准draft翻译</title>
    <link href="/87a42267/"/>
    <url>/87a42267/</url>
    
    <content type="html"><![CDATA[<ul><li>将来会翻译完的(心虚);</li></ul><span id="more"></span><h1 id="0-前言todo"><a class="markdownIt-Anchor" href="#0-前言todo"></a> 0. 前言[todo]</h1><p>有时候，我们会遇到一些语法不能确定的地方。</p><p>这时候我回去翻一下标准。</p><p>所以我把我阅读过的部分翻译一下。</p><p>随着我越看越多，这里也会越来越多。</p><p>目前，文中所见的大部分页内跳转链接都是跳转到文章开头。</p><h1 id="1-范围introscope"><a class="markdownIt-Anchor" href="#1-范围introscope"></a> 1. 范围[intro.scope]</h1><ol><li><p>这个文档指定了<code>C++</code>编程语言的实现要求。本文不仅对<code>C++</code>的实现做出了要求，而且也定义了什么是<code>C++</code>。这些内容可以在本文的各个位置找到。</p></li><li><p><code>C++</code>是一个基于<code>ISO/IEC 9899:2018</code>所描述的C语言的，通用的编程语言。<code>C++</code>提供的工具超越了C语言所提供的，包括额外的数据类型、类、模板、异常、命名空间、操作符重载、函数重载、引用、存储释放操作符、和额外的库。</p></li></ol><h1 id="2-参考标准introrefs"><a class="markdownIt-Anchor" href="#2-参考标准introrefs"></a> 2. 参考标准[intro.refs]</h1><ol><li><p>本文以某些方式借用了下面的文档中的一些或所有内容。下面列出的文档中：如果标明了日期，那么说明我们只引用了该版本；否则，我们引用的是最新版本。</p><ol><li>ISO/IEC 2382, Information technology — Vocabulary</li><li>ISO 8601:2004, Data elements and interchange formats — Information interchange — Representation of dates and times</li><li>ISO/IEC 9899:2018, Programming languages — C</li><li>ISO/IEC/IEEE 9945:2009, Information Technology — Portable Operating System Interface (POSIX)</li><li>ISO/IEC/IEEE 9945:2009/Cor 1:2013, Information Technology — Portable Operating System Interface (POSIX), Technical Corrigendum 1</li><li>ISO/IEC/IEEE 9945:2009/Cor 2:2017, Information Technology — Portable Operating System Interface (POSIX), Technical Corrigendum 2</li><li>ISO/IEC 10646, Information technology — Universal Coded Character Set (UCS)</li><li>ISO/IEC 10646:2003, Information technology — Universal Multiple-Octet Coded Character Set (UCS)</li><li>ISO/IEC/IEEE 60559:2020, Information technology — Microprocessor Systems — Floating-Point arithmetic</li><li>ISO 80000-2:2009, Quantities and units — Part 2: Mathematical signs and symbols to be used in the natural sciences and technology</li><li>Ecma International, ECMAScript3 Language Specification, Standard Ecma-262, third edition, 1999.</li><li>The Unicode Consortium.<br />Unicode Standard Annex, UAX #44, Unicode Character Database.<br />Edited by Ken Whistler and Laurenţiu Iancu.<br />Available from: [<a href="http://www.unicode.org/reports/tr44/">http://www.unicode.org/reports/tr44/</a>]</li><li>The Unicode Consortium.<br />The Unicode Standard, Derived Core Properties.<br />Available from: [<a href="https://www.unicode.org/Public/UCD/latest/ucd/DerivedCoreProperties.txt">https://www.unicode.org/Public/UCD/latest/ucd/DerivedCoreProperties.txt</a>]</li></ol></li><li><p><code>ISO/IEC 9899:2018, Clause 7</code>所描述的库，在下文被称为<code>C标准库</code>。</p></li><li><p><code>ISO/IEC 9945:2009</code>所描述的操作系统接口，在下文被称为<code>POSIX</code>。</p></li><li><p><code>Ecma-262</code>所描述的ECMAScript编程语言，在下文被称为<code>ECMA-262</code>。</p></li><li><p>（记1：从<code>ISO/IEC 10646:2003</code>中引用的内容，只用来支撑一些已经过时特性(<a href="#0-%E5%89%8D%E8%A8%80todo">depr.locale.stdcvt</a>)）。</p></li></ol><h1 id="3-条款和定义introdefs"><a class="markdownIt-Anchor" href="#3-条款和定义introdefs"></a> 3. 条款和定义[intro.defs]</h1><ol><li><p>在<code>ISO/IEC 2382</code>中给出的条款和定义，在<code>ISO 80000-2:2009</code>中给出的条款、定义、和符号，在本文中依旧适用。</p></li><li><p>ISO和IEC在下面的地址中维护了我们所适用的标准文档。</p><ol><li>ISO Online browsing platform: available at [<a href="https://www.iso.org/obp">https://www.iso.org/obp</a>]</li><li>IEC Electropedia: [available at <a href="http://www.electropedia.or">http://www.electropedia.or</a>]</li></ol></li><li><p>那些只在本文的一小段中适用的定义，会用斜体来表示。</p></li></ol><h2 id="31-访问defnsaccess"><a class="markdownIt-Anchor" href="#31-访问defnsaccess"></a> 3.1. 访问[defns.access]</h2><p>（运行时的动作）读取或者修改了对象的值。</p><p>（记1：只有标量类型的广义左值可以用来访问对象。标量对象的读取在<a href="#0-%E5%89%8D%E8%A8%80todo">conv.lval</a>中有描述，标量对象的修改在<a href="#0-%E5%89%8D%E8%A8%80todo">expr.ass</a>、<a href="#0-%E5%89%8D%E8%A8%80todo">expr.post.incr</a>和<a href="#0-%E5%89%8D%E8%A8%80todo">expr.pre.incr</a>中有描述。尝试读取或者修改对象，将会导致调用类的构造函数或者赋值操作。尽管这些函数可能会执行一些标量子对象的访问操作，但是这个调用本身并不涉及访问。）</p><h2 id="32-任意位置流defnsarbitrarysteam"><a class="markdownIt-Anchor" href="#32-任意位置流defnsarbitrarysteam"></a> 3.2. 任意位置流[defns.arbitrary.steam]</h2><p>（库）只要在流的长度范围内，就可以定位到任意整数位置的流。</p><p>（记1：所有任意位置流都是可重定位流<a href="#0-%E5%89%8D%E8%A8%80todo">defns.prepolitical.stream</a>）</p><h2 id="33-参数defnsargument"><a class="markdownIt-Anchor" href="#33-参数defnsargument"></a> 3.3. 参数[defns.argument]</h2><p>（函数调用表达式）在括号中的，被逗号分隔的表达式。</p><h2 id="34-参数defnsargumentmacro"><a class="markdownIt-Anchor" href="#34-参数defnsargumentmacro"></a> 3.4. 参数[defns.argument.macro]</h2><p>（宏函数表达式）在括号中的，被逗号分隔的预处理器标记序列。</p><h2 id="35-参数defnsargumentthrow"><a class="markdownIt-Anchor" href="#35-参数defnsargumentthrow"></a> 3.5. 参数[defns.argument.throw]</h2><p>（抛出异常）<a href="#0-%E5%89%8D%E8%A8%80todo">抛出异常</a>的操作数。</p><h2 id="36-参数defnsargumenttempl"><a class="markdownIt-Anchor" href="#36-参数defnsargumenttempl"></a> 3.6. 参数[defns.argument.templ]</h2><p>（模板实例化）在尖括号中的，被逗号分隔的<a href="#0-%E5%89%8D%E8%A8%80todo">常量表达式</a>、<a href="#0-%E5%89%8D%E8%A8%80todo">类型标识符</a>或者<a href="#0-%E5%89%8D%E8%A8%80todo">表达式</a>。</p><h2 id="37-阻塞defnsblock"><a class="markdownIt-Anchor" href="#37-阻塞defnsblock"></a> 3.7. 阻塞[defns.block]</h2><p>（执行）需要等待一些条件被满足才能继续执行被阻塞的操作。</p><h2 id="38-代码块defnsblockstmt"><a class="markdownIt-Anchor" href="#38-代码块defnsblockstmt"></a> 3.8. 代码块[defns.block.stmt]</h2><p>（语句）一些复合语句。</p><h2 id="39-字符defnscharacter"><a class="markdownIt-Anchor" href="#39-字符defnscharacter"></a> 3.9. 字符[defns.character]</h2><p>（库）被按顺序对待时，可以表示文本的对象。</p><p>（记1：不仅仅是意味着<code>char</code>、<code>char_t</code>、<code>char16_t</code>、<code>char32_t</code>、<code>wchar_t</code>对象，而且包括任何在<a href="#0-%E5%89%8D%E8%A8%80todo">字符串</a>、<a href="#0-%E5%89%8D%E8%A8%80todo">本地化</a>、<a href="#0-%E5%89%8D%E8%A8%80todo">输入输出</a>或<a href="#0-%E5%89%8D%E8%A8%80todo">正则</a>中定义的类型）</p><h2 id="310-字符容器类型defnscharactercontainer"><a class="markdownIt-Anchor" href="#310-字符容器类型defnscharactercontainer"></a> 3.10. 字符容器类型[defns.character.container]</h2><p>（库）用来表示字符的类或者类型</p><p>（记1：字符串，输入输出流，正则表达式类模板）</p><h2 id="311-对照元素defnsregexcollatingelement"><a class="markdownIt-Anchor" href="#311-对照元素defnsregexcollatingelement"></a> 3.11. 对照元素[defns.regex.collating.element]</h2><h2 id="312-组件defnscomponent"><a class="markdownIt-Anchor" href="#312-组件defnscomponent"></a> 3.12. 组件[defns.component]</h2><h2 id="313-条件支持defnscondsupp"><a class="markdownIt-Anchor" href="#313-条件支持defnscondsupp"></a> 3.13. 条件支持[defns.cond.supp]</h2><h2 id="314-常数子表达式defnsconstsubexpr"><a class="markdownIt-Anchor" href="#314-常数子表达式defnsconstsubexpr"></a> 3.14. 常数子表达式[defns.const.subexpr]</h2><h2 id="315-死锁defnsdeadlock"><a class="markdownIt-Anchor" href="#315-死锁defnsdeadlock"></a> 3.15. 死锁[defns.deadlock]</h2><h2 id="316-默认行为defnsdefaultbehaviorimpl"><a class="markdownIt-Anchor" href="#316-默认行为defnsdefaultbehaviorimpl"></a> 3.16. 默认行为[defns.default.behavior.impl]</h2><h2 id="317-诊断信息defnsdiagnostic"><a class="markdownIt-Anchor" href="#317-诊断信息defnsdiagnostic"></a> 3.17. 诊断信息[defns.diagnostic]</h2><h2 id="318-defnsargument"><a class="markdownIt-Anchor" href="#318-defnsargument"></a> 3.18. [defns.argument]</h2><h2 id="319-defnsargumentmacro"><a class="markdownIt-Anchor" href="#319-defnsargumentmacro"></a> 3.19. [defns.argument.macro]</h2><h2 id="320-defnsargumentthrow"><a class="markdownIt-Anchor" href="#320-defnsargumentthrow"></a> 3.20. [defns.argument.throw]</h2><h2 id="321-defnsargumenttempl"><a class="markdownIt-Anchor" href="#321-defnsargumenttempl"></a> 3.21. [defns.argument.templ]</h2><h2 id="322-defnsblock"><a class="markdownIt-Anchor" href="#322-defnsblock"></a> 3.22. [defns.block]</h2><h2 id="323-defnsblockstmt"><a class="markdownIt-Anchor" href="#323-defnsblockstmt"></a> 3.23. [defns.block.stmt]</h2><h2 id="324-defnscharacter"><a class="markdownIt-Anchor" href="#324-defnscharacter"></a> 3.24. [defns.character]</h2><h2 id="325-访问defnsaccess"><a class="markdownIt-Anchor" href="#325-访问defnsaccess"></a> 3.25. 访问[defns.access]</h2><h2 id="326-defnsarbitrarysteam"><a class="markdownIt-Anchor" href="#326-defnsarbitrarysteam"></a> 3.26. [defns.arbitrary.steam]</h2><h2 id="327-defnsargument"><a class="markdownIt-Anchor" href="#327-defnsargument"></a> 3.27. [defns.argument]</h2><h2 id="328-访问defnsaccess"><a class="markdownIt-Anchor" href="#328-访问defnsaccess"></a> 3.28. 访问[defns.access]</h2><h2 id="329-defnsarbitrarysteam"><a class="markdownIt-Anchor" href="#329-defnsarbitrarysteam"></a> 3.29. [defns.arbitrary.steam]</h2><h2 id="330-defnsargument"><a class="markdownIt-Anchor" href="#330-defnsargument"></a> 3.30. [defns.argument]</h2><h2 id="331-访问defnsaccess"><a class="markdownIt-Anchor" href="#331-访问defnsaccess"></a> 3.31. 访问[defns.access]</h2><h2 id="332-defnsarbitrarysteam"><a class="markdownIt-Anchor" href="#332-defnsarbitrarysteam"></a> 3.32. [defns.arbitrary.steam]</h2><h2 id="333-defnsargument"><a class="markdownIt-Anchor" href="#333-defnsargument"></a> 3.33. [defns.argument]</h2><h2 id="334-defnsargumentmacro"><a class="markdownIt-Anchor" href="#334-defnsargumentmacro"></a> 3.34. [defns.argument.macro]</h2><h2 id="335-defnsargumentthrow"><a class="markdownIt-Anchor" href="#335-defnsargumentthrow"></a> 3.35. [defns.argument.throw]</h2><h2 id="336-defnsargumenttempl"><a class="markdownIt-Anchor" href="#336-defnsargumenttempl"></a> 3.36. [defns.argument.templ]</h2><h2 id="337-defnsblock"><a class="markdownIt-Anchor" href="#337-defnsblock"></a> 3.37. [defns.block]</h2><h2 id="338-defnsblockstmt"><a class="markdownIt-Anchor" href="#338-defnsblockstmt"></a> 3.38. [defns.block.stmt]</h2><h2 id="339-defnscharacter"><a class="markdownIt-Anchor" href="#339-defnscharacter"></a> 3.39. [defns.character]</h2><h2 id="340-访问defnsaccess"><a class="markdownIt-Anchor" href="#340-访问defnsaccess"></a> 3.40. 访问[defns.access]</h2><h2 id="341-defnsarbitrarysteam"><a class="markdownIt-Anchor" href="#341-defnsarbitrarysteam"></a> 3.41. [defns.arbitrary.steam]</h2><h2 id="342-defnsargument"><a class="markdownIt-Anchor" href="#342-defnsargument"></a> 3.42. [defns.argument]</h2><h2 id="343-访问defnsaccess"><a class="markdownIt-Anchor" href="#343-访问defnsaccess"></a> 3.43. 访问[defns.access]</h2><h2 id="344-defnsarbitrarysteam"><a class="markdownIt-Anchor" href="#344-defnsarbitrarysteam"></a> 3.44. [defns.arbitrary.steam]</h2><h2 id="345-defnsargument"><a class="markdownIt-Anchor" href="#345-defnsargument"></a> 3.45. [defns.argument]</h2><h2 id="346-访问defnsaccess"><a class="markdownIt-Anchor" href="#346-访问defnsaccess"></a> 3.46. 访问[defns.access]</h2><h2 id="347-defnsarbitrarysteam"><a class="markdownIt-Anchor" href="#347-defnsarbitrarysteam"></a> 3.47. [defns.arbitrary.steam]</h2><h2 id="348-defnsargument"><a class="markdownIt-Anchor" href="#348-defnsargument"></a> 3.48. [defns.argument]</h2><h2 id="349-defnsargumentthrow"><a class="markdownIt-Anchor" href="#349-defnsargumentthrow"></a> 3.49. [defns.argument.throw]</h2><h2 id="350-defnsargumenttempl"><a class="markdownIt-Anchor" href="#350-defnsargumenttempl"></a> 3.50. [defns.argument.templ]</h2><h2 id="351-defnsblock"><a class="markdownIt-Anchor" href="#351-defnsblock"></a> 3.51. [defns.block]</h2><h2 id="352-defnsblockstmt"><a class="markdownIt-Anchor" href="#352-defnsblockstmt"></a> 3.52. [defns.block.stmt]</h2><h2 id="353-defnscharacter"><a class="markdownIt-Anchor" href="#353-defnscharacter"></a> 3.53. [defns.character]</h2><h2 id="354-访问defnsaccess"><a class="markdownIt-Anchor" href="#354-访问defnsaccess"></a> 3.54. 访问[defns.access]</h2><h2 id="355-defnsarbitrarysteam"><a class="markdownIt-Anchor" href="#355-defnsarbitrarysteam"></a> 3.55. [defns.arbitrary.steam]</h2><h2 id="356-defnsargument"><a class="markdownIt-Anchor" href="#356-defnsargument"></a> 3.56. [defns.argument]</h2><h2 id="357-访问defnsaccess"><a class="markdownIt-Anchor" href="#357-访问defnsaccess"></a> 3.57. 访问[defns.access]</h2><h2 id="358-defnsarbitrarysteam"><a class="markdownIt-Anchor" href="#358-defnsarbitrarysteam"></a> 3.58. [defns.arbitrary.steam]</h2><h2 id="359-defnsargument"><a class="markdownIt-Anchor" href="#359-defnsargument"></a> 3.59. [defns.argument]</h2><h2 id="360-访问defnsaccess"><a class="markdownIt-Anchor" href="#360-访问defnsaccess"></a> 3.60. 访问[defns.access]</h2><h2 id="361-defnsarbitrarysteam"><a class="markdownIt-Anchor" href="#361-defnsarbitrarysteam"></a> 3.61. [defns.arbitrary.steam]</h2><h2 id="362-defnsargument"><a class="markdownIt-Anchor" href="#362-defnsargument"></a> 3.62. [defns.argument]</h2><h2 id="363-访问defnsaccess"><a class="markdownIt-Anchor" href="#363-访问defnsaccess"></a> 3.63. 访问[defns.access]</h2><h2 id="364-defnsarbitrarysteam"><a class="markdownIt-Anchor" href="#364-defnsarbitrarysteam"></a> 3.64. [defns.arbitrary.steam]</h2><h2 id="365-defnsargument"><a class="markdownIt-Anchor" href="#365-defnsargument"></a> 3.65. [defns.argument]</h2><h2 id="366-访问defnsaccess"><a class="markdownIt-Anchor" href="#366-访问defnsaccess"></a> 3.66. 访问[defns.access]</h2><h2 id="367-defnsarbitrarysteam"><a class="markdownIt-Anchor" href="#367-defnsarbitrarysteam"></a> 3.67. [defns.arbitrary.steam]</h2><h2 id="368-良构defnswellformed"><a class="markdownIt-Anchor" href="#368-良构defnswellformed"></a> 3.68. 良构[defns.well.formed]</h2><p>结构遵守了语法规则和语义规则的<code>C++</code>程序。</p><h1 id="6-基本basic"><a class="markdownIt-Anchor" href="#6-基本basic"></a> 6. 基本[basic]</h1><h2 id="66-程序和链接basiclink"><a class="markdownIt-Anchor" href="#66-程序和链接basiclink"></a> 6.6 程序和链接[basic.link]</h2><ol><li><p>一个程序由一个或多个翻译单元链接在一起组成,一个翻译单元由一系列的声明组成.</p></li><li><p>当一个名字能够表示一个定义在其他作用域的对象/引用/函数/类型/模板/命名空间/变量的时候,他就是一个有链接的名字.</p></li></ol><p>2.1. 当一个名字有外部链接的时候,可以在其他的翻译单元的同作用域,或者同翻译单元的不同作用域中,使用这个名字来引用他表示的实体.</p><p>2.2. 当一个名字有模块链接的时候,可以在其他的模块的同作用域,或者同模块的不同作用域中,使用这个名字来引用他表示的实体.</p><p>2.3. 当一个名字有内部链接的时候,可以在同一翻译单元的其他作用域中,使用这个名字来引用他表示的实体.</p><p>2.4. 当一个名字没有链接时,这个实体不能在其他作用域中,使用名字来引用.</p><ol start="3"><li>一个属于某个命名空间(全局变量属于全局命名空间)的实体的,如果符合以下任意条件,那么他的名字具有内部链接:</li></ol><p>3.1. 显式加上static修饰符的变量,变量模板,函数或函数模板,有内部链接.</p><p>3.2. 非volatile,非变量模板的const类型变量有内部链接,除非满足以下任意一点:</p><p>3.2.1. 显式声明了extern</p><p>3.2.2. 他是inline或exported</p><p>3.2.3. 他有前向声明而且他的前向声明没有内部链接</p><p>3.3. 匿名联合体的数据成员有内部链接.</p><h2 id="69-程序执行basicexec"><a class="markdownIt-Anchor" href="#69-程序执行basicexec"></a> 6.9 程序执行[basic.exec]</h2><h3 id="693-开始和终止basicstart"><a class="markdownIt-Anchor" href="#693-开始和终止basicstart"></a> 6.9.3 开始和终止[basic.start]</h3><h4 id="6933-动态初始化和非阻塞变量basicstartdynamic"><a class="markdownIt-Anchor" href="#6933-动态初始化和非阻塞变量basicstartdynamic"></a> 6.9.3.3 动态初始化和非阻塞变量[basic.start.dynamic]</h4><ol><li>在静态存储区的非阻塞变量的动态初始化顺序是未被指定的,通常顺序会更加偏向于内联变量.</li></ol><h1 id="7-表达式expr"><a class="markdownIt-Anchor" href="#7-表达式expr"></a> 7 表达式[expr]</h1><h2 id="76-复合表达式exprcompound"><a class="markdownIt-Anchor" href="#76-复合表达式exprcompound"></a> 7.6 复合表达式[expr.compound]</h2><h3 id="761-后缀表达式exprpost"><a class="markdownIt-Anchor" href="#761-后缀表达式exprpost"></a> 7.6.1 后缀表达式[expr.post]</h3><h4 id="7615-类成员访问exprref"><a class="markdownIt-Anchor" href="#7615-类成员访问exprref"></a> 7.6.1.5 类成员访问[expr.ref]</h4><h1 id="9-声明dcl"><a class="markdownIt-Anchor" href="#9-声明dcl"></a> 9 声明[dcl]</h1><h2 id="92-标识符dclspec"><a class="markdownIt-Anchor" href="#92-标识符dclspec"></a> 9.2 标识符[dcl.spec]</h2><h3 id="929-类型标识符dcltype"><a class="markdownIt-Anchor" href="#929-类型标识符dcltype"></a> 9.2.9 类型标识符[dcl.type]</h3><h4 id="9296-占位类型标识符dclspecauto"><a class="markdownIt-Anchor" href="#9296-占位类型标识符dclspecauto"></a> 9.2.9.6 占位类型标识符[dcl.spec.auto]</h4><h5 id="92961-通常dclspecautogeneral"><a class="markdownIt-Anchor" href="#92961-通常dclspecautogeneral"></a> 9.2.9.6.1 通常[dcl.spec.auto.general]</h5><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">placeholder</span>-<span class="hljs-keyword">type</span>-specifier:<br>  <span class="hljs-keyword">type</span>-constraint auto<br>  <span class="hljs-keyword">type</span>-constraint decltype ( auto )<br></code></pre></td></tr></table></figure><ol><li>占位类型标识符表示一个占位类型,这个占位类型在类型推导之后将会被替换成真正的类型.</li></ol><h2 id="93-声明符dcldcl"><a class="markdownIt-Anchor" href="#93-声明符dcldcl"></a> 9.3 声明符[dcl.dcl]</h2><h3 id="934-声明符的含义dclmeaning"><a class="markdownIt-Anchor" href="#934-声明符的含义dclmeaning"></a> 9.3.4 声明符的含义[dcl.meaning]</h3><h4 id="9341-通常dclmeaninggeneral"><a class="markdownIt-Anchor" href="#9341-通常dclmeaninggeneral"></a> 9.3.4.1 通常[dcl.meaning.general]</h4><h4 id="9346-函数dclfct"><a class="markdownIt-Anchor" href="#9346-函数dclfct"></a> 9.3.4.6 函数[dcl.fct]</h4><h1 id="11-类"><a class="markdownIt-Anchor" href="#11-类"></a> 11 类</h1><h2 id="114-类成员"><a class="markdownIt-Anchor" href="#114-类成员"></a> 11.4 类成员</h2><h3 id="1149-静态成员"><a class="markdownIt-Anchor" href="#1149-静态成员"></a> 11.4.9 静态成员</h3><h4 id="11491-通常"><a class="markdownIt-Anchor" href="#11491-通常"></a> 11.4.9.1 通常</h4><ol><li>可以使用<code>X::s</code>的方式来表示某个类<code>X</code>的某个静态成员<code>s</code>.不一定需要使用类成员访问[expr.ref]的方式来表示静态成员. 静态成员也可以使用类成员访问的方式来表示,在这种情况下计算对象表达式.</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">process</span> &#123;<br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">reschedule</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-function">process&amp; <span class="hljs-title">g</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br>  process::<span class="hljs-built_in">reschedule</span>();        <span class="hljs-comment">// OK, no object necessary</span><br>  <span class="hljs-built_in">g</span>().<span class="hljs-built_in">reschedule</span>();             <span class="hljs-comment">// g() is called</span><br></code></pre></td></tr></table></figure><ol start="2"><li>静态成员遵守对象成员访问规则[class.access].当在类成员的声明中使用的时候,<code>static</code>只能用于出现在类定义中的成员声明中.</li></ol><blockquote><p>不能用在出现在命名空间的成员声明中.</p></blockquote><h4 id="11492-静态成员函数classstaticmfct"><a class="markdownIt-Anchor" href="#11492-静态成员函数classstaticmfct"></a> 11.4.9.2 静态成员函数[class.static.mfct]</h4><ol><li><p>[class.mfct]描述的规则同样适用于静态成员函数.</p></li><li><p>静态成员函数没有<code>this</code>指针[expr.prim.this],静态成员函数不能用<code>const</code>, <code>volatile</code> 或 <code>virtual</code>修饰[dcl.fct]</p></li></ol><h4 id="11493-静态数据成员classstaticdata"><a class="markdownIt-Anchor" href="#11493-静态数据成员classstaticdata"></a> 11.4.9.3 静态数据成员[class.static.data]</h4><ol><li><p>静态数据成员不是类的对象的一部分.<code>thread_local</code>的静态数据成员会被每个线程拷贝一份.如果静态数据成员没有声明<code>thread_local</code>,那么类的所有成员共享着一个数据成员.</p></li><li><p>静态数据成员不该被<code>mutable</code>[dcl.stc].静态数据成员不能是匿名类[class.pre], 局部类[class.local]或内嵌类[class.nest]的直接成员[class.meml].</p></li><li><p>在类定义中的非内联静态数据成员并未被定义,他可能是除<code>cv void</code>以外的未完成类型</p></li></ol><blockquote><p>静态数据成员的初始化位于他所隶属的类的作用域内[basic.scope.class]</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">process</span> &#123;<br>  <span class="hljs-type">static</span> process* run_chain;<br>  <span class="hljs-type">static</span> process* running;<br>&#125;;<br><br>process* process::running = <span class="hljs-built_in">get_main</span>();<br>process* process::run_chain = running;<br></code></pre></td></tr></table></figure><p>静态数据成员<code>run_chain</code>的定义位于全局作用域;符号<code>process::run_chain</code>表示<code>run_chain</code>是类<code>process</code>的成员,并且在类<code>process</code>的作用域内.</p><blockquote><p>一旦静态数据成员被定义,他就会存在,哪怕这个类实例化没有任何对象.</p></blockquote><p>在这个例子,即使类<code>process</code>没产生任何对象,<code>running</code>和<code>run_chain</code>依旧存在.</p><p>[basic.start.static], [basic.start.dynameic]和[basic.start.term]描述了静态数据成员的初始化和销毁.</p><ol start="4"><li><p>如果一个非内联.非<code>volatile</code>的常量静态数据成员是一个整数或枚举类型,在类定义中声明语句中,它可以直接使用一个常量通过赋值表达式来初始化.</p></li><li><p>在一个合法的程序中一个静态数据成员只能被定义一次.[basic.def.odr]</p></li><li><p>命名空间访问中的类的静态数据成员具有类名称的链接.[basic.link]</p></li></ol><h1 id="12-重载over"><a class="markdownIt-Anchor" href="#12-重载over"></a> 12 重载[over]</h1><h2 id="122-重载分析overmatch"><a class="markdownIt-Anchor" href="#122-重载分析overmatch"></a> 12.2 重载分析[over.match]</h2><h3 id="1224-最可行的函数overmatchbest"><a class="markdownIt-Anchor" href="#1224-最可行的函数overmatchbest"></a> 12.2.4 最可行的函数[over.match.best]</h3><h4 id="12241-通常overmatchbestgeneral"><a class="markdownIt-Anchor" href="#12241-通常overmatchbestgeneral"></a> 12.2.4.1 通常[over.match.best.general]</h4><h4 id="12242-隐式转换序列overbestics"><a class="markdownIt-Anchor" href="#12242-隐式转换序列overbestics"></a> 12.2.4.2 隐式转换序列[over.best.ics]</h4><h5 id="122421-通常overbesticsgeneral"><a class="markdownIt-Anchor" href="#122421-通常overbesticsgeneral"></a> 12.2.4.2.1 通常[over.best.ics.general]</h5><ol><li>隐式转换序列,是一用于将函数调用时传入的参数类型转换为被调用的函数所需要的参数类型的.</li></ol>]]></content>
    
    
    <categories>
      
      <category>细说CPP标准和stl源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>语言律师</tag>
      
      <tag>工地英语</tag>
      
      <tag>有生之年</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ type traits 源码分析</title>
    <link href="/ae6bf35b/"/>
    <url>/ae6bf35b/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="宏"><a class="markdownIt-Anchor" href="#宏"></a> 宏</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _GLIBCXX_TYPE_TRAITS</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GLIBCXX_TYPE_TRAITS 1</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> GCC system_header</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> __cplusplus &lt; 201103L</span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/c++0x_warning.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/c++config.h&gt;</span></span><br></code></pre></td></tr></table></figure><p>首先定义一个宏<code>_GLIBCXX_TYPE_TRAITS</code>,以便在重复包含的时候不会出问题.</p><p><code>#pragma GCC system_header</code>表示编译器将会像对待系统库那样对待这个文件(也就是这个文件可能不符合标准,但是不要警告).</p><p>如果当前版本小于c++11(也就是<code>__cplusplus &lt; 201103L</code>),那么<code>type_traits</code>只会包含一个<code>bits/c++0x_warning.h</code>,这个头文件里有一些警告信息.</p><p><code>bits/c++config.h</code>中定义了一些宏,日后细说.</p><h2 id="命名空间"><a class="markdownIt-Anchor" href="#命名空间"></a> 命名空间</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> std _GLIBCXX_VISIBILITY(<span class="hljs-keyword">default</span>)<br>&#123;<br>_GLIBCXX_BEGIN_NAMESPACE_VERSION<br></code></pre></td></tr></table></figure><p>这里出现的两个宏的定义位于上面所说的<code>bits/c++config.h</code>中.</p><p><code>_GLIBCXX_VISIBILITY</code>用于改变命名空间可见性.</p><p>如果<code>_GLIBCXX_INLINE_VERSION</code>的值不为<code>0</code>,<code>_GLIBCXX_BEGIN_NAMESPACE_VERSION</code>会在这个位置再定义一个命名空间,用来包住后面的定义.</p><p><code>_GLIBCXX_INLINE_VERSION</code>默认是<code>0</code>的,这时候<code>_GLIBCXX_BEGIN_NAMESPACE_VERSION</code>宏是空的.</p><h2 id="前向声明"><a class="markdownIt-Anchor" href="#前向声明"></a> 前向声明</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... _Elements&gt;<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">tuple</span>;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">reference_wrapper</span>;<br></code></pre></td></tr></table></figure><p>这里前向声明了两个定义在其他头文件里的类,从而不用包含这两个类所在的头文件.</p><p>这两个类所在的头文件也包含了<code>type_traits</code>,因此<code>type_traits</code>不能再去包含他们.</p><h2 id="integral_constant"><a class="markdownIt-Anchor" href="#integral_constant"></a> integral_constant</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp, _Tp __v&gt;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">integral_constant</span><br>    &#123;<br>      <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> _Tp                  value = __v;<br>      <span class="hljs-keyword">typedef</span> _Tp                           value_type;<br>      <span class="hljs-keyword">typedef</span> integral_constant&lt;_Tp, __v&gt;   type;<br>      <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">value_type</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> value; &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> __cplusplus &gt; 201103L</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __cpp_lib_integral_constant_callable 201304</span><br><br>      <span class="hljs-function"><span class="hljs-keyword">constexpr</span> value_type <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> value; &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;;<br></code></pre></td></tr></table></figure><h3 id="数据成员"><a class="markdownIt-Anchor" href="#数据成员"></a> 数据成员</h3><p>这个结构体定义了变量<code>value = __v</code>,这是一个<code>constexpr static</code>修饰的数据成员变量.</p><p>在C++17之后,这样<code>constexpr</code>修饰的静态成员变量可以在类定义语句内初始化.</p><p>在C++标准文档中有这样一句话</p><blockquote><p>A function or static data member declared with the constexpr or consteval specifier is implicitly an inline function or variable<br />被constexpr或consteval修饰的函数或则静态数据成员视为隐式地被inline修饰.</p></blockquote><p>也就是这么做效果等同<code>inline</code>.</p><p>C++17之后可以给静态数据成员加上<code>inline</code>,使得他可以直接在类定义语句内初始化.</p><p>接下来是将<code>_Tp</code>定义为<code>value_type</code>,将自身类型定义为<code>type</code>.</p><h3 id="函数成员"><a class="markdownIt-Anchor" href="#函数成员"></a> 函数成员</h3><h4 id="operator-value_type"><a class="markdownIt-Anchor" href="#operator-value_type"></a> operator value_type()</h4><p>如果将类型<code>integral_constant&lt;_Tp, __v&gt;</code>的对象转换为<code>_Tp</code>类型,那么将会调用<code>operator value_type()</code>函数,返回一个<code>_Tp</code>类型的<code>value</code>.</p><p>如果有类似这样的语句</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">integral_constant</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-number">1</span>&gt;())<br></code></pre></td></tr></table></figure><p>因为这时候<code>value_type</code>为<code>int</code>,那么这个类将会有一个函数成员<code>operator int()</code>.</p><p>例如上面的语句会返回<code>int</code>类型的<code>1</code>.</p><h4 id="operator"><a class="markdownIt-Anchor" href="#operator"></a> operator()()</h4><p>如果有一个<code>integral_constant&lt;_Tp, __v&gt;</code>类型的对象<code>a</code>,当我们使用<code>a()</code>时,将会调用<code>operator()()</code>.</p><p>这里的<code>operator()()</code>直接返回了<code>value</code>.</p><p>例如,下面的语句,将会返回一个<code>int</code>类型的<code>1</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">integral_constant</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-number">1</span>&gt;()()<br></code></pre></td></tr></table></figure><h3 id="静态成员定义"><a class="markdownIt-Anchor" href="#静态成员定义"></a> 静态成员定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp, _Tp __v&gt;<br>  <span class="hljs-keyword">constexpr</span> _Tp integral_constant&lt;_Tp, __v&gt;::value;<br></code></pre></td></tr></table></figure><p>如果C++版本小于17,那么还是需要在类定义语句之外使用这个语句来定义<code>value</code>.</p><p>在C++标准中有这样一段话</p><blockquote><p>在类定义中的非内联静态数据成员并未被定义,他可能是除<code>cv void</code>以外的未完成类型</p></blockquote><p>因此我们需要在类的外面定义他.</p><h3 id="常用类型定义"><a class="markdownIt-Anchor" href="#常用类型定义"></a> 常用类型定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <span class="hljs-comment">/// The type used as a compile-time boolean with true value.</span><br>  <span class="hljs-keyword">using</span> true_type =  integral_constant&lt;<span class="hljs-type">bool</span>, <span class="hljs-literal">true</span>&gt;;<br><br>  <span class="hljs-comment">/// The type used as a compile-time boolean with false value.</span><br>  <span class="hljs-keyword">using</span> false_type = integral_constant&lt;<span class="hljs-type">bool</span>, <span class="hljs-literal">false</span>&gt;;<br><br>  <span class="hljs-comment">/// @cond undocumented</span><br>  <span class="hljs-comment">/// bool_constant for C++11</span><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-type">bool</span> __v&gt;<br>    <span class="hljs-keyword">using</span> __bool_constant = integral_constant&lt;<span class="hljs-type">bool</span>, __v&gt;;<br>  <span class="hljs-comment">/// @endcond</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> __cplusplus &gt;= 201703L</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> __cpp_lib_bool_constant 201505</span><br>  <span class="hljs-comment">/// Alias template for compile-time boolean constant types.</span><br>  <span class="hljs-comment">/// @since C++17</span><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-type">bool</span> __v&gt;<br>    <span class="hljs-keyword">using</span> bool_constant = integral_constant&lt;<span class="hljs-type">bool</span>, __v&gt;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>这里使用<code>using</code>重命名了几个特定类型的<code>integral_constant</code>.</p><p>其中<code>false_type</code>和<code>true_type</code>非常常用,他们是模板元编程的基石之一.</p><h2 id="conditional"><a class="markdownIt-Anchor" href="#conditional"></a> conditional</h2><p>这里是一个前向定义.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">bool</span>, <span class="hljs-keyword">typename</span>, <span class="hljs-keyword">typename</span>&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">conditional</span>;<br></code></pre></td></tr></table></figure><p>他的实现也在同一个文件中.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">bool</span> _Cond, <span class="hljs-keyword">typename</span> _Iftrue, <span class="hljs-keyword">typename</span> _Iffalse&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">conditional</span><br>  &#123; <span class="hljs-keyword">typedef</span> _Iftrue type; &#125;;<br><br><span class="hljs-comment">// Partial specialization for false.</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Iftrue, <span class="hljs-keyword">typename</span> _Iffalse&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">conditional</span>&lt;<span class="hljs-literal">false</span>, _Iftrue, _Iffalse&gt;<br>  &#123; <span class="hljs-keyword">typedef</span> _Iffalse type; &#125;;<br></code></pre></td></tr></table></figure><p>以上代码根据<code>bool _Cond</code>的值,来决定<code>conditional::type</code>.</p><p>首先定义一个默认模板类,无论如何都把<code>type</code>定义为<code>_Iftrue</code>.</p><p>然后特化这个模板,当<code>_Cond</code>传入<code>false</code>的时候,把<code>type</code>定义为<code>_Iffalse</code>.</p><p>上述的<code>conditonal</code>的第一个模板参数<code>_Cond</code>其实很有说法.</p><p>如果我们直接传布尔值,或者传一个很简单的表达式,那就浪费了这个精巧的结构.</p><p>为此,C++定义了<code>__or_</code>, <code>__and_</code>,<code>__not_</code>结构体,来实现复杂的判断.</p><h2 id="__type_identity"><a class="markdownIt-Anchor" href="#__type_identity"></a> __type_identity</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> _Type&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__type_identity</span><br>  &#123; <span class="hljs-keyword">using</span> type = _Type; &#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>  <span class="hljs-keyword">using</span> <span class="hljs-type">__type_identity_t</span> = <span class="hljs-keyword">typename</span> __type_identity&lt;_Tp&gt;::type;<br></code></pre></td></tr></table></figure><p>这里定义了一个结构体<code>__type_identity</code>,这个结构体内部只是把模板参数中的<code>_Type</code>命名为<code>type</code>.</p><p>然后就是定义一个<code>__type_identity_t</code>,以便使用这个<code>type</code>.</p><h2 id="逻辑运算"><a class="markdownIt-Anchor" href="#逻辑运算"></a> 逻辑运算</h2><p>这几个逻辑运算也是模板元编程中非常关键的一点,他们给模板带来了逻辑.</p><h3 id="__or_"><a class="markdownIt-Anchor" href="#__or_"></a> __or_</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>...&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__or_</span>;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__or_</span>&lt;&gt;<br>  : <span class="hljs-keyword">public</span> false_type<br>  &#123; &#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _B1&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__or_</span>&lt;_B1&gt;<br>  : <span class="hljs-keyword">public</span> _B1<br>  &#123; &#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _B1, <span class="hljs-keyword">typename</span> _B2&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__or_</span>&lt;_B1, _B2&gt;<br>  : <span class="hljs-keyword">public</span> conditional&lt;_B1::value, _B1, _B2&gt;::type<br>  &#123; &#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _B1, <span class="hljs-keyword">typename</span> _B2, <span class="hljs-keyword">typename</span> _B3, <span class="hljs-keyword">typename</span>... _Bn&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__or_</span>&lt;_B1, _B2, _B3, _Bn...&gt;<br>  : <span class="hljs-keyword">public</span> conditional&lt;_B1::value, _B1, __or_&lt;_B2, _B3, _Bn...&gt;&gt;::type<br>  &#123; &#125;;<br></code></pre></td></tr></table></figure><h4 id="__or_-2"><a class="markdownIt-Anchor" href="#__or_-2"></a> __or_&lt;&gt;</h4><p>当我们不给<code>__or_</code>传模板参数时,他就会直接继承一个<code>false_type</code>.</p><p>这时候这个<code>__or_</code>的<code>value</code>成员就是<code>false</code>.</p><p>也就是说以下代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::__or_&lt;&gt; empty_or;<br>std::cout &lt;&lt; empty_or.value &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><p>会输出<code>0</code>.</p><h4 id="__or__b1"><a class="markdownIt-Anchor" href="#__or__b1"></a> __or_&lt;_B1&gt;</h4><p>当<code>__or_</code>接受一个模板参数的时候,他直接继承这个这个模板参数.</p><p>也就是如果这个参数继承了<code>true_type</code>,也就是<code>_B1::value</code>为<code>true</code>,那么<code>__or_</code>就会继承<code>_B1</code>,这时候<code>value</code>成员就会是<code>true</code>.</p><p>同理,如果这个参数继承了<code>false_type</code>,那么<code>__or_</code>就继承<code>_B1</code>之后,<code>value</code>成员就会是<code>false</code>.</p><p>这非常符合<code>or</code>的特征,当只接收一个布尔值时,计算结果就是这个布尔值.</p><h4 id="__or__b1-_b2"><a class="markdownIt-Anchor" href="#__or__b1-_b2"></a> __or_&lt;_B1, _B2&gt;</h4><p>如果<code>_B1::value</code>为<code>true</code>,那么<code>conditional&lt;_B1::value, _B1, _B2&gt;::type</code>将会返回<code>_B1</code>.</p><p>那么<code>__or_</code>直接继承<code>_B1</code>,短路掉<code>_B2</code>.</p><p>这时候<code>value</code>就是<code>true.</code></p><p>否则就继承<code>_B2</code>.</p><p>继承<code>_B2</code>之后,<code>__or_</code>的<code>value</code>取决于<code>_B2::value</code>.</p><p>这和<code>or</code>运算的表现一模一样.</p><p>这就相当于<code>_B1 || (_B2)</code>.</p><h4 id="__or__b1-_b2-_b3-_bn"><a class="markdownIt-Anchor" href="#__or__b1-_b2-_b3-_bn"></a> __or_&lt;_B1, _B2, _B3, _Bn…&gt;</h4><p>这里将传入的模板参数全部展开,就像这样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">conditional&lt;_B1::value, _B1, __or_&lt;_B2, _B3, _B4&gt;&gt;::type<br><span class="hljs-comment">//展开一次</span><br>conditional&lt;_B1::value, _B1, conditional&lt;_B2::value, _B2, __or_&lt;_B3, _B4&gt;&gt;&gt;::type<br><span class="hljs-comment">//再展开一次</span><br>conditional&lt;_B1::value, _B1, conditional&lt;_B2::value, _B2, conditional&lt;_B3::type, _B3, _B4&gt;&gt;&gt;::type<br></code></pre></td></tr></table></figure><p>这就像是<code>_B1 || (_B2 || (_B3 || _B4))</code>.</p><p>一旦有一个符合,<code>value</code>就会是<code>true</code>.</p><h3 id="__and_"><a class="markdownIt-Anchor" href="#__and_"></a> __and_</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>...&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__and_</span>;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__and_</span>&lt;&gt;<br>  : <span class="hljs-keyword">public</span> true_type<br>  &#123; &#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _B1&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__and_</span>&lt;_B1&gt;<br>  : <span class="hljs-keyword">public</span> _B1<br>  &#123; &#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _B1, <span class="hljs-keyword">typename</span> _B2&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__and_</span>&lt;_B1, _B2&gt;<br>  : <span class="hljs-keyword">public</span> conditional&lt;_B1::value, _B2, _B1&gt;::type<br>  &#123; &#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _B1, <span class="hljs-keyword">typename</span> _B2, <span class="hljs-keyword">typename</span> _B3, <span class="hljs-keyword">typename</span>... _Bn&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__and_</span>&lt;_B1, _B2, _B3, _Bn...&gt;<br>  : <span class="hljs-keyword">public</span> conditional&lt;_B1::value, __and_&lt;_B2, _B3, _Bn...&gt;, _B1&gt;::type<br>  &#123; &#125;;<br></code></pre></td></tr></table></figure><p>不传入模板参数的时候,直接继承<code>true_type</code>.</p><p>传入一个模板参数的时候,也是直接继承<code>_B1</code>.</p><p>传入两个模板参数的时候,如果<code>_B1</code>为<code>false</code>,那么直接继承<code>_B1</code>; 否则继承<code>_B2</code>,这时候<code>__and_</code>的值取决于<code>_B2</code>.</p><p>后面的展开也和上面同理,相当于展开成<code>_B1 &amp;&amp; (_B2 &amp;&amp; (_B3 &amp;&amp; ...))</code>.</p><h3 id="__not_"><a class="markdownIt-Anchor" href="#__not_"></a> __not_</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Pp&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__not_</span><br>  : <span class="hljs-keyword">public</span> __bool_constant&lt;!<span class="hljs-built_in">bool</span>(_Pp::value)&gt;<br>  &#123; &#125;;<br></code></pre></td></tr></table></figure><p>这里就简单很多直接对传入模板参数的<code>value</code>取反,然后继承一个<code>__bool_constant</code>.</p><h3 id="快捷方式"><a class="markdownIt-Anchor" href="#快捷方式"></a> 快捷方式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">if</span> __cplusplus &gt;= 201703L</span><br><br>  <span class="hljs-comment">/// @cond undocumented</span><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... _Bn&gt;<br>    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> __or_v = __or_&lt;_Bn...&gt;::value;<br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... _Bn&gt;<br>    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> __and_v = __and_&lt;_Bn...&gt;::value;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __cpp_lib_logical_traits 201510</span><br><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... _Bn&gt;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">conjunction</span><br>    : __and_&lt;_Bn...&gt;<br>    &#123; &#125;;<br><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... _Bn&gt;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">disjunction</span><br>    : __or_&lt;_Bn...&gt;<br>    &#123; &#125;;<br><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Pp&gt;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">negation</span><br>    : __not_&lt;_Pp&gt;<br>    &#123; &#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... _Bn&gt;<br>    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> conjunction_v = conjunction&lt;_Bn...&gt;::value;<br><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... _Bn&gt;<br>    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> disjunction_v = disjunction&lt;_Bn...&gt;::value;<br><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Pp&gt;<br>    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> negation_v = negation&lt;_Pp&gt;::value;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>这里定义了<code>inline constexpr</code>的变量<code>__or_v</code>和<code>__and_v</code>,可以方便地访问<code>value</code>.</p><p>目前<code>constexpr</code>模板变量直接写在头文件里没有关系,因为他没有外部链接,但是以后可能会有问题.</p><p>加上<code>inline</code>的变量可以定义在头文件里,然后被其他文件包含也不会出问题.</p><h2 id="类型判断"><a class="markdownIt-Anchor" href="#类型判断"></a> 类型判断</h2><p>类型判断的模板类我打乱顺序来讲,但是这样更加易于理解.</p><h3 id="is_reference"><a class="markdownIt-Anchor" href="#is_reference"></a> is_reference</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>&gt;<br>   <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_lvalue_reference</span><br>   : <span class="hljs-keyword">public</span> false_type &#123; &#125;;<br><br> <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>   <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_lvalue_reference</span>&lt;_Tp&amp;&gt;<br>   : <span class="hljs-keyword">public</span> true_type &#123; &#125;;<br><br> <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>&gt;<br>   <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_rvalue_reference</span><br>   : <span class="hljs-keyword">public</span> false_type &#123; &#125;;<br><br> <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>   <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_rvalue_reference</span>&lt;_Tp&amp;&amp;&gt;<br>   : <span class="hljs-keyword">public</span> true_type &#123; &#125;;<br><br> <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>   <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_reference</span><br>   : <span class="hljs-keyword">public</span> __or_&lt;is_lvalue_reference&lt;_Tp&gt;,<br>                  is_rvalue_reference&lt;_Tp&gt;&gt;::type<br>   &#123; &#125;;<br></code></pre></td></tr></table></figure><p>这里用来判断<code>_Tp</code>是否引用类型,如果了解模板的匹配就会知道,如果是左值或则右值引用,就会继承<code>true_type</code>.</p><p>不必多说,很简单.</p><h3 id="is_const"><a class="markdownIt-Anchor" href="#is_const"></a> is_const</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/// is_const</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_const</span><br>  : <span class="hljs-keyword">public</span> false_type &#123; &#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_const</span>&lt;_Tp <span class="hljs-type">const</span>&gt;<br>  : <span class="hljs-keyword">public</span> true_type &#123; &#125;;<br></code></pre></td></tr></table></figure><p>这也同理,如果带有<code>const</code>就会选择第二个特化.</p><h3 id="is_function"><a class="markdownIt-Anchor" href="#is_function"></a> is_function</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_function</span><br>  : <span class="hljs-keyword">public</span> __bool_constant&lt;!is_const&lt;<span class="hljs-type">const</span> _Tp&gt;::value&gt; &#123; &#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_function</span>&lt;_Tp&amp;&gt;<br>  : <span class="hljs-keyword">public</span> false_type &#123; &#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_function</span>&lt;_Tp&amp;&amp;&gt;<br>  : <span class="hljs-keyword">public</span> false_type &#123; &#125;;<br></code></pre></td></tr></table></figure><p>如果在<code>_Tp</code>的前面加上<code>const</code>之后,<code>_Tp</code>的类型不为<code>const</code>,那么这个类型就是一个函数.</p><p>这里非常巧妙.</p><p>我们知道,在函数前面加上<code>const</code>,他只是变成了一个返回<code>const</code>类型的函数.</p><h3 id="is_void"><a class="markdownIt-Anchor" href="#is_void"></a> is_void</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>  <span class="hljs-keyword">using</span> <span class="hljs-type">__remove_cv_t</span> = <span class="hljs-keyword">typename</span> remove_cv&lt;_Tp&gt;::type;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__is_void_helper</span><br>  : <span class="hljs-keyword">public</span> false_type &#123; &#125;;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__is_void_helper</span>&lt;<span class="hljs-type">void</span>&gt;<br>  : <span class="hljs-keyword">public</span> true_type &#123; &#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_void</span><br>  : <span class="hljs-keyword">public</span> __is_void_helper&lt;<span class="hljs-type">__remove_cv_t</span>&lt;_Tp&gt;&gt;::type<br>  &#123; &#125;;<br></code></pre></td></tr></table></figure><p><code>__remove_cv_t</code>作用是将<code>_Tp</code>的<code>const</code>和<code>volatile</code>修饰符去掉(如果有的话).后面会提到他的实现</p><p>然后直接和<code>void</code>类型对比,作出判断.</p><h2 id="类型操作"><a class="markdownIt-Anchor" href="#类型操作"></a> 类型操作</h2><h3 id="修改const和volatile"><a class="markdownIt-Anchor" href="#修改const和volatile"></a> 修改const和volatile</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <span class="hljs-comment">// Const-volatile modifications.</span><br><br>  <span class="hljs-comment">/// remove_const</span><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">remove_const</span><br>    &#123; <span class="hljs-keyword">typedef</span> _Tp     type; &#125;;<br><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">remove_const</span>&lt;_Tp <span class="hljs-type">const</span>&gt;<br>    &#123; <span class="hljs-keyword">typedef</span> _Tp     type; &#125;;<br><br>  <span class="hljs-comment">/// remove_volatile</span><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">remove_volatile</span><br>    &#123; <span class="hljs-keyword">typedef</span> _Tp     type; &#125;;<br><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">remove_volatile</span>&lt;_Tp <span class="hljs-keyword">volatile</span>&gt;<br>    &#123; <span class="hljs-keyword">typedef</span> _Tp     type; &#125;;<br><br>  <span class="hljs-comment">/// remove_cv</span><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">remove_cv</span><br>    &#123; <span class="hljs-keyword">using</span> type = _Tp; &#125;;<br><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">remove_cv</span>&lt;<span class="hljs-type">const</span> _Tp&gt;<br>    &#123; <span class="hljs-keyword">using</span> type = _Tp; &#125;;<br><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">remove_cv</span>&lt;<span class="hljs-keyword">volatile</span> _Tp&gt;<br>    &#123; <span class="hljs-keyword">using</span> type = _Tp; &#125;;<br><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">remove_cv</span>&lt;<span class="hljs-type">const</span> <span class="hljs-keyword">volatile</span> _Tp&gt;<br>    &#123; <span class="hljs-keyword">using</span> type = _Tp; &#125;;<br><br>  <span class="hljs-comment">/// add_const</span><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">add_const</span><br>    &#123; <span class="hljs-keyword">typedef</span> _Tp <span class="hljs-type">const</span>     type; &#125;;<br><br>  <span class="hljs-comment">/// add_volatile</span><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">add_volatile</span><br>    &#123; <span class="hljs-keyword">typedef</span> _Tp <span class="hljs-keyword">volatile</span>     type; &#125;;<br><br>  <span class="hljs-comment">/// add_cv</span><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">add_cv</span><br>    &#123;<br>      <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span><br>      add_const&lt;<span class="hljs-keyword">typename</span> add_volatile&lt;_Tp&gt;::type&gt;::type     type;<br>    &#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> __cplusplus &gt; 201103L</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __cpp_lib_transformation_trait_aliases 201304</span><br><br>  <span class="hljs-comment">/// Alias template for remove_const</span><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>    <span class="hljs-keyword">using</span> <span class="hljs-type">remove_const_t</span> = <span class="hljs-keyword">typename</span> remove_const&lt;_Tp&gt;::type;<br><br>  <span class="hljs-comment">/// Alias template for remove_volatile</span><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>    <span class="hljs-keyword">using</span> <span class="hljs-type">remove_volatile_t</span> = <span class="hljs-keyword">typename</span> remove_volatile&lt;_Tp&gt;::type;<br><br>  <span class="hljs-comment">/// Alias template for remove_cv</span><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>    <span class="hljs-keyword">using</span> <span class="hljs-type">remove_cv_t</span> = <span class="hljs-keyword">typename</span> remove_cv&lt;_Tp&gt;::type;<br><br>  <span class="hljs-comment">/// Alias template for add_const</span><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>    <span class="hljs-keyword">using</span> <span class="hljs-type">add_const_t</span> = <span class="hljs-keyword">typename</span> add_const&lt;_Tp&gt;::type;<br><br>  <span class="hljs-comment">/// Alias template for add_volatile</span><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>    <span class="hljs-keyword">using</span> <span class="hljs-type">add_volatile_t</span> = <span class="hljs-keyword">typename</span> add_volatile&lt;_Tp&gt;::type;<br><br>  <span class="hljs-comment">/// Alias template for add_cv</span><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>    <span class="hljs-keyword">using</span> <span class="hljs-type">add_cv_t</span> = <span class="hljs-keyword">typename</span> add_cv&lt;_Tp&gt;::type;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>操作非常简单,接收特定类型之后在模板类内部定义一个自己想用的版本就可以了.</p><h3 id="修改引用类型"><a class="markdownIt-Anchor" href="#修改引用类型"></a> 修改引用类型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <span class="hljs-comment">/// remove_reference</span><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">remove_reference</span><br>    &#123; <span class="hljs-keyword">typedef</span> _Tp   type; &#125;;<br><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">remove_reference</span>&lt;_Tp&amp;&gt;<br>    &#123; <span class="hljs-keyword">typedef</span> _Tp   type; &#125;;<br><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">remove_reference</span>&lt;_Tp&amp;&amp;&gt;<br>    &#123; <span class="hljs-keyword">typedef</span> _Tp   type; &#125;;<br><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp, <span class="hljs-type">bool</span> = __is_referenceable&lt;_Tp&gt;::value&gt;<br>    <span class="hljs-keyword">struct</span> __add_lvalue_reference_helper<br>    &#123; <span class="hljs-keyword">typedef</span> _Tp   type; &#125;;<br><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__add_lvalue_reference_helper</span>&lt;_Tp, <span class="hljs-literal">true</span>&gt;<br>    &#123; <span class="hljs-keyword">typedef</span> _Tp&amp;   type; &#125;;<br><br>  <span class="hljs-comment">/// add_lvalue_reference</span><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">add_lvalue_reference</span><br>    : <span class="hljs-keyword">public</span> __add_lvalue_reference_helper&lt;_Tp&gt;<br>    &#123; &#125;;<br><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp, <span class="hljs-type">bool</span> = __is_referenceable&lt;_Tp&gt;::value&gt;<br>    <span class="hljs-keyword">struct</span> __add_rvalue_reference_helper<br>    &#123; <span class="hljs-keyword">typedef</span> _Tp   type; &#125;;<br><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__add_rvalue_reference_helper</span>&lt;_Tp, <span class="hljs-literal">true</span>&gt;<br>    &#123; <span class="hljs-keyword">typedef</span> _Tp&amp;&amp;   type; &#125;;<br><br>  <span class="hljs-comment">/// add_rvalue_reference</span><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">add_rvalue_reference</span><br>    : <span class="hljs-keyword">public</span> __add_rvalue_reference_helper&lt;_Tp&gt;<br>    &#123; &#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> __cplusplus &gt; 201103L</span><br>  <span class="hljs-comment">/// Alias template for remove_reference</span><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>    <span class="hljs-keyword">using</span> <span class="hljs-type">remove_reference_t</span> = <span class="hljs-keyword">typename</span> remove_reference&lt;_Tp&gt;::type;<br><br>  <span class="hljs-comment">/// Alias template for add_lvalue_reference</span><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>    <span class="hljs-keyword">using</span> <span class="hljs-type">add_lvalue_reference_t</span> = <span class="hljs-keyword">typename</span> add_lvalue_reference&lt;_Tp&gt;::type;<br><br>  <span class="hljs-comment">/// Alias template for add_rvalue_reference</span><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>    <span class="hljs-keyword">using</span> <span class="hljs-type">add_rvalue_reference_t</span> = <span class="hljs-keyword">typename</span> add_rvalue_reference&lt;_Tp&gt;::type;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>也是一样.</p><h2 id="更多类型判断"><a class="markdownIt-Anchor" href="#更多类型判断"></a> 更多类型判断</h2><h2 id=""><a class="markdownIt-Anchor" href="#"></a> </h2>]]></content>
    
    
    <categories>
      
      <category>细说CPP标准和stl源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>细说std源码</tag>
      
      <tag>模板元编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>物理层的那些东西</title>
    <link href="/f8be8220/"/>
    <url>/f8be8220/</url>
    
    <content type="html"><![CDATA[<ul><li>各种网线的特点;</li><li>各种mii接口的特点;</li></ul><span id="more"></span><p>他们的连接关系通常如下</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">双绞线-&gt;rj45接口-&gt;变压器-&gt;PHY-&gt;mii-&gt;MAC<br></code></pre></td></tr></table></figure><p>就像我随便找的这张图</p><p><img src="/img/20220301195000.jpg" alt="" /></p><h2 id="双绞线"><a class="markdownIt-Anchor" href="#双绞线"></a> 双绞线</h2><h3 id="类型"><a class="markdownIt-Anchor" href="#类型"></a> 类型</h3><table><thead><tr><th>名称</th><th>描述</th><th>速率</th><th>传输距离</th></tr></thead><tbody><tr><td>一类线</td><td>最早的电话线,只有两对线(一对收,一对发)</td><td></td><td></td></tr><tr><td>二类线</td><td>可以用于语音和数据传输,有三对线</td><td>4Mbps</td><td></td></tr><tr><td>三类线</td><td>被ANSI/TIA-568.C.2作为最低使用等级</td><td>10Mbps</td><td>100M</td></tr><tr><td>四类线</td><td></td><td>16Mbps</td><td></td></tr><tr><td>五类线</td><td></td><td>100Mbps</td><td>100M</td></tr><tr><td>超五类线(CAT5E)</td><td>从这里开始可以支持千兆,基本上够用了</td><td>1000Mbps</td><td>100M</td></tr><tr><td>六类线</td><td>新增十字骨架.因为线芯粗,水晶头会把相隔的线错开.勉强可以用超五类水晶头.其实靠谱的六类线就可以在100米内跑到万兆了.</td><td>1000Mbps</td><td>100M</td></tr><tr><td>超六类线(CAT6A)</td><td>好像新增一根抗拉线</td><td>1Gbps</td><td>100M</td></tr><tr><td>七类线</td><td>线很粗,水晶头难打</td><td>10Gbps</td><td>100M</td></tr><tr><td>超七类线(CAT7A)</td><td>线很粗,水晶头难打</td><td>10Gbps</td><td>100M</td></tr><tr><td>八类线</td><td>目前没有一个确定的标准</td><td>25G-40Gbps</td><td>30M</td></tr></tbody></table><h3 id="接线"><a class="markdownIt-Anchor" href="#接线"></a> 接线</h3><p>水晶头不带卡扣那一面朝向我们时,从左到右分别是</p><table><thead><tr><th>标准</th><th>TX+</th><th>TX-</th><th>RX+</th><th>未使用</th><th>未使用</th><th>RX-</th><th>未使用</th><th>未使用</th></tr></thead><tbody><tr><td>568A</td><td>白绿</td><td>绿</td><td>白橙</td><td>蓝</td><td>白蓝</td><td>橙</td><td>白棕</td><td>棕</td></tr><tr><td>568B</td><td>白橙</td><td>橙</td><td>白绿</td><td>蓝</td><td>白蓝</td><td>绿</td><td>白棕</td><td>棕</td></tr></tbody></table><p>常用的是568B.</p><p>有4条线未使用,在百兆网络可以只连接4条,但是poe供电和千兆以上网络必须全连接.</p><p>可以注意到,rj45不需要时钟线.</p><h2 id="phy"><a class="markdownIt-Anchor" href="#phy"></a> PHY</h2><p>IEEE802.3标准定义了三个组成PHY的主要子层</p><h3 id="8b10b编码和4b5b编码"><a class="markdownIt-Anchor" href="#8b10b编码和4b5b编码"></a> 8B/10B编码和4B/5B编码</h3><p>简单来说,就是因为一些物理原因,需要用10位数据来表示8位数据,会更有效率.而且能够在接收的时候从这些数据中得到时钟,而不需要额外的时钟线.</p><p>即使这么做会浪费20%的速率.</p><p>以下描述来自百度百科</p><blockquote><p>8B/10B，也叫做8比特/10比特或8b10b。8b/10b方式最初由IBM公司于1983年发明并应用于ESCON(200M互连系统），由Al Widmer和Peter Franaszek在IBM的刊物“研究与开发”上描述。<br />8b/10b编码的特性之一是保证DC 平衡，采用8b/10b编码方式，可使得发送的“0”、“1”数量保持基本一致，连续的“1”或“0”不超过5位，即每5个连续的“1”或“0”后必须插入一位“0”或“1”，从而保证信号DC平衡，它就是说，在链路超时时不致发生DC失调。通过8b/10b编码，可以保证传输的数据串在接收端能够被正确复原，除此之外，利用一些特殊的代码( 在PCI-Express总线中为K码) ，可以帮助接收端进行还原的工作，并且可以在早期发现数据位的传输错误，抑制错误继续发生。<br />8b/10b编码是将一组连续的8位数据分解成两组数据，一组3位，一组5位，经过编码后分别成为一组4位的代码和一组6位的代码，从而组成一组10位的数据发送出去。相反，解码是将1组10位的输入数据经过变换得到8位数据位。数据值可以统一的表示为DX.Y或KX.Y，其中D表示为数据代码，K表示为特殊的命令代码，X表示输入的原始数据的低5位EDCBA，Y 表示输入的原始数据的高3位HGF。</p></blockquote><p>4B/5B编码的出现也是类似原因.</p><h3 id="pcs"><a class="markdownIt-Anchor" href="#pcs"></a> PCS</h3><p>物理编码子层(Physical Coding Sublayer)</p><p>主要作用是对数据进行编码和解码,比如负责转换上面所说的8B/10B编码.</p><p>因此,如果速率是100Mbps,那么这里实际通过的数据速率实际上是125Mbps.</p><p>他通过mii接口与mac层交互</p><h3 id="pma"><a class="markdownIt-Anchor" href="#pma"></a> PMA</h3><p>物理介质连接子层(Physical Medium Attachment Layer)</p><p>将串行信号装换成并行信号.提供给PCS,或者反过来把从PCS来的并行信号装换成串行信号,传给PMD.</p><h3 id="pmd"><a class="markdownIt-Anchor" href="#pmd"></a> PMD</h3><p>物理介质相关子层(Physical Medium Dependent Layer)</p><p>将串行信号传输到相应的物理介质上.</p><h2 id="mii接口"><a class="markdownIt-Anchor" href="#mii接口"></a> MII接口</h2><p>MII是用于连接PHY和MAC的接口.</p><h3 id="mdio"><a class="markdownIt-Anchor" href="#mdio"></a> MDIO</h3><p>所有接口除了下文所说的线以外还带<code>MDIO</code>和<code>MDC</code>线.</p><p>通过这两条线<code>MAC</code>层可以控制<code>PHY</code>层的寄存器,并通过这些寄存器对物理层芯片进行控制和管理.</p><table><thead><tr><th>线</th><th>作用</th></tr></thead><tbody><tr><td><code>MDC</code></td><td>时钟,和<code>TX_CLK</code>,<code>RX_CLK</code>无关系</td></tr><tr><td><code>MDIO</code></td><td>双向的数据线,在上升沿有效</td></tr></tbody></table><p><code>MDIO</code>管理接口的数据帧结构如下</p><table><thead><tr><th>内容</th><th>读</th><th>写</th><th>作用</th></tr></thead><tbody><tr><td>PRE</td><td>32个连续的1</td><td>32个连续的1</td><td>前缀</td></tr><tr><td>ST</td><td><code>01</code></td><td><code>01</code></td><td></td></tr><tr><td>OP</td><td><code>10</code></td><td><code>01</code></td><td>操作码,用来表示读还是写</td></tr><tr><td>PHYAD</td><td>5位</td><td>5位</td><td>物理层芯片的地址,每个芯片都把自己的地址与这5个位进行比较.若匹配则响应后面的操作,否则忽略掉后面的操作.</td></tr><tr><td>REGAD</td><td>5位</td><td>5位</td><td>用来表示物理层芯片的32个寄存器中某个寄存器的地址</td></tr><tr><td>TA</td><td><code>Z0</code></td><td><code>10</code></td><td>状态转换域,读操作时,第一位为高阻态,第二位由<code>PHY</code>置零;写操作时,由<code>MAC</code>输出<code>10</code></td></tr><tr><td>DATA</td><td>16位</td><td>16位</td><td>数据域</td></tr><tr><td>IDLE</td><td>空闲</td><td>空闲</td><td>一半用上拉电阻使其出于高点平</td></tr></tbody></table><h3 id="速率对比"><a class="markdownIt-Anchor" href="#速率对比"></a> 速率对比</h3><table><thead><tr><th>接口</th><th>速率</th><th>时钟</th><th>线</th></tr></thead><tbody><tr><td>MII</td><td>10Mbps</td><td>2.5Mhz</td><td>16线</td></tr><tr><td>MII</td><td>100Mbps</td><td>25Mhz</td><td>16线</td></tr><tr><td>RMII</td><td>10Mbps</td><td>50Mhz</td><td>8线</td></tr><tr><td>RMII</td><td>100Mbps</td><td>50Mhz</td><td>8线</td></tr><tr><td>SMII</td><td>10Mbps</td><td>125Mhz</td><td>4线</td></tr><tr><td>SMII</td><td>100Mbps</td><td>125Mhz</td><td>4线</td></tr><tr><td>GMII</td><td>1000Mbps</td><td>125Mhz</td><td>24线</td></tr><tr><td>RGMII</td><td>10Mbps</td><td>2.5Mhz</td><td>16线</td></tr><tr><td>RGMII</td><td>100Mbps</td><td>25Mhz</td><td>16线</td></tr><tr><td>RGMII</td><td>1000Mbps</td><td>125Mhz</td><td>16线</td></tr><tr><td>SGMII</td><td>1000Mbps</td><td>625Mhz</td><td>至少2线</td></tr></tbody></table><h3 id="mii所有变种的祖先"><a class="markdownIt-Anchor" href="#mii所有变种的祖先"></a> MII,所有变种的祖先</h3><p>mii接口一共有<code>16</code>条线.</p><table><thead><tr><th>线</th><th>作用</th></tr></thead><tbody><tr><td><code>TXD[3:0]</code></td><td>数据发送,共<code>4</code>条线</td></tr><tr><td><code>TX_CLK</code></td><td>接受数据参考时钟,在<code>100Mbps</code>下,时钟频率为<code>25Mhz</code>,<code>10Mbps</code>速率下,时钟频率为<code>2.5Mhz</code></td></tr><tr><td><code>TX_EN</code></td><td>发送使能信号,只有在<code>TX_EN</code>有效期内传的数据才有效</td></tr><tr><td><code>TX_ER</code></td><td>发送数据错误提示信号,同步于<code>TX_CLK</code>,高电平有效.有效期内传输的数据无效.在<code>10Mbps</code>速率下不起作用</td></tr><tr><td><code>RXD[3:0]</code></td><td>数据接收,共<code>4</code>条线</td></tr><tr><td><code>RX_CLK</code></td><td>接收数据参考时钟,在<code>100Mbps</code>下,时钟频率为<code>25Mhz</code>,<code>10Mbps</code>速率下,时钟频率为<code>2.5Mhz</code></td></tr><tr><td><code>RX_DV</code></td><td>接收使能信号,只有在<code>RX_DV</code>有效期内传的数据才有效</td></tr><tr><td><code>RX_ER</code></td><td>接收数据错误提示信号,同步于<code>TX_CLK</code>,高电平有效.有效期内传输的数据无效.在<code>10Mbps</code>速率下不起作用</td></tr><tr><td><code>CRS</code></td><td>载波侦测信号,不需要同步于参考时钟,只有<code>PHY</code>在半双工模式下有效</td></tr><tr><td><code>COL</code></td><td>冲突检测信号,不需要同步于参考时钟,只有<code>PHY</code>在半双工模式下有效</td></tr></tbody></table><p>注意,这里的<code>TX_CLK</code>也是由<code>PHY</code>提供的.即使数据由<code>MAC</code>发送.</p><h3 id="rmii"><a class="markdownIt-Anchor" href="#rmii"></a> RMII</h3><p>简化版的<code>MII</code>,减少到<code>8</code>根线.</p><table><thead><tr><th>线</th><th>作用</th></tr></thead><tbody><tr><td><code>TXD[1:0]</code></td><td>数据发送,只有两条</td></tr><tr><td><code>TX_EN</code></td><td>发送使能信号</td></tr><tr><td><code>RXD[1:0]</code></td><td>数据接收,只有两条</td></tr><tr><td><code>RX_ER</code></td><td>接收数据错误提示信号</td></tr><tr><td><code>CLK_REF</code></td><td>由外部时钟提供的<code>50Mhz</code>时钟</td></tr><tr><td><code>CRS_DV</code></td><td>同时发送<code>RX_DV</code>和<code>CRS</code>信号,<code>MAC</code>能够从中获得两个信号</td></tr></tbody></table><p>这里注意,因为时钟总是50Mhz,那么两条数据线总能传100Mbps才对,为什么会有10Mbps的选项呢?</p><p>其实是在10Mbps速率时,<code>TX/RX</code>每隔10个周期采样一个数据,因而<code>TX/RX</code>数据需要在数据线上保留10个周期,相当于一个数据发送10次.</p><h3 id="smii及其后代"><a class="markdownIt-Anchor" href="#smii及其后代"></a> SMII及其后代</h3><p>串行MII,也就是数据线只有一条,并且只需要四条线.</p><table><thead><tr><th>线</th><th>作用</th></tr></thead><tbody><tr><td>TXD</td><td>发送数据</td></tr><tr><td>RXD</td><td>接收数据</td></tr><tr><td>SYNC</td><td>每10个时钟周期由<code>PHY</code>置为高点平,表示一组数据开始</td></tr><tr><td>CLK_REF</td><td>120Mhz,因为每8位数据中会插入2位控制信号,所以需要大于100Mhz</td></tr></tbody></table><p>在发送数据上增加的数据是<code>TX_EN</code>和<code>TX_ER</code>.</p><p>在接收数据上增加的数据是<code>RX_DV</code>和<code>CRS</code>.</p><p>使用和RMII同样的方法来实现10Mbps.</p><h4 id="ssmii"><a class="markdownIt-Anchor" href="#ssmii"></a> SSMII</h4><p>同步串行MII,收发使用独立的<code>SYNC</code>和<code>CLK</code>,因此比SMII多两条线.</p><p>注意这个接口的<code>SYNC</code>和<code>CLK</code>都是由<code>PHY</code>提供的,无论方向如何.</p><table><thead><tr><th>线</th><th>作用</th></tr></thead><tbody><tr><td>TXD</td><td>发送数据</td></tr><tr><td>TX_CLK</td><td>发送时钟</td></tr><tr><td>TX_SYNC</td><td>发送同步时钟</td></tr><tr><td>RXD</td><td>接收数据</td></tr><tr><td>RX_CLK</td><td>接收时钟</td></tr><tr><td>RX_SYNC</td><td>接收同步时钟</td></tr></tbody></table><h4 id="sssmii"><a class="markdownIt-Anchor" href="#sssmii"></a> SSSMII</h4><p>源同步串行MII,和上一个SSMII的区别在于,发送方的<code>SYNC</code>和<code>CLK</code>由<code>MAC</code>提供.</p><table><thead><tr><th>线</th><th>作用</th></tr></thead><tbody><tr><td>TXD</td><td>发送数据</td></tr><tr><td>TX_CLK</td><td>发送时钟</td></tr><tr><td>TX_SYNC</td><td>发送同步时钟</td></tr><tr><td>RXD</td><td>接收数据</td></tr><tr><td>RX_CLK</td><td>接收时钟</td></tr><tr><td>RX_SYNC</td><td>接收同步时钟</td></tr></tbody></table><h3 id="gmii及其后代"><a class="markdownIt-Anchor" href="#gmii及其后代"></a> GMII及其后代</h3><p>时钟频率提升到125Mbps,数据线变为8根,因此它能够达到千兆速度.</p><p>注意,这里的<code>TX_CLK</code>是由<code>MAC</code>提供的,这和MII不同.</p><p>同时他也兼容MII,这时候只使用4条数据线,并且时钟方向改变.</p><table><thead><tr><th>线</th><th>作用</th></tr></thead><tbody><tr><td><code>TXD[7:0]</code></td><td>数据发送,共<code>4</code>条线</td></tr><tr><td><code>TX_CLK</code></td><td>接受数据参考时钟</td></tr><tr><td><code>TX_EN</code></td><td>发送使能信号,只有在<code>TX_EN</code>有效期内传的数据才有效</td></tr><tr><td><code>TX_ER</code></td><td>发送数据错误提示信号,同步于<code>TX_CLK</code>,高电平有效.有效期内传输的数据无效.</td></tr><tr><td><code>RXD[7:0]</code></td><td>数据接收,共<code>4</code>条线</td></tr><tr><td><code>RX_CLK</code></td><td>接收数据参考时钟</td></tr><tr><td><code>RX_DV</code></td><td>接收使能信号,只有在<code>RX_DV</code>有效期内传的数据才有效</td></tr><tr><td><code>RX_ER</code></td><td>接收数据错误提示信号,同步于<code>TX_CLK</code>,高电平有效.有效期内传输的数据无效.</td></tr><tr><td><code>CRS</code></td><td>载波侦测信号,不需要同步于参考时钟,只有<code>PHY</code>在半双工模式下有效</td></tr><tr><td><code>COL</code></td><td>冲突检测信号,不需要同步于参考时钟,只有<code>PHY</code>在半双工模式下有效</td></tr></tbody></table><h4 id="rgmii"><a class="markdownIt-Anchor" href="#rgmii"></a> RGMII</h4><p>简化的GMII,只有14条线.</p><table><thead><tr><th>线</th><th>作用</th></tr></thead><tbody><tr><td><code>TXD[3:0]</code></td><td>数据发送,共<code>4</code>条线</td></tr><tr><td><code>TX_CLK</code></td><td>接受数据参考时钟</td></tr><tr><td><code>TX_EN</code></td><td>发送使能信号,只有在<code>TX_EN</code>有效期内传的数据才有效</td></tr><tr><td><code>RXD[3:0]</code></td><td>数据接收,共<code>4</code>条线</td></tr><tr><td><code>RX_CLK</code></td><td>接收数据参考时钟</td></tr><tr><td><code>RX_DV</code></td><td>接收使能信号,只有在<code>RX_DV</code>有效期内传的数据才有效</td></tr><tr><td><code>CRS</code></td><td>载波侦测信号,不需要同步于参考时钟,只有<code>PHY</code>在半双工模式下有效</td></tr><tr><td><code>COL</code></td><td>冲突检测信号,不需要同步于参考时钟,只有<code>PHY</code>在半双工模式下有效</td></tr></tbody></table><p>时钟频率依旧是125Mbps,数据线减少为4条.</p><p>为了达到1000Mbps,它在上升沿下降沿都采样数据.</p><p>上升沿发送的数据相当于原本的<code>TXD[3:0]</code>,下降沿发送的数据相当于原来的<code>TXD[7:4]</code>.接收同理.</p><p>上升沿发送使能信息,下降沿发送错误信息,从而在一条线上发送使能和错误信息.</p><p>如果降低时钟频率为25Mhz和2.5Mhz,也可以实现100Mbps和10Mbps.</p><h4 id="sgmii"><a class="markdownIt-Anchor" href="#sgmii"></a> SGMII</h4><p>串行的GMII,收发各一对差分信号线.时钟频率625Mhz,在上升沿和下降沿都采样.</p><p>有<code>CLK</code>,但是有时候不使用,而是直接从数据中恢复出时钟.</p><p>因为每8位数据都需要插入2位数据(使能和错误),因此传输速率实际需要达到1250Mbps=625Mhz*2(两次采样).</p><p>这也就是为什么时钟频率是625Mbps.</p><table><thead><tr><th>线</th><th>作用</th></tr></thead><tbody><tr><td>TXD</td><td>发送</td></tr><tr><td>TX_CLK</td><td>发送时钟</td></tr><tr><td>RXD</td><td>接收</td></tr><tr><td>RX_CLK</td><td>接收时钟</td></tr></tbody></table><p>SGMII接口可以配置成SerDes接口,直接外接光模块.</p><p>这时候虽然没有使能信号和错误信号.但625Mhz的频率还是只能传1000Mbps的数据.</p><p>为什么这里会多用20%的频率呢?</p><p>因为这时候没有了<code>PHY</code>,需要直接接收<code>8B/10B</code>信号,传给<code>MAC</code>处理.</p><h4 id="qsgmii"><a class="markdownIt-Anchor" href="#qsgmii"></a> QSGMII</h4><p>四个SGMII合在一起,实现一个5000Mbps的接口.</p><h2 id="wlan-和-wifi"><a class="markdownIt-Anchor" href="#wlan-和-wifi"></a> wlan 和 wifi</h2><p>wlan是无线局域网,802.11是wlan的一个标准,wifi是802.11的一个实现.</p><h3 id="各代wifi的特点"><a class="markdownIt-Anchor" href="#各代wifi的特点"></a> 各代wifi的特点</h3><table><thead><tr><th></th><th>标准</th><th>年份</th><th>工作频段</th><th>理论速率</th></tr></thead><tbody><tr><td></td><td>802.11</td><td>1997</td><td>2.4GHZ</td><td>2Mbps</td></tr><tr><td></td><td>802.11b</td><td>1999</td><td>2.4GHZ</td><td>11Mbps</td></tr><tr><td></td><td>802.11a</td><td>1999</td><td>5GHZ</td><td>54Mbps</td></tr><tr><td></td><td>802.11g</td><td>1999</td><td>2.4GHZ</td><td>54Mbps</td></tr><tr><td>WI-FI4</td><td>802.11n</td><td>2009</td><td>2.4GHZ and 5GHZ</td><td>600Mbps</td></tr><tr><td>WI-FI5</td><td>802.11ac Wave1</td><td>2013</td><td>5GHZ</td><td>3.47Gbps</td></tr><tr><td>WI-FI5</td><td>802.11ac Wave2</td><td>2015</td><td>5GHZ</td><td>6.9Gbps</td></tr><tr><td>WI-FI6</td><td>802.11ax</td><td>2018</td><td>2.4GHZ and 5GHZ</td><td>9.6Gbps</td></tr></tbody></table><p>表面上看wifi5和wifi6的理论速率区别不大,但是大部分wifi5产品实际只能到达1Gbps,而wifi6设备确实能够达到理论速率.</p><p>实际上他们的带宽差距接近10倍.</p><p>注意wifi5只有5Ghz,观察openwrt的选项可以发现2.4Ghz只能设置成n或者ax.</p><p>2.4Ghz频段指的是$ [2.4,2.4835] $Ghz.</p><p>5Ghz频段指的是$ [5.15,5.35] <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mi>h</mi><mi>z</mi><mi mathvariant="normal">和</mi></mrow><annotation encoding="application/x-tex">Ghz和</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">G</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord cjk_fallback">和</span></span></span></span> [5.725,5.85] $Ghz.</p>]]></content>
    
    
    <categories>
      
      <category>经验和总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mii</tag>
      
      <tag>rj45</tag>
      
      <tag>phy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>毛子精简版windows系统下载</title>
    <link href="/9827976a/"/>
    <url>/9827976a/</url>
    
    <content type="html"><![CDATA[<ul><li>磁力链接;</li></ul><span id="more"></span><p>有时候,我们想要在<code>linux</code>上开一个<code>windows</code>虚拟机,而且是常驻的,让我们挂一些软件.</p><p>我们并不需要一个很完整的系统,只需要到达<strong>又不是不能用</strong>的程度就好.</p><p>同时希望他不要消耗太多内存.</p><p>我从网上搜罗来两个磁力链接.</p><p>用磁力链接下载比各路阴间网盘舒服多了.不提供网盘方式.</p><table><thead><tr><th>链接</th><th>我测试时的下载速度</th><th>说明</th></tr></thead><tbody><tr><td><code>magnet:?xt=urn:btih:ad3e4827b7d77a636a8704683714ab080e231c72</code></td><td>没速度</td><td>win10,下不动不知道内容</td></tr><tr><td><code>magnet:?xt=urn:btih:31aaa22e5e00c2bdbb4bc742f6df3df322763bee</code></td><td>满速下载</td><td>虽然安装页面是win8,但是装好之后是win7</td></tr></tbody></table><p>win7使用kms会报错,可以使用密钥<code>FJ82H-XT6CR-J8D7P-XQJJ2-GPDD4</code>.</p><p>另外记录一些磁力链接</p><table><thead><tr><th>链接</th><th>说明</th></tr></thead><tbody><tr><td><code>magnet:?xt=urn:btih:c6df2f47d033d54b054cafe7ef683ba167222d92</code></td><td>windows XP SP3</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>资源分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>精简系统</tag>
      
      <tag>磁力链接</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>麻雀d1s修复adb和phoenixsuit连接问题</title>
    <link href="/a30c2c5a/"/>
    <url>/a30c2c5a/</url>
    
    <content type="html"><![CDATA[<ul><li>修复pc连接电脑掉电问题;</li><li>修复phoenixsuit连接问题;</li></ul><span id="more"></span><h2 id="修复pc连接电脑后掉电问题"><a class="markdownIt-Anchor" href="#修复pc连接电脑后掉电问题"></a> 修复pc连接电脑后掉电问题</h2><p>官方的<code>tina</code>编译出来之后,连接电脑,如果使用了<code>otg</code>口,会导致这个开发板不断的断开和重连.</p><p>而且串口不断地打印断连重连的信息.有这个报错信息:</p><blockquote><p>WARN: get power supply failed\n</p></blockquote><p>看起来是和供电有关的问题,我在网上找到<a href="https://blog.csdn.net/qq_45362097/article/details/120710425">这个文章</a>.</p><p>作者说这是因为开发板连接<code>usb</code>之后会把某个电流限制到<code>500ma</code>.我们可以改一下</p><p>在文件<code>tina-d1-open/lichee/linux-5.4/drivers/usb/sunxi_usb/udc/sunxi_udc.c</code>中,修改函数<code>sunxi_set_cur_vol_work</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">sunxi_set_cur_vol_work</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> work_struct *work)</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(SUNXI_USB_FPGA) &amp;&amp; defined(CONFIG_POWER_SUPPLY)</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">power_supply</span> *<span class="hljs-title">psy</span> =</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">power_supply_propval</span> <span class="hljs-title">temp</span>;</span><br><br>        <span class="hljs-keyword">if</span> (of_find_property(g_udc_pdev-&gt;dev.of_node, <span class="hljs-string">&quot;det_vbus_supply&quot;</span>, <span class="hljs-literal">NULL</span>))<br>                psy = devm_power_supply_get_by_phandle(&amp;g_udc_pdev-&gt;dev,<br>                                                     <span class="hljs-string">&quot;det_vbus_supply&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (!psy || IS_ERR(psy)) &#123;<br>                DMSG_PANIC(<span class="hljs-string">&quot;%s()%d WARN: get power supply failed\n&quot;</span>,<br>                           __func__, __LINE__);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>                temp.intval = <span class="hljs-number">2500</span>; <span class="hljs-comment">//改为2500ma</span><br><br>                power_supply_set_property(psy,<br>                                        POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT, &amp;temp);<br>        &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>改完之后编译打包,这个现象不会出现了.</p><h2 id="修复phoenixsuit连接问题"><a class="markdownIt-Anchor" href="#修复phoenixsuit连接问题"></a> 修复phoenixsuit连接问题</h2><p>修改文件<code>tina-d1-open/lichee/brandy-2.0/u-boot-2018/drivers/sunxi_flash/mmc/sdmmc.c</code>中的<code>sunxi_sprite_mmc_probe</code>函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sunxi_sprite_mmc_probe</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_MACH_SUN50IW11</span><br>        <span class="hljs-keyword">return</span> sdmmc_init_for_sprite(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">//修改了这里.</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        <span class="hljs-type">int</span> workmode = uboot_spare_head.boot_data.work_mode;<br>        <span class="hljs-keyword">if</span> (workmode == WORK_MODE_CARD_PRODUCT)<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> sdmmc_init_for_sprite(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>改了之后就可以直接用phoenixsuit来刷机.而不需要使用读卡器.</p>]]></content>
    
    
    <categories>
      
      <category>经验和总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>riscv</tag>
      
      <tag>全志d1s</tag>
      
      <tag>tina</tag>
      
      <tag>麻雀开发板</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++atomic源码分析</title>
    <link href="/51d9423d/"/>
    <url>/51d9423d/</url>
    
    <content type="html"><![CDATA[<ul><li>未写完;</li></ul><span id="more"></span><h2 id="atomic的那些特化"><a class="markdownIt-Anchor" href="#atomic的那些特化"></a> atomic的那些特化</h2><p><code>atomic</code>主要有4种特化:</p><ol><li><p>通用实现;</p></li><li><p>针对<code>bool</code>类型的特化;</p></li><li><p>针对指针类型的特化;</p></li><li><p>针对普通数值类型的特化;</p></li></ol><h2 id="针对普通数值类型的特化"><a class="markdownIt-Anchor" href="#针对普通数值类型的特化"></a> 针对普通数值类型的特化</h2><p>对于以下的类型,统统是继承了<code>__atomic_base&lt;type&gt;</code>.</p><ol><li><code>char; signed char; unsigned char;</code></li><li><code>short; unsigned short;</code></li><li><code>int; unsigned int;</code></li><li><code>long; unsigned long;</code></li><li><code>long long; unsigned long long;</code></li><li><code>wchar_t;</code></li><li><code>char16_t; char32_t;</code></li></ol><p>他们的特化实现都一样,形如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <span class="hljs-keyword">template</span>&lt;&gt;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">atomic</span>&lt;<span class="hljs-type">char</span>&gt; : __atomic_base&lt;<span class="hljs-type">char</span>&gt;<br>    &#123;<br>      <span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> __integral_type;<br>      <span class="hljs-keyword">typedef</span> __atomic_base&lt;<span class="hljs-type">char</span>&gt; __base_type;<br><br>      <span class="hljs-built_in">atomic</span>() <span class="hljs-keyword">noexcept</span> = <span class="hljs-keyword">default</span>;<br>      ~<span class="hljs-built_in">atomic</span>() <span class="hljs-keyword">noexcept</span> = <span class="hljs-keyword">default</span>;<br>      <span class="hljs-built_in">atomic</span>(<span class="hljs-type">const</span> atomic&amp;) = <span class="hljs-keyword">delete</span>;<br>      atomic&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> atomic&amp;) = <span class="hljs-keyword">delete</span>;<br>      atomic&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> atomic&amp;) <span class="hljs-keyword">volatile</span> = <span class="hljs-keyword">delete</span>;<br><br>      <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">atomic</span><span class="hljs-params">(__integral_type __i)</span> <span class="hljs-keyword">noexcept</span> : __base_type(__i) &#123;</span> &#125;<br><br>      <span class="hljs-keyword">using</span> __base_type::<span class="hljs-keyword">operator</span> __integral_type;<br>      <span class="hljs-keyword">using</span> __base_type::<span class="hljs-keyword">operator</span>=;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> __cplusplus &gt;= 201703L</span><br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> is_always_lock_free = ATOMIC_CHAR_LOCK_FREE == <span class="hljs-number">2</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;;<br></code></pre></td></tr></table></figure><h3 id="构造方法"><a class="markdownIt-Anchor" href="#构造方法"></a> 构造方法</h3><p><code>atomic()</code>和<code>~atomioc()</code>被定义为<code>default</code>.</p><p><code>atomic(char)</code>则是直接初始化给私有成员<code>__i</code>.</p><p>其他都<code>delete</code>了.</p><p>我暂且不知道为什么不允许拷贝<code>atomic</code>.</p><h3 id="volatile赋值操作符"><a class="markdownIt-Anchor" href="#volatile赋值操作符"></a> volatile赋值操作符</h3><p>对于<code>volatile</code>修饰的对象,赋值时会调用<code>volatile</code>修饰的赋值操作符.</p><h3 id="delete和using"><a class="markdownIt-Anchor" href="#delete和using"></a> delete和using</h3><p>可以看到,这里<code>delete</code>了<code>operator=</code>,但是却<code>using</code>了父类的<code>operator=</code>.</p><p>这样做,只是禁用了<code>atomic&amp; operator=(const atomic&amp;)</code>这个版本的<code>operator</code>.</p><p>但是父类的<code>operator=()</code>定义了参数为<code>char</code>时的行为,则不会被<code>delete</code>.</p><p>也就是这样:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::atomic&lt;<span class="hljs-type">char</span>&gt; x;<br>std::atomic&lt;<span class="hljs-type">char</span>&gt; y;<br>x = y; <span class="hljs-comment">// 语法错误</span><br>x = (<span class="hljs-type">char</span>)<span class="hljs-number">1</span>; <span class="hljs-comment">// 可以</span><br></code></pre></td></tr></table></figure><h3 id="atomic_base"><a class="markdownIt-Anchor" href="#atomic_base"></a> atomic_base</h3><p>除了以上内容,atomic继承了<code>__atomic_base</code>.我们来细说他.</p><h4 id="一些类型定义"><a class="markdownIt-Anchor" href="#一些类型定义"></a> 一些类型定义</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _ITp&gt;<br>   <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__atomic_base</span><br>   &#123;<br>     <span class="hljs-keyword">using</span> value_type = _ITp;<br>     <span class="hljs-keyword">using</span> difference_type = value_type;<br><br>   <span class="hljs-keyword">private</span>:<br>     <span class="hljs-keyword">typedef</span> _ITp __int_type;<br><br>     <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> _S_alignment =<br><span class="hljs-built_in">sizeof</span>(_ITp) &gt; <span class="hljs-built_in">alignof</span>(_ITp) ? <span class="hljs-built_in">sizeof</span>(_ITp) : <span class="hljs-built_in">alignof</span>(_ITp);<br><br>     <span class="hljs-built_in">alignas</span>(_S_alignment) __int_type _M_i;<br></code></pre></td></tr></table></figure><p>这里把传入的数值类型命名为<code>value_type</code>.</p><p>这里的<code>difference_type</code>是用于描述差值的类型,显然数值和数值的差值,用的还是这个数值本身的类型.</p><p><code>_S_alignment</code>取<code>_ITp</code>的大小和对齐尺寸中的最大值.</p><p>众所周知,数值类型的大小和对齐方式也许不一样,比如在<code>32</code>位系统中,<code>long double</code>大小为<code>12</code>字节,但是却按照<code>4</code>字节对齐.</p><p>但是注意,这里没有特化<code>long double</code>.也就是所有情况下应该都相同,并且都是<code>2</code>的次幂.</p><p><code>alignas(_S_alignment) __int_type _M_i;</code>,声明一个按照<code>_S_alignment</code>对齐的,<code>_ITp</code>类型的成员.</p><p>这个成员就是原子类要操作的那个数值了.</p><h4 id="构造方法-2"><a class="markdownIt-Anchor" href="#构造方法-2"></a> 构造方法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span>:<br>  __atomic_base() <span class="hljs-keyword">noexcept</span> = <span class="hljs-keyword">default</span>;<br>  ~__atomic_base() <span class="hljs-keyword">noexcept</span> = <span class="hljs-keyword">default</span>;<br>  __atomic_base(<span class="hljs-type">const</span> __atomic_base&amp;) = <span class="hljs-keyword">delete</span>;<br>  __atomic_base&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> __atomic_base&amp;) = <span class="hljs-keyword">delete</span>;<br>  __atomic_base&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> __atomic_base&amp;) <span class="hljs-keyword">volatile</span> = <span class="hljs-keyword">delete</span>;<br><br>  <span class="hljs-comment">// Requires __int_type convertible to _M_i.</span><br>  <span class="hljs-keyword">constexpr</span> __atomic_base(__int_type __i) <span class="hljs-keyword">noexcept</span> : _M_i (__i) &#123; &#125;<br></code></pre></td></tr></table></figure><p>同样禁用了拷贝构造,而且可以直接从一个数值初始化.</p><h4 id="操作数值"><a class="markdownIt-Anchor" href="#操作数值"></a> 操作数值</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp">     <span class="hljs-keyword">operator</span> __int_type() <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span><br>     &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">load</span>(); &#125;<br><br>     <span class="hljs-keyword">operator</span> __int_type() <span class="hljs-type">const</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">noexcept</span><br>     &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">load</span>(); &#125;<br><br>     __int_type<br>     <span class="hljs-keyword">operator</span>=(__int_type __i) <span class="hljs-keyword">noexcept</span><br>     &#123;<br><span class="hljs-built_in">store</span>(__i);<br><span class="hljs-keyword">return</span> __i;<br>     &#125;<br><br>     __int_type<br>     <span class="hljs-keyword">operator</span>=(__int_type __i) <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">noexcept</span><br>     &#123;<br><span class="hljs-built_in">store</span>(__i);<br><span class="hljs-keyword">return</span> __i;<br>     &#125;<br></code></pre></td></tr></table></figure><p>当我们把一个<code>atomic&lt;char&gt;</code>类型强转为<code>char</code>时,就会调用<code>operator __int_type()</code>.从而取出数值.</p><p>而第二个函数就是上面所说的,子类<code>using::operator=(char)</code>的函数.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp">__int_type<br><span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) <span class="hljs-keyword">noexcept</span><br>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">fetch_add</span>(<span class="hljs-number">1</span>); &#125;<br><br>__int_type<br><span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">noexcept</span><br>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">fetch_add</span>(<span class="hljs-number">1</span>); &#125;<br><br>__int_type<br><span class="hljs-keyword">operator</span>--(<span class="hljs-type">int</span>) <span class="hljs-keyword">noexcept</span><br>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">fetch_sub</span>(<span class="hljs-number">1</span>); &#125;<br><br>__int_type<br><span class="hljs-keyword">operator</span>--(<span class="hljs-type">int</span>) <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">noexcept</span><br>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">fetch_sub</span>(<span class="hljs-number">1</span>); &#125;<br><br>__int_type<br><span class="hljs-keyword">operator</span>++() <span class="hljs-keyword">noexcept</span><br>&#123; <span class="hljs-keyword">return</span> __atomic_add_fetch(&amp;_M_i, <span class="hljs-number">1</span>, <span class="hljs-built_in">int</span>(memory_order_seq_cst)); &#125;<br><br>__int_type<br><span class="hljs-keyword">operator</span>++() <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">noexcept</span><br>&#123; <span class="hljs-keyword">return</span> __atomic_add_fetch(&amp;_M_i, <span class="hljs-number">1</span>, <span class="hljs-built_in">int</span>(memory_order_seq_cst)); &#125;<br><br>__int_type<br><span class="hljs-keyword">operator</span>--() <span class="hljs-keyword">noexcept</span><br>&#123; <span class="hljs-keyword">return</span> __atomic_sub_fetch(&amp;_M_i, <span class="hljs-number">1</span>, <span class="hljs-built_in">int</span>(memory_order_seq_cst)); &#125;<br><br>__int_type<br><span class="hljs-keyword">operator</span>--() <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">noexcept</span><br>&#123; <span class="hljs-keyword">return</span> __atomic_sub_fetch(&amp;_M_i, <span class="hljs-number">1</span>, <span class="hljs-built_in">int</span>(memory_order_seq_cst)); &#125;<br><br>__int_type<br><span class="hljs-keyword">operator</span>+=(__int_type __i) <span class="hljs-keyword">noexcept</span><br>&#123; <span class="hljs-keyword">return</span> __atomic_add_fetch(&amp;_M_i, __i, <span class="hljs-built_in">int</span>(memory_order_seq_cst)); &#125;<br><br>__int_type<br><span class="hljs-keyword">operator</span>+=(__int_type __i) <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">noexcept</span><br>&#123; <span class="hljs-keyword">return</span> __atomic_add_fetch(&amp;_M_i, __i, <span class="hljs-built_in">int</span>(memory_order_seq_cst)); &#125;<br><br>__int_type<br><span class="hljs-keyword">operator</span>-=(__int_type __i) <span class="hljs-keyword">noexcept</span><br>&#123; <span class="hljs-keyword">return</span> __atomic_sub_fetch(&amp;_M_i, __i, <span class="hljs-built_in">int</span>(memory_order_seq_cst)); &#125;<br><br>__int_type<br><span class="hljs-keyword">operator</span>-=(__int_type __i) <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">noexcept</span><br>&#123; <span class="hljs-keyword">return</span> __atomic_sub_fetch(&amp;_M_i, __i, <span class="hljs-built_in">int</span>(memory_order_seq_cst)); &#125;<br><br>__int_type<br><span class="hljs-keyword">operator</span>&amp;=(__int_type __i) <span class="hljs-keyword">noexcept</span><br>&#123; <span class="hljs-keyword">return</span> __atomic_and_fetch(&amp;_M_i, __i, <span class="hljs-built_in">int</span>(memory_order_seq_cst)); &#125;<br><br>__int_type<br><span class="hljs-keyword">operator</span>&amp;=(__int_type __i) <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">noexcept</span><br>&#123; <span class="hljs-keyword">return</span> __atomic_and_fetch(&amp;_M_i, __i, <span class="hljs-built_in">int</span>(memory_order_seq_cst)); &#125;<br><br>__int_type<br><span class="hljs-keyword">operator</span>|=(__int_type __i) <span class="hljs-keyword">noexcept</span><br>&#123; <span class="hljs-keyword">return</span> __atomic_or_fetch(&amp;_M_i, __i, <span class="hljs-built_in">int</span>(memory_order_seq_cst)); &#125;<br><br>__int_type<br><span class="hljs-keyword">operator</span>|=(__int_type __i) <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">noexcept</span><br>&#123; <span class="hljs-keyword">return</span> __atomic_or_fetch(&amp;_M_i, __i, <span class="hljs-built_in">int</span>(memory_order_seq_cst)); &#125;<br><br>__int_type<br><span class="hljs-keyword">operator</span>^=(__int_type __i) <span class="hljs-keyword">noexcept</span><br>&#123; <span class="hljs-keyword">return</span> __atomic_xor_fetch(&amp;_M_i, __i, <span class="hljs-built_in">int</span>(memory_order_seq_cst)); &#125;<br><br>__int_type<br><span class="hljs-keyword">operator</span>^=(__int_type __i) <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">noexcept</span><br>&#123; <span class="hljs-keyword">return</span> __atomic_xor_fetch(&amp;_M_i, __i, <span class="hljs-built_in">int</span>(memory_order_seq_cst)); &#125;<br></code></pre></td></tr></table></figure><p>这里逻辑非常简单,我们暂时认为他们调用的函数是原子性操作.</p><p>整理用到的函数如下,我们后面会分析:</p><table><thead><tr><th>函数</th><th>相当于原子性的</th></tr></thead><tbody><tr><td><code>load</code></td><td>读</td></tr><tr><td><code>store</code></td><td>写</td></tr><tr><td><code>fetch_add</code></td><td><code>x++</code></td></tr><tr><td><code>fetch_sub</code></td><td><code>x--</code></td></tr><tr><td><code>__atomic_add_fetch</code></td><td><code>x+=i</code></td></tr><tr><td><code>__atomic_sub_fetch</code></td><td><code>x-=i</code></td></tr><tr><td><code>__atomic_and_fetch</code></td><td><code>x&amp;=i</code></td></tr><tr><td><code>__atomic_or_fetch</code></td><td><code>x|=i</code></td></tr><tr><td><code>__atomic_xor_fetch</code></td><td><code>x^=i</code></td></tr></tbody></table><p>这里要注意一目运算符重载的方法,我们可以认为:</p><p><code>operator++(int)</code>是重载了<code>i++</code>操作.</p><p>这里的<code>int</code>参数纯粹用于将它和<code>++i</code>区别开来,不会去使用这个参数.</p><p><code>operator++()</code>是重载了<code>++i</code>操作.</p><p>其他同理.</p><h4 id="检查这个对象的原子操作是否免锁"><a class="markdownIt-Anchor" href="#检查这个对象的原子操作是否免锁"></a> 检查这个对象的原子操作是否免锁</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>     <span class="hljs-function"><span class="hljs-type">bool</span></span><br><span class="hljs-function">     <span class="hljs-title">is_lock_free</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">     </span>&#123;<br><span class="hljs-comment">// Use a fake, minimally aligned pointer.</span><br><span class="hljs-keyword">return</span> __atomic_is_lock_free(<span class="hljs-built_in">sizeof</span>(_M_i),<br>    <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span> *&gt;(-_S_alignment));<br>     &#125;<br><br>     <span class="hljs-function"><span class="hljs-type">bool</span></span><br><span class="hljs-function">     <span class="hljs-title">is_lock_free</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">     </span>&#123;<br><span class="hljs-comment">// Use a fake, minimally aligned pointer.</span><br><span class="hljs-keyword">return</span> __atomic_is_lock_free(<span class="hljs-built_in">sizeof</span>(_M_i),<br>    <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span> *&gt;(-_S_alignment));<br>     &#125;<br></code></pre></td></tr></table></figure><p><code>reinterpret_cast&lt;void *&gt;</code>用<code>void*</code>的方式来理解<code>-_S_alignment</code>的每一个比特位.</p><p>也就是把<code>-_S_alignment</code>当成一个<code>void*</code>指针.</p><p>不管<code>-_S_alignment</code>原本是什么含义,而只看他字面上的内容.</p><p>我们无法找到<code>__atomic_is_lock_free</code>这个函数,因为他是被重命名而来的.</p><p>观察以下这个宏</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> C2_(X,Y)        X ## Y</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> C2(X,Y)                C2_(X,Y)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> S2(X)                #X</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> S(X)                S2(X)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ASMNAME(X)        __asm__(S(C2(__USER_LABEL_PREFIX__,X)))</span><br><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> EXPORT_ALIAS(X)                                        \</span><br><span class="hljs-meta">        extern typeof(C2(libat_,X)) C2(export_,X)                \</span><br><span class="hljs-meta">          ASMNAME(C2(__atomic_,X))                                \</span><br><span class="hljs-meta">          __attribute__((alias(S(C2(libat_,X)))))</span><br><br></code></pre></td></tr></table></figure><p>这里用一个宏把<code>libat_&lt;X&gt;</code>重命名为<code>__atomic_&lt;X&gt;</code>.</p><p><code>#X</code>表示把<code>X</code>变为字符串,这里用到两次.</p><p>用于拼接产生一个字符串,作为参数传给<code>__asm__</code>和<code>alias</code>.</p><p><code>X ## Y</code>用于拼接两个字符串,在这里基本就是用来拼接函数名.</p><p><code>alias</code>重命名函数,用法像是这样:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">typeof</span>(oldname) newname __attribute__((<span class="hljs-built_in">alias</span>(<span class="hljs-string">&quot;oldname&quot;</span>)));<br></code></pre></td></tr></table></figure><p><code>__USER_LABEL_PREFIX__</code>见这个<a href="https://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html">链接</a>,他看起来是空的.</p><p>总之,<code>EXPORT_ALIAS</code>将会翻译为:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">typeof</span>(libat_X) export_X __asm__(<span class="hljs-string">&quot;__atomic_X&quot;</span>) __attribute__((<span class="hljs-built_in">alias</span>(<span class="hljs-string">&quot;libat_X&quot;</span>)));<br></code></pre></td></tr></table></figure><p>这里是给他起了两个名字,<code>export_X</code>和<code>__atomic_X</code>.</p><p>如果你想要自己试一下这个语法,编译时会发现找不到符号<code>libat_X</code>.</p><p>因为<code>C++</code>的符号名不是函数名,你用<code>gcc</code>编译就可以了.</p><p>这个<code>__atomic_is_lock_free</code>的实际实现如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXACT(N)                                                \</span><br><span class="hljs-meta">  do &#123;                                                                \</span><br><span class="hljs-meta">    <span class="hljs-keyword">if</span> (!C2(HAVE_INT,N)) break; <span class="hljs-comment">/*检查是否有长度为N的整数,检查宏HAVE_INTN即可判断*/</span> \</span><br><span class="hljs-meta">    <span class="hljs-keyword">if</span> ((uintptr_t)ptr &amp; (N - 1)) break; <span class="hljs-comment">/*检查是否按照N(2的次幂)字节对齐*/</span> \</span><br><span class="hljs-meta">    <span class="hljs-keyword">if</span> (__atomic_always_lock_free(N, 0)) return true; \</span><br><span class="hljs-meta">    <span class="hljs-keyword">if</span> (!C2(MAYBE_HAVE_ATOMIC_CAS_,N)) break; \</span><br><span class="hljs-meta">    <span class="hljs-keyword">if</span> (C2(FAST_ATOMIC_LDST_,N)) return true; \</span><br><span class="hljs-meta">  &#125; while (0)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LARGER(N)                                                \</span><br><span class="hljs-meta">  do &#123;                                                                \</span><br><span class="hljs-meta">    uintptr_t r = (uintptr_t)ptr &amp; (N - 1);                        \</span><br><span class="hljs-meta">    <span class="hljs-keyword">if</span> (!C2(HAVE_INT,N)) break;                                        \</span><br><span class="hljs-meta">    <span class="hljs-keyword">if</span> (!C2(FAST_ATOMIC_LDST_,N)) break;                        \</span><br><span class="hljs-meta">    <span class="hljs-keyword">if</span> (!C2(MAYBE_HAVE_ATOMIC_CAS_,N)) break;                        \</span><br><span class="hljs-meta">    <span class="hljs-keyword">if</span> (r + n &lt;= N) return true;                                \</span><br><span class="hljs-meta">  &#125; while (0)</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span></span><br><span class="hljs-function"><span class="hljs-title">libat_is_lock_free</span> <span class="hljs-params">(<span class="hljs-type">size_t</span> n, <span class="hljs-type">void</span> *ptr)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">switch</span> (n)<br>    &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:                                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:                <span class="hljs-built_in">EXACT</span>(<span class="hljs-number">1</span>);        <span class="hljs-keyword">goto</span> L4;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:                <span class="hljs-built_in">EXACT</span>(<span class="hljs-number">2</span>);        <span class="hljs-keyword">goto</span> L4;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:                <span class="hljs-built_in">EXACT</span>(<span class="hljs-number">4</span>);        <span class="hljs-keyword">goto</span> L8;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:                <span class="hljs-built_in">EXACT</span>(<span class="hljs-number">8</span>);        <span class="hljs-keyword">goto</span> L16;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">16</span>:                <span class="hljs-built_in">EXACT</span>(<span class="hljs-number">16</span>);        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: L4:                <span class="hljs-built_in">LARGER</span>(<span class="hljs-number">4</span>);        <span class="hljs-comment">/* FALLTHRU */</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">5</span> ... <span class="hljs-number">7</span>: L8:        <span class="hljs-built_in">LARGER</span>(<span class="hljs-number">8</span>);        <span class="hljs-comment">/* FALLTHRU */</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">9</span> ... <span class="hljs-number">15</span>: L16:        <span class="hljs-built_in">LARGER</span>(<span class="hljs-number">16</span>);        <span class="hljs-keyword">break</span>;<br>    &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-built_in">EXPORT_ALIAS</span> (is_lock_free);<br></code></pre></td></tr></table></figure><p>总之就是对很多宏进行判断,可以看出,如果类型是一个长度为<code>N</code>并且按照<code>N</code>字节对齐的数值.</p><p>那么就会进入下面的函数判断.其他宏我将会整理.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ATOMIC_ALWAYS_LOCK_FREE_OR_ALIGNED_LOCK_FREE(size, p)                  \</span><br><span class="hljs-meta">  (__atomic_always_lock_free(size, p) ||                                       \</span><br><span class="hljs-meta">   (__atomic_always_lock_free(size, 0) &amp;&amp; ((uintptr_t)p % size) == 0))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IS_LOCK_FREE_1(p) ATOMIC_ALWAYS_LOCK_FREE_OR_ALIGNED_LOCK_FREE(1, p)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IS_LOCK_FREE_2(p) ATOMIC_ALWAYS_LOCK_FREE_OR_ALIGNED_LOCK_FREE(2, p)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IS_LOCK_FREE_4(p) ATOMIC_ALWAYS_LOCK_FREE_OR_ALIGNED_LOCK_FREE(4, p)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IS_LOCK_FREE_8(p) ATOMIC_ALWAYS_LOCK_FREE_OR_ALIGNED_LOCK_FREE(8, p)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IS_LOCK_FREE_16(p) ATOMIC_ALWAYS_LOCK_FREE_OR_ALIGNED_LOCK_FREE(16, p)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRY_LOCK_FREE_CASE(n, type, ptr)                                       \</span><br><span class="hljs-meta">  case n:                                                                      \</span><br><span class="hljs-meta">    <span class="hljs-keyword">if</span> (IS_LOCK_FREE_##n(ptr)) &#123;                                               \</span><br><span class="hljs-meta">      LOCK_FREE_ACTION(type);                                                  \</span><br><span class="hljs-meta">    &#125;                                                                          \</span><br><span class="hljs-meta">    break;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOCK_FREE_CASES(ptr)                                                   \</span><br><span class="hljs-meta">  do &#123;                                                                         \</span><br><span class="hljs-meta">    switch (size) &#123;                                                            \</span><br><span class="hljs-meta">      TRY_LOCK_FREE_CASE(1, uint8_t, ptr)                                      \</span><br><span class="hljs-meta">      TRY_LOCK_FREE_CASE(2, uint16_t, ptr)                                     \</span><br><span class="hljs-meta">      TRY_LOCK_FREE_CASE(4, uint32_t, ptr)                                     \</span><br><span class="hljs-meta">      TRY_LOCK_FREE_CASE(8, uint64_t, ptr)                                     \</span><br><span class="hljs-meta">      TRY_LOCK_FREE_CASE_16(ptr) <span class="hljs-comment">/* __uint128_t may not be supported */</span>        \</span><br><span class="hljs-meta">    default:                                                                   \</span><br><span class="hljs-meta">      break;                                                                   \</span><br><span class="hljs-meta">    &#125;                                                                          \</span><br><span class="hljs-meta">  &#125; while (0)</span><br><br><span class="hljs-type">bool</span> __atomic_is_lock_free_c(<span class="hljs-type">size_t</span> size, <span class="hljs-type">void</span> *ptr) &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOCK_FREE_ACTION(type) return true;</span><br>  <span class="hljs-built_in">LOCK_FREE_CASES</span>(ptr);<br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> LOCK_FREE_ACTION</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><p>函数开始定义一个宏<code>LOCK_FREE_ACTION(type)</code>,用于返回<code>true</code>.</p><p>可以看出,他把指针和大小一路传到<code>__atomic_always_lock_free</code>,我实在早不到实现,但是在<a href="https://gcc.gnu.org/onlinedocs/gcc/_005f_005fatomic-Builtins.html">这个地方</a>找到了他的说明.</p><blockquote><p>如果大小字节的对象始终为目标架构生成无锁定原子指令，则此内置函数返回true。大小必须解析为编译时常数，结果也可以解析为编译时常数。<br />PTR是可选指向对象的可选指针，可用于确定对齐。值为0表示应使用典型的对齐。编译器也可能忽略此参数。</p></blockquote><p>如果<code>(__atomic_always_lock_free(size, p)</code>返回真,或<code>__atomic_always_lock_free(size, 0)</code>返回真而且指针是<code>size</code>的倍数,那么就是无锁的.</p><p>否则将继续检查接下来的宏,直到返回.</p><h4 id="memory_order"><a class="markdownIt-Anchor" href="#memory_order"></a> memory_order</h4><h4 id="load和store操作"><a class="markdownIt-Anchor" href="#load和store操作"></a> load和store操作</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><code class="hljs cpp">     <span class="hljs-function">_GLIBCXX_ALWAYS_INLINE <span class="hljs-type">void</span></span><br><span class="hljs-function">     <span class="hljs-title">store</span><span class="hljs-params">(__int_type __i, memory_order __m = memory_order_seq_cst)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">     </span>&#123;<br>memory_order __b = __m &amp; __memory_order_mask;<br>__glibcxx_assert(__b != memory_order_acquire);<br>__glibcxx_assert(__b != memory_order_acq_rel);<br>__glibcxx_assert(__b != memory_order_consume);<br><br>__atomic_store_n(&amp;_M_i, __i, <span class="hljs-built_in">int</span>(__m));<br>     &#125;<br><br>     <span class="hljs-function">_GLIBCXX_ALWAYS_INLINE <span class="hljs-type">void</span></span><br><span class="hljs-function">     <span class="hljs-title">store</span><span class="hljs-params">(__int_type __i,</span></span><br><span class="hljs-params"><span class="hljs-function">    memory_order __m = memory_order_seq_cst)</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">     </span>&#123;<br>memory_order __b = __m &amp; __memory_order_mask;<br>__glibcxx_assert(__b != memory_order_acquire);<br>__glibcxx_assert(__b != memory_order_acq_rel);<br>__glibcxx_assert(__b != memory_order_consume);<br><br>__atomic_store_n(&amp;_M_i, __i, <span class="hljs-built_in">int</span>(__m));<br>     &#125;<br><br>     <span class="hljs-function">_GLIBCXX_ALWAYS_INLINE __int_type</span><br><span class="hljs-function">     <span class="hljs-title">load</span><span class="hljs-params">(memory_order __m = memory_order_seq_cst)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">     </span>&#123;<br>memory_order __b = __m &amp; __memory_order_mask;<br>__glibcxx_assert(__b != memory_order_release);<br>__glibcxx_assert(__b != memory_order_acq_rel);<br><br><span class="hljs-keyword">return</span> __atomic_load_n(&amp;_M_i, <span class="hljs-built_in">int</span>(__m));<br>     &#125;<br><br>     <span class="hljs-function">_GLIBCXX_ALWAYS_INLINE __int_type</span><br><span class="hljs-function">     <span class="hljs-title">load</span><span class="hljs-params">(memory_order __m = memory_order_seq_cst)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">     </span>&#123;<br>memory_order __b = __m &amp; __memory_order_mask;<br>__glibcxx_assert(__b != memory_order_release);<br>__glibcxx_assert(__b != memory_order_acq_rel);<br><br><span class="hljs-keyword">return</span> __atomic_load_n(&amp;_M_i, <span class="hljs-built_in">int</span>(__m));<br>     &#125;<br><br>     <span class="hljs-function">_GLIBCXX_ALWAYS_INLINE __int_type</span><br><span class="hljs-function">     <span class="hljs-title">exchange</span><span class="hljs-params">(__int_type __i,</span></span><br><span class="hljs-params"><span class="hljs-function">       memory_order __m = memory_order_seq_cst)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">     </span>&#123;<br><span class="hljs-keyword">return</span> __atomic_exchange_n(&amp;_M_i, __i, <span class="hljs-built_in">int</span>(__m));<br>     &#125;<br><br><br>     <span class="hljs-function">_GLIBCXX_ALWAYS_INLINE __int_type</span><br><span class="hljs-function">     <span class="hljs-title">exchange</span><span class="hljs-params">(__int_type __i,</span></span><br><span class="hljs-params"><span class="hljs-function">       memory_order __m = memory_order_seq_cst)</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">     </span>&#123;<br><span class="hljs-keyword">return</span> __atomic_exchange_n(&amp;_M_i, __i, <span class="hljs-built_in">int</span>(__m));<br>     &#125;<br><br>     <span class="hljs-function">_GLIBCXX_ALWAYS_INLINE <span class="hljs-type">bool</span></span><br><span class="hljs-function">     <span class="hljs-title">compare_exchange_weak</span><span class="hljs-params">(__int_type&amp; __i1, __int_type __i2,</span></span><br><span class="hljs-params"><span class="hljs-function">    memory_order __m1, memory_order __m2)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">     </span>&#123;<br>memory_order __b2 = __m2 &amp; __memory_order_mask;<br>memory_order __b1 = __m1 &amp; __memory_order_mask;<br>__glibcxx_assert(__b2 != memory_order_release);<br>__glibcxx_assert(__b2 != memory_order_acq_rel);<br>__glibcxx_assert(__b2 &lt;= __b1);<br><br><span class="hljs-keyword">return</span> __atomic_compare_exchange_n(&amp;_M_i, &amp;__i1, __i2, <span class="hljs-number">1</span>,<br>   <span class="hljs-built_in">int</span>(__m1), <span class="hljs-built_in">int</span>(__m2));<br>     &#125;<br><br>     <span class="hljs-function">_GLIBCXX_ALWAYS_INLINE <span class="hljs-type">bool</span></span><br><span class="hljs-function">     <span class="hljs-title">compare_exchange_weak</span><span class="hljs-params">(__int_type&amp; __i1, __int_type __i2,</span></span><br><span class="hljs-params"><span class="hljs-function">    memory_order __m1,</span></span><br><span class="hljs-params"><span class="hljs-function">    memory_order __m2)</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">     </span>&#123;<br>memory_order __b2 = __m2 &amp; __memory_order_mask;<br>memory_order __b1 = __m1 &amp; __memory_order_mask;<br>__glibcxx_assert(__b2 != memory_order_release);<br>__glibcxx_assert(__b2 != memory_order_acq_rel);<br>__glibcxx_assert(__b2 &lt;= __b1);<br><br><span class="hljs-keyword">return</span> __atomic_compare_exchange_n(&amp;_M_i, &amp;__i1, __i2, <span class="hljs-number">1</span>,<br>   <span class="hljs-built_in">int</span>(__m1), <span class="hljs-built_in">int</span>(__m2));<br>     &#125;<br><br>     <span class="hljs-function">_GLIBCXX_ALWAYS_INLINE <span class="hljs-type">bool</span></span><br><span class="hljs-function">     <span class="hljs-title">compare_exchange_weak</span><span class="hljs-params">(__int_type&amp; __i1, __int_type __i2,</span></span><br><span class="hljs-params"><span class="hljs-function">    memory_order __m = memory_order_seq_cst)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">     </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">compare_exchange_weak</span>(__i1, __i2, __m,<br>     __cmpexch_failure_order(__m));<br>     &#125;<br><br>     <span class="hljs-function">_GLIBCXX_ALWAYS_INLINE <span class="hljs-type">bool</span></span><br><span class="hljs-function">     <span class="hljs-title">compare_exchange_weak</span><span class="hljs-params">(__int_type&amp; __i1, __int_type __i2,</span></span><br><span class="hljs-params"><span class="hljs-function">   memory_order __m = memory_order_seq_cst)</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">     </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">compare_exchange_weak</span>(__i1, __i2, __m,<br>     __cmpexch_failure_order(__m));<br>     &#125;<br><br>     <span class="hljs-function">_GLIBCXX_ALWAYS_INLINE <span class="hljs-type">bool</span></span><br><span class="hljs-function">     <span class="hljs-title">compare_exchange_strong</span><span class="hljs-params">(__int_type&amp; __i1, __int_type __i2,</span></span><br><span class="hljs-params"><span class="hljs-function">      memory_order __m1, memory_order __m2)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">     </span>&#123;<br>memory_order __b2 = __m2 &amp; __memory_order_mask;<br>memory_order __b1 = __m1 &amp; __memory_order_mask;<br>__glibcxx_assert(__b2 != memory_order_release);<br>__glibcxx_assert(__b2 != memory_order_acq_rel);<br>__glibcxx_assert(__b2 &lt;= __b1);<br><br><span class="hljs-keyword">return</span> __atomic_compare_exchange_n(&amp;_M_i, &amp;__i1, __i2, <span class="hljs-number">0</span>,<br>   <span class="hljs-built_in">int</span>(__m1), <span class="hljs-built_in">int</span>(__m2));<br>     &#125;<br><br>     <span class="hljs-function">_GLIBCXX_ALWAYS_INLINE <span class="hljs-type">bool</span></span><br><span class="hljs-function">     <span class="hljs-title">compare_exchange_strong</span><span class="hljs-params">(__int_type&amp; __i1, __int_type __i2,</span></span><br><span class="hljs-params"><span class="hljs-function">      memory_order __m1,</span></span><br><span class="hljs-params"><span class="hljs-function">      memory_order __m2)</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">     </span>&#123;<br>memory_order __b2 = __m2 &amp; __memory_order_mask;<br>memory_order __b1 = __m1 &amp; __memory_order_mask;<br><br>__glibcxx_assert(__b2 != memory_order_release);<br>__glibcxx_assert(__b2 != memory_order_acq_rel);<br>__glibcxx_assert(__b2 &lt;= __b1);<br><br><span class="hljs-keyword">return</span> __atomic_compare_exchange_n(&amp;_M_i, &amp;__i1, __i2, <span class="hljs-number">0</span>,<br>   <span class="hljs-built_in">int</span>(__m1), <span class="hljs-built_in">int</span>(__m2));<br>     &#125;<br><br>     <span class="hljs-function">_GLIBCXX_ALWAYS_INLINE <span class="hljs-type">bool</span></span><br><span class="hljs-function">     <span class="hljs-title">compare_exchange_strong</span><span class="hljs-params">(__int_type&amp; __i1, __int_type __i2,</span></span><br><span class="hljs-params"><span class="hljs-function">      memory_order __m = memory_order_seq_cst)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">     </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">compare_exchange_strong</span>(__i1, __i2, __m,<br>       __cmpexch_failure_order(__m));<br>     &#125;<br><br>     <span class="hljs-function">_GLIBCXX_ALWAYS_INLINE <span class="hljs-type">bool</span></span><br><span class="hljs-function">     <span class="hljs-title">compare_exchange_strong</span><span class="hljs-params">(__int_type&amp; __i1, __int_type __i2,</span></span><br><span class="hljs-params"><span class="hljs-function"> memory_order __m = memory_order_seq_cst)</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">     </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">compare_exchange_strong</span>(__i1, __i2, __m,<br>       __cmpexch_failure_order(__m));<br>     &#125;<br></code></pre></td></tr></table></figure><h4 id="原子其他操作"><a class="markdownIt-Anchor" href="#原子其他操作"></a> 原子其他操作</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    <span class="hljs-function">_GLIBCXX_ALWAYS_INLINE __int_type</span><br><span class="hljs-function">    <span class="hljs-title">fetch_add</span><span class="hljs-params">(__int_type __i,</span></span><br><span class="hljs-params"><span class="hljs-function">memory_order __m = memory_order_seq_cst)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> __atomic_fetch_add(&amp;_M_i, __i, <span class="hljs-built_in">int</span>(__m)); &#125;<br><br>    <span class="hljs-function">_GLIBCXX_ALWAYS_INLINE __int_type</span><br><span class="hljs-function">    <span class="hljs-title">fetch_add</span><span class="hljs-params">(__int_type __i,</span></span><br><span class="hljs-params"><span class="hljs-function">memory_order __m = memory_order_seq_cst)</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> __atomic_fetch_add(&amp;_M_i, __i, <span class="hljs-built_in">int</span>(__m)); &#125;<br><br>    <span class="hljs-function">_GLIBCXX_ALWAYS_INLINE __int_type</span><br><span class="hljs-function">    <span class="hljs-title">fetch_sub</span><span class="hljs-params">(__int_type __i,</span></span><br><span class="hljs-params"><span class="hljs-function">memory_order __m = memory_order_seq_cst)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> __atomic_fetch_sub(&amp;_M_i, __i, <span class="hljs-built_in">int</span>(__m)); &#125;<br><br>    <span class="hljs-function">_GLIBCXX_ALWAYS_INLINE __int_type</span><br><span class="hljs-function">    <span class="hljs-title">fetch_sub</span><span class="hljs-params">(__int_type __i,</span></span><br><span class="hljs-params"><span class="hljs-function">memory_order __m = memory_order_seq_cst)</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> __atomic_fetch_sub(&amp;_M_i, __i, <span class="hljs-built_in">int</span>(__m)); &#125;<br><br>    <span class="hljs-function">_GLIBCXX_ALWAYS_INLINE __int_type</span><br><span class="hljs-function">    <span class="hljs-title">fetch_and</span><span class="hljs-params">(__int_type __i,</span></span><br><span class="hljs-params"><span class="hljs-function">memory_order __m = memory_order_seq_cst)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> __atomic_fetch_and(&amp;_M_i, __i, <span class="hljs-built_in">int</span>(__m)); &#125;<br><br>    <span class="hljs-function">_GLIBCXX_ALWAYS_INLINE __int_type</span><br><span class="hljs-function">    <span class="hljs-title">fetch_and</span><span class="hljs-params">(__int_type __i,</span></span><br><span class="hljs-params"><span class="hljs-function">memory_order __m = memory_order_seq_cst)</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> __atomic_fetch_and(&amp;_M_i, __i, <span class="hljs-built_in">int</span>(__m)); &#125;<br><br>    <span class="hljs-function">_GLIBCXX_ALWAYS_INLINE __int_type</span><br><span class="hljs-function">    <span class="hljs-title">fetch_or</span><span class="hljs-params">(__int_type __i,</span></span><br><span class="hljs-params"><span class="hljs-function">      memory_order __m = memory_order_seq_cst)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> __atomic_fetch_or(&amp;_M_i, __i, <span class="hljs-built_in">int</span>(__m)); &#125;<br><br>    <span class="hljs-function">_GLIBCXX_ALWAYS_INLINE __int_type</span><br><span class="hljs-function">    <span class="hljs-title">fetch_or</span><span class="hljs-params">(__int_type __i,</span></span><br><span class="hljs-params"><span class="hljs-function">      memory_order __m = memory_order_seq_cst)</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> __atomic_fetch_or(&amp;_M_i, __i, <span class="hljs-built_in">int</span>(__m)); &#125;<br><br>    <span class="hljs-function">_GLIBCXX_ALWAYS_INLINE __int_type</span><br><span class="hljs-function">    <span class="hljs-title">fetch_xor</span><span class="hljs-params">(__int_type __i,</span></span><br><span class="hljs-params"><span class="hljs-function">memory_order __m = memory_order_seq_cst)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> __atomic_fetch_xor(&amp;_M_i, __i, <span class="hljs-built_in">int</span>(__m)); &#125;<br><br>    <span class="hljs-function">_GLIBCXX_ALWAYS_INLINE __int_type</span><br><span class="hljs-function">    <span class="hljs-title">fetch_xor</span><span class="hljs-params">(__int_type __i,</span></span><br><span class="hljs-params"><span class="hljs-function">memory_order __m = memory_order_seq_cst)</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> __atomic_fetch_xor(&amp;_M_i, __i, <span class="hljs-built_in">int</span>(__m)); &#125;<br>  &#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>细说CPP标准和stl源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>细说std源码</tag>
      
      <tag>atomic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++chrono源码分析</title>
    <link href="/6ed806ff/"/>
    <url>/6ed806ff/</url>
    
    <content type="html"><![CDATA[<ul><li>未写完;</li></ul><span id="more"></span><h2 id="头文件"><a class="markdownIt-Anchor" href="#头文件"></a> 头文件</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ratio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;limits&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/parse_numbers.h&gt;</span> <span class="hljs-comment">// for literals support.</span></span><br></code></pre></td></tr></table></figure><p>作用如下:</p><table><thead><tr><th>头文件</th><th>作用</th></tr></thead><tbody><tr><td><code>ratio</code></td><td><code>ratio</code>分数类(分子分母是模板参数)</td></tr><tr><td><code>type_traits</code></td><td>这里面定义了一些类型判断相关的模板类和模板函数</td></tr><tr><td><code>limits</code></td><td>定义了一些数据类型的最大最小值</td></tr><tr><td><code>ctime</code></td><td><code>C</code>语言时间库</td></tr><tr><td><code>bits/parse_numbers.h</code></td><td>用于将字符串转为数值</td></tr></tbody></table><h2 id="超前引用"><a class="markdownIt-Anchor" href="#超前引用"></a> 超前引用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> chrono<br>&#123;<br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Rep, <span class="hljs-keyword">typename</span> _Period = ratio&lt;<span class="hljs-number">1</span>&gt;&gt;<br>    <span class="hljs-keyword">struct</span> duration;<br><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Clock, <span class="hljs-keyword">typename</span> _Dur = <span class="hljs-keyword">typename</span> _Clock::duration&gt;<br>    <span class="hljs-keyword">struct</span> time_point;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里都参数可以细说.</p><h3 id="ratio"><a class="markdownIt-Anchor" href="#ratio"></a> ratio</h3><p><code>ratio</code>定义于<code>ratio</code>文件.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">intmax_t</span> _Num, <span class="hljs-type">intmax_t</span> _Den = <span class="hljs-number">1</span>&gt;<br>  <span class="hljs-keyword">struct</span> ratio<br>  &#123;<br>    <span class="hljs-built_in">static_assert</span>(_Den != <span class="hljs-number">0</span>, <span class="hljs-string">&quot;denominator cannot be zero&quot;</span>);<br>    <span class="hljs-built_in">static_assert</span>(_Num &gt;= -__INTMAX_MAX__ &amp;&amp; _Den &gt;= -__INTMAX_MAX__,<br>    <span class="hljs-string">&quot;out of range&quot;</span>);<br><br>    <span class="hljs-comment">// Note: sign(N) * abs(N) == N</span><br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">intmax_t</span> num =<br>      _Num * __static_sign&lt;_Den&gt;::value / __static_gcd&lt;_Num, _Den&gt;::value;<br><br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">intmax_t</span> den =<br>      __static_abs&lt;_Den&gt;::value / __static_gcd&lt;_Num, _Den&gt;::value;<br><br>    <span class="hljs-keyword">typedef</span> ratio&lt;num, den&gt; type;<br>  &#125;;<br></code></pre></td></tr></table></figure><h4 id="intmax_t"><a class="markdownIt-Anchor" href="#intmax_t"></a> intmax_t</h4><p><code>intmax_t</code>在我的电脑上被定义为<code>long int</code>,这是平台相关的.</p><h4 id="编译期判断"><a class="markdownIt-Anchor" href="#编译期判断"></a> 编译期判断</h4><p>首先判断传入的分母是否为<code>0</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">static_assert</span>(_Den != <span class="hljs-number">0</span>, <span class="hljs-string">&quot;denominator cannot be zero&quot;</span>);<br></code></pre></td></tr></table></figure><p>判断传入的分数是否在范围内</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">static_assert</span>(_Num &gt;= -__INTMAX_MAX__ &amp;&amp; _Den &gt;= -__INTMAX_MAX__,<br><span class="hljs-string">&quot;out of range&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="编译期处理分子分母"><a class="markdownIt-Anchor" href="#编译期处理分子分母"></a> 编译期处理分子分母</h4><p><code>__static_&lt;XXX&gt;</code>这些函数的定义如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">intmax_t</span> _Pn&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__static_sign</span><br>  : integral_constant&lt;<span class="hljs-type">intmax_t</span>, (_Pn &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>&gt;<br>  &#123; &#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">intmax_t</span> _Pn&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__static_abs</span><br>  : integral_constant&lt;<span class="hljs-type">intmax_t</span>, _Pn * __static_sign&lt;_Pn&gt;::value&gt;<br>  &#123; &#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">intmax_t</span> _Pn, <span class="hljs-type">intmax_t</span> _Qn&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__static_gcd</span><br>  : __static_gcd&lt;_Qn, (_Pn % _Qn)&gt;<br>  &#123; &#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">intmax_t</span> _Pn&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__static_gcd</span>&lt;_Pn, <span class="hljs-number">0</span>&gt;<br>  : integral_constant&lt;<span class="hljs-type">intmax_t</span>, __static_abs&lt;_Pn&gt;::value&gt;<br>  &#123; &#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">intmax_t</span> _Qn&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__static_gcd</span>&lt;<span class="hljs-number">0</span>, _Qn&gt;<br>  : integral_constant&lt;<span class="hljs-type">intmax_t</span>, __static_abs&lt;_Qn&gt;::value&gt;<br>  &#123; &#125;;<br></code></pre></td></tr></table></figure><p>我们基本可以把<code>integral_constant</code>视为一个在编译期用以表示数值的常量,并且他带有的信息还能用来确定类型.</p><p>用法就是像上面那样,<code>自定义的类型名称 : integral_constant&lt;数值类型, 数值&gt;</code>.</p><p>可以看出:</p><p><code>__static_sign</code>根据<code>_Pn</code>的值,被定义为<code>1</code>或<code>-1</code>,来表示符号.</p><p><code>__static_abs</code>被定义为<code>_Pn</code>乘以<code>_Pn</code>的符号,通过负负得正获得绝对值.</p><p><code>__static_gcd</code>一路继承下去,最终得到的类是一个<code>integral_constant</code>,并且值是<code>gcd</code>.</p><p>比如,一个<code>__static_gcd&lt;20,30&gt;</code>最终会继承一个<code>integral_constant&lt;intmax_t, 5&gt;</code></p><p>有人会疑问这里辗转相除次数多了,会不会产生一个很冗余的类.</p><p>我这里有一种个人理解:不会.</p><p>对于翻译出来的程序来说,<code>__static_gcd&lt;20,30&gt;</code>和<code>integral_constant&lt;intmax_t, 5&gt;</code>是一样的内容.</p><p>如果<code>A类</code>仅仅继承<code>B类</code>,没有添加其他任何信息,那么这两个类是一样的.没有额外开销.</p><p>诸如<code>std::is_base_of</code>这样的函数,想要判断类之间的继承关系要怎么判断.</p><p>其实编译期直接就把用到继承信息的地方,直接替换成结果,运行期不需要计算,程序本身也不需要得知这些信息.</p><p>所以也不需要记录,就不会有直觉上那种冗余信息.</p><p>如果带有虚函数,需要在运行器确定类型呢?</p><p>那么这个类会有一个虚表,虚表中记录了这些信息,这种情况就另说了.</p><p>注意,虚表这个概念只是<code>C++</code>实现过程中产生的概念,<code>C++</code>应该并未钦定,不要觉得虚表是<code>C++</code>的一个天经地义的组成成分.</p><p>如果要一个符合普遍规律的说法,应该是</p><blockquote><p>内嵌于对象表示中的，位于对象之外的元数据.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">intmax_t</span> num = _Num * __static_sign&lt;_Den&gt;::value / __static_gcd&lt;_Num, _Den&gt;::value;<br></code></pre></td></tr></table></figure><p>那么,根据上面的代码就是<code>num</code>赋值为分子和分母约分之后,带正负的分子.</p><p>这个分数的符号由分子确定.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">intmax_t</span> den = __static_abs&lt;_Den&gt;::value / __static_gcd&lt;_Num, _Den&gt;::value;<br></code></pre></td></tr></table></figure><p><code>den</code>则是分子分母约分之后的分母,并且不带正负.</p><h3 id="_clock"><a class="markdownIt-Anchor" href="#_clock"></a> _Clock</h3><p>内部定义了这几个类,后面会提到.</p><table><thead><tr><th>类</th><th>描述</th></tr></thead><tbody><tr><td><code>system_clock</code></td><td>从系统获取的时钟</td></tr><tr><td><code>steady_clock</code></td><td>不能被修改的时钟</td></tr><tr><td><code>high_resolution_clock</code></td><td>高精度时钟,实际上是<code>system_clock</code>或者<code>steady_clock</code>的别名</td></tr></tbody></table><h2 id="__duration_common_type_wrapper"><a class="markdownIt-Anchor" href="#__duration_common_type_wrapper"></a> __duration_common_type_wrapper</h2><p>待续</p>]]></content>
    
    
    <categories>
      
      <category>细说CPP标准和stl源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>chrono</tag>
      
      <tag>duration</tag>
      
      <tag>ratio</tag>
      
      <tag>time_point</tag>
      
      <tag>细说std源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++的各种宏和属性</title>
    <link href="/3b391a6f/"/>
    <url>/3b391a6f/</url>
    
    <content type="html"><![CDATA[<ul><li>总结中;</li><li>宏;</li><li>progma;</li><li>__cpluscplus;</li><li>__attribute__;</li></ul><span id="more"></span><h2 id="宏"><a class="markdownIt-Anchor" href="#宏"></a> 宏</h2><table><thead><tr><th>宏名称</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td><code>_GLIBCXX17_DEPRECATED</code></td><td></td><td>这个东西即将被删除,不推荐使用</td></tr><tr><td><code>_GLIBCXX_GTHREAD_USE_WEAK</code></td><td>对于<code>MINGW32</code>为<code>0</code>,否则为<code>1</code></td><td>不知道</td></tr><tr><td><code>_GLIBCXX_HAS_GTHREADS</code></td><td>如果可用则为<code>1</code></td><td>表示当前<code>gthread</code>库是否可用</td></tr><tr><td><code>_GLIBCXX_HIDE_EXPORTS</code></td><td></td><td>在<code>gthr.h</code>中,如果没有定义这个宏,就会执行<code>#pragma GCC visibility pop</code></td></tr><tr><td><code>_GLIBCXX_VISIBILITY</code></td><td><code>__attribute__ ((__visibility__ (#V)))</code></td><td>改变可见性</td></tr><tr><td><code>_GLIBCXX_HAVE_ATTRIBUTE_VISIBILITY</code></td><td>如果可以设置可见性,就有定义</td><td>决定<code>_GLIBCXX_VISIBILITY</code>是否起作用</td></tr></tbody></table><h2 id="pragma"><a class="markdownIt-Anchor" href="#pragma"></a> pragma</h2><p>常常见到<code>#pragma xxx yyy</code>的用法,总结如下:</p><h3 id="system_header"><a class="markdownIt-Anchor" href="#system_header"></a> system_header</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> GCC system_header</span><br></code></pre></td></tr></table></figure><p>像对待系统库那样对待这个文件(也就是这个文件可能不符合标准,但是不要警告).</p><h3 id="visibility"><a class="markdownIt-Anchor" href="#visibility"></a> visibility</h3><p>指定目标文件外部链接实体的可见性.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> GCC visibility push (value)</span><br></code></pre></td></tr></table></figure><p><code>value</code>可以为以下值</p><p>default<br />实体在共享库中可见,并且可以被抢占.<br />protected<br />Indicates that the affected external linkage entities have the protected visibility attribute. These entities are exported in shared libraries, but they cannot be preempted.<br />hidden<br />Indicates that the affected external linkage entities have the hidden visibility attribute. These entities are not exported in shared libraries, but their addresses can be referenced indirectly through pointers.<br />internal<br />Indicates that the affected external linkage entities have the internal visibility attribute. These entities are not exported in shared libraries, and their addresses are not available to other modules.</p><p>可以通过以上指令来指定实体的可见性,如果在没有<code>push</code>的情况下使用<code>pop</code>,编译器将会警告.</p><h2 id="__cplusplus"><a class="markdownIt-Anchor" href="#__cplusplus"></a> __cplusplus</h2><p><code>__cpluscplus</code>表示当前的<code>c++</code>标准,主要有这几个值</p><table><thead><tr><th>值</th><th>标准</th></tr></thead><tbody><tr><td><code>199711L</code></td><td><code>c++98</code></td></tr><tr><td><code>201103L</code></td><td><code>c++11</code></td></tr><tr><td><code>201402L</code></td><td><code>c++14</code></td></tr><tr><td><code>201703L</code></td><td><code>c++17</code></td></tr><tr><td><code>202002L</code></td><td><code>c++20</code></td></tr><tr><td><code>202100L</code></td><td><code>c++23(不完整)</code></td></tr></tbody></table><h2 id="__attribute__"><a class="markdownIt-Anchor" href="#__attribute__"></a> __attribute__</h2><p>这个常常这样写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">__attribute__ ((值))<br></code></pre></td></tr></table></figure><p>用来提醒编译器,这个函数或数据有一些特殊属性.我整理的如下:</p><table><thead><tr><th>值</th><th>作用</th></tr></thead><tbody><tr><td><code>packed</code></td><td>取消结构在编译过程中的优化对齐,按照实际占用字节数进行对齐.</td></tr><tr><td><code>aligned(n)</code></td><td>指定内存对齐<code>n</code>字节</td></tr><tr><td><code>noreturn</code></td><td>告诉编译器这个函数没有返回值,以便编译器优化</td></tr><tr><td><code>weak</code></td><td>弱符号</td></tr><tr><td><code>__visibility__ (V))</code></td><td>可见性,<code>V</code>参考上文</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>细说CPP标准和stl源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>细说std源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++thread源码分析</title>
    <link href="/770726c0/"/>
    <url>/770726c0/</url>
    
    <content type="html"><![CDATA[<ul><li>thread的内部类;</li><li>thread的构造函数;</li><li>执行流程;</li><li>一些对外函数的实现;</li></ul><span id="more"></span><h2 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h2><p>如果写一段这样的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br><br>    <span class="hljs-built_in">node</span>() &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p, cons\n&quot;</span>, <span class="hljs-keyword">this</span>); &#125;<br>    <span class="hljs-built_in">node</span>(node &amp;n) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p, copy from %p\n&quot;</span>, <span class="hljs-keyword">this</span>, &amp;n); &#125;<br>    <span class="hljs-built_in">node</span>(node &amp;&amp;n) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p, move from %p\n&quot;</span>, <span class="hljs-keyword">this</span>, &amp;n); &#125;<br>    ~<span class="hljs-built_in">node</span>() &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p,dest\n&quot;</span>, <span class="hljs-keyword">this</span>); &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> node nd)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">5</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, &amp;nd);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1\n&quot;</span>);<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(fun, node())</span></span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2\n&quot;</span>);<br>    t.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;3\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译命令为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">g++ a.cpp -lpthread<br></code></pre></td></tr></table></figure><p>输出结果将会类似这样:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1</span><br><span class="hljs-number">0x7fff2e724a3f</span>, cons<br><span class="hljs-number">0x7fff2e7249f8</span>, move from <span class="hljs-number">0x7fff2e724a3f</span><br><span class="hljs-number">0x5589443292c8</span>, move from <span class="hljs-number">0x7fff2e7249f8</span><br><span class="hljs-number">0x7fff2e7249f8</span>,dest<br><span class="hljs-number">0x7fff2e724a3f</span>,dest<br><span class="hljs-number">2</span><br><span class="hljs-number">0x7fd6a8499df7</span>, move from <span class="hljs-number">0x5589443292c8</span><br><span class="hljs-number">0x7fd6a8499df7</span><br><span class="hljs-number">0x7fd6a8499df7</span>,dest<br><span class="hljs-number">0x5589443292c8</span>,dest<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>可以看出,一开始构造了一个对象位于栈内存<code>0x7fff2e724a3f</code>.</p><p>后来他被移动构造到栈内存<code>0x7fff2e7249f8</code>,</p><p>再后来他被移动到堆内存<code>0x5589443292c8</code>,</p><p>然后按照先构造后析构的顺序,析构了<code>0x7fff2e7249f8</code>, <code>0x7fff2e724a3f</code>.</p><p>线程执行之后,他被移动到栈内存<code>0x7fd6a8499df7</code>,等待五秒并打印了这个地址.</p><p>函数执行结束,析构了<code>0x7fd6a8499df7</code>.</p><p>在线程结束时,析构了<code>0x5589443292c8</code>.</p><p>看完下面文章,你会清楚这些构造,移动和析构,都在什么函数,什么时机中执行.</p><h2 id="文件开头定义"><a class="markdownIt-Anchor" href="#文件开头定义"></a> 文件开头定义</h2><h3 id="宏"><a class="markdownIt-Anchor" href="#宏"></a> 宏</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _GLIBCXX_THREAD</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GLIBCXX_THREAD 1</span><br></code></pre></td></tr></table></figure><p>定义<code>_GLIBCXX_THREAD</code>宏.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> GCC system_header</span><br></code></pre></td></tr></table></figure><p>从<code>#pragma GCC system_header</code>直到文件结束之间的代码会被编译器视为系统头文件之中的代码。系统头文件中的代码往往不能完全遵循C标准, 所以头文件之中的警告信息往往不显示。(除非用<code>#warning</code>显式指明)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">if</span> __cplusplus &lt; 201103L</span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/c++0x_warning.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br></code></pre></td></tr></table></figure><p><code>__cpluscplus</code>表示当前的<code>c++</code>标准,主要有这几个值</p><table><thead><tr><th>值</th><th>标准</th></tr></thead><tbody><tr><td><code>199711L</code></td><td><code>c++98</code></td></tr><tr><td><code>201103L</code></td><td><code>c++11</code></td></tr><tr><td><code>201402L</code></td><td><code>c++14</code></td></tr><tr><td><code>201703L</code></td><td><code>c++17</code></td></tr><tr><td><code>202002L</code></td><td><code>c++20</code></td></tr><tr><td><code>202100L</code></td><td><code>c++23(不完整)</code></td></tr></tbody></table><p>显然他们是单调递增的,<code>c++11</code>之前的<code>__cpluscplus</code>都会小于<code>201103L</code>.</p><p>这里表示如果当前标准小于<code>c++11</code>,那么不引入下面的代码,而是直接引入<code>&lt;bits/c++0x_warning.h&gt;</code>.</p><h3 id="头文件"><a class="markdownIt-Anchor" href="#头文件"></a> 头文件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tuple&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cerrno&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/functexcept.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/functional_hash.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/invoke.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/gthr.h&gt;</span></span><br></code></pre></td></tr></table></figure><p>作用如下:</p><table><thead><tr><th>头文件</th><th>作用</th></tr></thead><tbody><tr><td><code>chrono</code></td><td>时间日期相关</td></tr><tr><td><code>memory</code></td><td>内存分配,回收和管理</td></tr><tr><td><code>tuple</code></td><td>元组</td></tr><tr><td><code>cerrno</code></td><td>里面包含了<code>error.h</code>,定义了<code>errno</code>的整数值</td></tr><tr><td><code>bits/functexcept.h</code></td><td>定义了一些内部函数,与抛出异常有关</td></tr><tr><td><code>bits/functional_hash.h</code></td><td>定义了一些哈希相关的类,<code>hash</code>函数最终调用了<code>bits/hash_bytes.h</code>的<code>_Hash_bytes</code></td></tr><tr><td><code>bits/invoke.h</code></td><td>实现了<code>__invoke</code>类,用来调用某个可调用对象</td></tr><tr><td><code>bits/gthr.h</code></td><td>引入了<code>bits/gthr-default.h</code>,这个宏里面定义了<code>thread</code>所需的<code>posix</code>类型</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(_GLIBCXX_HAS_GTHREADS)</span><br></code></pre></td></tr></table></figure><p>在<code>bits/c++config.h</code>中定义如果<code>gthread</code>库可用,值为<code>1</code>.</p><h3 id="可见性"><a class="markdownIt-Anchor" href="#可见性"></a> 可见性</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> std _GLIBCXX_VISIBILITY(<span class="hljs-keyword">default</span>)<br>&#123;<br>_GLIBCXX_BEGIN_NAMESPACE_VERSION<br></code></pre></td></tr></table></figure><p>命名空间的可见性为默认,实体在共享库中可见,并且可以被抢占.</p><p>这个<code>_GLIBCXX_VISIBILITY</code>定义如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _GLIBCXX_PSEUDO_VISIBILITY</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> _GLIBCXX_PSEUDO_VISIBILITY(V)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> _GLIBCXX_HAVE_ATTRIBUTE_VISIBILITY</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> _GLIBCXX_VISIBILITY(V) __attribute__ ((__visibility__ (#V)))</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-comment">// If this is not supplied by the OS-specific or CPU-specific</span><br><span class="hljs-comment">// headers included below, it will be defined to an empty default.</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> _GLIBCXX_VISIBILITY(V) _GLIBCXX_PSEUDO_VISIBILITY(V)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>如果<code>_GLIBCXX_HAVE_ATTRIBUTE_VISIBILITY</code>,那么设置可见性,不然他就是空的.</p><p>如果宏<code>_GLIBCXX_INLINE_VERSION</code>为真,这个<code>_GLIBCXX_BEGIN_NAMESPACE_VERSION</code>将会套上一个版本号为名的命名空间,否则啥也不干.</p><h2 id="内部类"><a class="markdownIt-Anchor" href="#内部类"></a> 内部类</h2><h3 id="_state"><a class="markdownIt-Anchor" href="#_state"></a> _State</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/// thread</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">thread</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// Abstract base class for types that wrap arbitrary functors to be</span><br>  <span class="hljs-comment">// invoked in the new thread of execution.</span><br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_State</span><br>  &#123;<br>    <span class="hljs-keyword">virtual</span> ~_State();<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> _M_run() = <span class="hljs-number">0</span>;<br>  &#125;;<br>  <span class="hljs-keyword">using</span> _State_ptr = unique_ptr&lt;_State&gt;;<br></code></pre></td></tr></table></figure><p>一个抽象基类<code>_State</code>用于封装可执行对象,然后定义一个类型<code>_State_ptr</code>,这是一个用来指向<code>_State</code>的智能指针.</p><h3 id="线程id"><a class="markdownIt-Anchor" href="#线程id"></a> 线程id</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">__gthread_t</span>native_handle_type;<br></code></pre></td></tr></table></figure><p><code>__gthread_t</code>在<code>gthr.h</code>中被定义为<code>pthread_t</code>,这是<code>linux</code>的线程id的数据类型,同一进程内唯一.</p><p>这个<code>pthread_t</code>和<code>pid_t</code>有区别.</p><p><code>pid_t</code>是标志进程的另一套机制.</p><p>众所周知,<code>linux</code>的线程是一个特殊的进程,<code>pid_t</code>是这个进程的实际的id.</p><p>为了将这些线程伪装成同一个进程,当我们使用<code>getpid()</code>时,这些线程会返回主线程的进程id.</p><p>使用<code>gettid()</code>可以获取他们真正的进程id.</p><p>这个<code>pid_t</code>是全局唯一的.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp">   <span class="hljs-keyword">class</span> <span class="hljs-title class_">id</span><br>   &#123;<br>     native_handle_type_M_thread;<br><br>   <span class="hljs-keyword">public</span>:<br>     <span class="hljs-built_in">id</span>() <span class="hljs-keyword">noexcept</span> : _M_thread() &#123; &#125;<br><br>     <span class="hljs-function"><span class="hljs-keyword">explicit</span></span><br><span class="hljs-function">     <span class="hljs-title">id</span><span class="hljs-params">(native_handle_type __id)</span> : _M_thread(__id) &#123;</span> &#125;<br><br>   <span class="hljs-keyword">private</span>:<br>     <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">thread</span>;<br>     <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">hash</span>&lt;thread::id&gt;;<br><br>     <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span><br>     <span class="hljs-keyword">operator</span>==(thread::id __x, thread::id __y) <span class="hljs-keyword">noexcept</span>;<br><br>     <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span><br>     <span class="hljs-keyword">operator</span>&lt;(thread::id __x, thread::id __y) <span class="hljs-keyword">noexcept</span>;<br><br>     <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_CharT</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">_Traits</span>&gt;<br><span class="hljs-keyword">friend</span> basic_ostream&lt;_CharT, _Traits&gt;&amp;<br><span class="hljs-keyword">operator</span>&lt;&lt;(basic_ostream&lt;_CharT, _Traits&gt;&amp; __out, thread::id __id);<br>   &#125;;<br><br> <span class="hljs-keyword">private</span>:<br>   id_M_id;<br></code></pre></td></tr></table></figure><p>这个内部类有一个<code>pthread_t</code>成员,他定义了一些友元函数,以便外部函数使用和比较他的<code>pthread_id</code>.</p><p>并且重载了<code>operator&lt;&lt;</code>以便打印线程id.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// _GLIBCXX_RESOLVE_LIB_DEFECTS</span><br><span class="hljs-comment">// 2097.  packaged_task constructors should be constrained</span><br><span class="hljs-comment">// 3039. Unnecessary decay in thread and packaged_task</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>  <span class="hljs-keyword">using</span> __not_same = __not_&lt;is_same&lt;<span class="hljs-type">__remove_cvref_t</span>&lt;_Tp&gt;, thread&gt;&gt;;<br></code></pre></td></tr></table></figure><p><code>__remove_cvref_t</code>可以移除<code>_Tp</code>类型的<code>const</code>,<code>volatitle</code>和引用属性.</p><p>然后对比去除这些属性的<code>_Tp</code>类型和<code>thread</code>类型,判断是否相同.</p><p>如果相同,那么<code>__not_same</code>类型的<code>value</code>成员会是<code>false</code>,否则为<code>true</code>.</p><h2 id="生命周期相关"><a class="markdownIt-Anchor" href="#生命周期相关"></a> 生命周期相关</h2><h3 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数"></a> 构造函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">thread</span>() <span class="hljs-keyword">noexcept</span> = <span class="hljs-keyword">default</span>;<br><br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Callable, <span class="hljs-keyword">typename</span>... _Args,<br>     <span class="hljs-keyword">typename</span> = _Require&lt;__not_same&lt;_Callable&gt;&gt;&gt;<br>      <span class="hljs-keyword">explicit</span><br>      <span class="hljs-built_in">thread</span>(_Callable&amp;&amp; __f, _Args&amp;&amp;... __args)<br>      &#123;<br><span class="hljs-built_in">static_assert</span>( __is_invocable&lt;<span class="hljs-keyword">typename</span> decay&lt;_Callable&gt;::type,<br>      <span class="hljs-keyword">typename</span> decay&lt;_Args&gt;::type...&gt;::value,<br>  <span class="hljs-string">&quot;std::thread arguments must be invocable after conversion to rvalues&quot;</span><br>  );<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> GTHR_ACTIVE_PROXY</span><br><span class="hljs-comment">// Create a reference to pthread_create, not just the gthr weak symbol.</span><br><span class="hljs-keyword">auto</span> __depend = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-built_in">void</span>(*)()&gt;(&amp;pthread_create);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-keyword">auto</span> __depend = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        _M_start_thread(_S_make_state(<br>      __make_invoker(std::forward&lt;_Callable&gt;(__f),<br>     std::forward&lt;_Args&gt;(__args)...)),<br>    __depend);<br>      &#125;<br></code></pre></td></tr></table></figure><p><code>_Require</code>的实现如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">bool</span>, <span class="hljs-keyword">typename</span> _Tp = <span class="hljs-type">void</span>&gt;<br>  <span class="hljs-keyword">struct</span> enable_if<br>  &#123; &#125;;<br><br><span class="hljs-comment">// Partial specialization for true.</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">enable_if</span>&lt;<span class="hljs-literal">true</span>, _Tp&gt;<br>  &#123; <span class="hljs-keyword">typedef</span> _Tp type; &#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... _Cond&gt;<br>  <span class="hljs-keyword">using</span> _Require = <span class="hljs-keyword">typename</span> enable_if&lt;__and_&lt;_Cond...&gt;::value&gt;::type;<br></code></pre></td></tr></table></figure><p><code>_Require</code>的作用:</p><p>如果可变模板参数<code>_Cond</code>进行<code>and</code>运算之后的<code>::value</code>为真(也就是这里的<code>_Callable</code>的类型和<code>thread</code>不同),那么<code>_Require</code>类型为合法类型(是一个<code>void</code>).</p><p>否则他会是一个错误的类型,编译将会报错.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">static_assert</span>( __is_invocable&lt;<span class="hljs-keyword">typename</span> decay&lt;_Callable&gt;::type,<br>      <span class="hljs-keyword">typename</span> decay&lt;_Args&gt;::type...&gt;::value,<br>  <span class="hljs-string">&quot;std::thread arguments must be invocable after conversion to rvalues&quot;</span><br>  );<br></code></pre></td></tr></table></figure><p>判断<code>_Callable</code>是否可以执行,根据判断结果,<code>__is_invocable</code>最终会继承<code>true_type</code>或<code>false_type</code>.</p><p>对这个<code>__is_invocable</code>取<code>value</code>,可以得知是否可以调用.</p><p>如果不能调用就会报错<code>std::thread arguments must be invocable after conversion to rvalues</code>.</p><h4 id="__make_invoker"><a class="markdownIt-Anchor" href="#__make_invoker"></a> __make_invoker</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> GTHR_ACTIVE_PROXY</span><br><span class="hljs-comment">// Create a reference to pthread_create, not just the gthr weak symbol.</span><br><span class="hljs-keyword">auto</span> __depend = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-built_in">void</span>(*)()&gt;(&amp;pthread_create);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-keyword">auto</span> __depend = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        _M_start_thread(_S_make_state(<br>      __make_invoker(std::forward&lt;_Callable&gt;(__f),<br>     std::forward&lt;_Args&gt;(__args)...)),<br>    __depend);<br>      &#125;<br></code></pre></td></tr></table></figure><p><code>__make_invoker</code>会返回一个<code>_Invoker</code>对象,函数的实现如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">   <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... _Tp&gt;<br>     <span class="hljs-keyword">using</span> __decayed_tuple = tuple&lt;<span class="hljs-keyword">typename</span> decay&lt;_Tp&gt;::type...&gt;;<br><br>   <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Callable, <span class="hljs-keyword">typename</span>... _Args&gt;<br>     <span class="hljs-type">static</span> _Invoker&lt;__decayed_tuple&lt;_Callable, _Args...&gt;&gt;<br>     __make_invoker(_Callable&amp;&amp; __callable, _Args&amp;&amp;... __args)<br>     &#123;<br><span class="hljs-keyword">return</span> &#123; __decayed_tuple&lt;_Callable, _Args...&gt;&#123;<br>    std::forward&lt;_Callable&gt;(__callable), std::forward&lt;_Args&gt;(__args)...<br>&#125; &#125;;<br>     &#125;<br> &#125;;<br></code></pre></td></tr></table></figure><p><code>__decayed_tuple&lt;typename... _Tp&gt;&#123;__args...&#125;</code>可以将大括号内的元素包装成一个元组,元祖内每个元素的类型由尖括号内的模板参数决定.</p><p><code>return</code>会把这个元祖转换为一个<code>_Invoker</code>,这是一个仿函数.后面会提到.</p><p>这里是<strong>第一次</strong>移动,这个<code>_Invoker</code>位于栈上,构造<code>_Invoker</code>的时候参数被移动到<code>_Invoker</code>的成员<code>_M_t</code>.</p><h4 id="_s_make_state"><a class="markdownIt-Anchor" href="#_s_make_state"></a> _S_make_state</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">   <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Callable&gt;<br>     <span class="hljs-type">static</span> _State_ptr<br>     _S_make_state(_Callable&amp;&amp; __f)<br>     &#123;<br><span class="hljs-keyword">using</span> _Impl = _State_impl&lt;_Callable&gt;;<br><span class="hljs-keyword">return</span> _State_ptr&#123;<span class="hljs-keyword">new</span> _Impl&#123;std::forward&lt;_Callable&gt;(__f)&#125;&#125;;<br>     &#125;<br></code></pre></td></tr></table></figure><p>这个函数接收一个可执行对象<code>__f</code>把它包装成一个<code>_State_impl</code>对象,并返回指向这个对象的智能指针.</p><p>这个<code>_State_impl</code>后面会提到.</p><p>这个<code>_State_ptr</code>是前面定义的指向内部类<code>_State</code>的智能指针.</p><p>这里是<strong>第二次</strong>移动,这里把可执行对象<code>_Invoker</code>移动到堆内存,并且用<code>_State_ptr</code>指向他.</p><p>这个<code>_State_ptr</code>指向的内存将会在线程结束的时候析构,析构时才会释放堆上的这块空间.</p><h4 id="_m_start_thread"><a class="markdownIt-Anchor" href="#_m_start_thread"></a> _M_start_thread</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span><br>thread::_M_start_thread(_State_ptr state, <span class="hljs-built_in">void</span> (*)())<br>&#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> err = __gthread_create(&amp;_M_id._M_thread,<br>                                   &amp;execute_native_thread_routine,<br>                                   state.<span class="hljs-built_in">get</span>());<br>  <span class="hljs-keyword">if</span> (err)<br>    __throw_system_error(err);<br>  state.<span class="hljs-built_in">release</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>同<code>state</code>指针指向的内容创建一个线程,然后释放<code>state</code>.</p><p>创建之后这个线程的线程id会保存在内部对象<code>_M_id</code>的<code>_M_thread</code>成员中.</p><p>这里<code>state</code>只是<code>release</code>而没有释放内存.</p><h4 id="execute_native_thread_routine"><a class="markdownIt-Anchor" href="#execute_native_thread_routine"></a> execute_native_thread_routine</h4><p><code>execute_native_thread_routine</code>是执行的关键,他被系统调用,并传入上文中<code>state.get()</code>获得的指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>*</span><br><span class="hljs-function"><span class="hljs-title">execute_native_thread_routine</span><span class="hljs-params">(<span class="hljs-type">void</span>* __p)</span></span><br><span class="hljs-function"></span>&#123;<br>  thread::_State_ptr <span class="hljs-type">__t</span>&#123; <span class="hljs-built_in">static_cast</span>&lt;thread::_State*&gt;(__p) &#125;;<br>  <span class="hljs-type">__t</span>-&gt;_M_run();<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>一顿转换之后获得了指向可执行对象的智能指针<code>__t</code>.</p><p><code>__t-&gt;_M_tun()</code>将会执行<code>_Invoker</code>的<code>operator()()</code>.</p><p><strong>第三次</strong>移动发生在这里.</p><p>把堆上的内容移动到栈上,传给<code>std::__invoke</code>,从而执行.</p><h3 id="析构函数"><a class="markdownIt-Anchor" href="#析构函数"></a> 析构函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">   ~<span class="hljs-built_in">thread</span>()<br>   &#123;<br>     <span class="hljs-keyword">if</span> (<span class="hljs-built_in">joinable</span>())<br>std::<span class="hljs-built_in">terminate</span>();<br>   &#125;<br></code></pre></td></tr></table></figure><p><code>joinable()</code>会新建一个<code>id</code>,和当前的<code>_M_id</code>对比,如果相同,那么说明这个线程没有传入一个可执行对象,或者已经被<code>join</code>了.</p><p>否则执行<code>std::terminate</code>结束进程.详情见<a href="https://zh.cppreference.com/w/cpp/error/terminate">这里</a>.</p><h3 id="拷贝构造函数和移动构造函数"><a class="markdownIt-Anchor" href="#拷贝构造函数和移动构造函数"></a> 拷贝构造函数和移动构造函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">thread</span>(<span class="hljs-type">const</span> thread&amp;) = <span class="hljs-keyword">delete</span>;<br><br><span class="hljs-built_in">thread</span>(thread&amp;&amp; <span class="hljs-type">__t</span>) <span class="hljs-keyword">noexcept</span><br>&#123; <span class="hljs-built_in">swap</span>(<span class="hljs-type">__t</span>); &#125;<br></code></pre></td></tr></table></figure><h3 id="拷贝赋值函数和移动赋值函数"><a class="markdownIt-Anchor" href="#拷贝赋值函数和移动赋值函数"></a> 拷贝赋值函数和移动赋值函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">   thread&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> thread&amp;) = <span class="hljs-keyword">delete</span>;<br><br>   thread&amp; <span class="hljs-keyword">operator</span>=(thread&amp;&amp; <span class="hljs-type">__t</span>) <span class="hljs-keyword">noexcept</span><br>   &#123;<br>     <span class="hljs-keyword">if</span> (<span class="hljs-built_in">joinable</span>())<br>std::<span class="hljs-built_in">terminate</span>();<br>     <span class="hljs-built_in">swap</span>(<span class="hljs-type">__t</span>);<br>     <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function">   <span class="hljs-title">swap</span><span class="hljs-params">(thread&amp; <span class="hljs-type">__t</span>)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">   </span>&#123; std::<span class="hljs-built_in">swap</span>(_M_id, <span class="hljs-type">__t</span>._M_id); &#125;<br></code></pre></td></tr></table></figure><p>移动赋值之前需要先判断是否<code>terminate</code>,移动<code>__t</code>的内容到当前对象.</p><h2 id="基本操作"><a class="markdownIt-Anchor" href="#基本操作"></a> 基本操作</h2><h3 id="joinable"><a class="markdownIt-Anchor" href="#joinable"></a> joinable</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span></span><br><span class="hljs-function"><span class="hljs-title">joinable</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-keyword">return</span> !(_M_id == <span class="hljs-built_in">id</span>()); &#125;<br></code></pre></td></tr></table></figure><p>新建一个<code>id</code>,和当前的<code>_M_id</code>对比,如果相同,那么说明这个线程没有传入一个可执行对象,或者已经被<code>join</code>了.</p><h3 id="join"><a class="markdownIt-Anchor" href="#join"></a> join</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">join</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>实现在<code>thread.cc</code>文件中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">thread::join</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> __e = EINVAL;<br>  <span class="hljs-keyword">if</span> (_M_id != <span class="hljs-built_in">id</span>())<br>    __e = __gthread_join(_M_id._M_thread, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (__e)<br>    __throw_system_error(__e);<br>  _M_id = <span class="hljs-built_in">id</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>如果当前是<code>joinable</code>的,就调用<code>__gthread_join</code>.</p><p>然后<code>_M_id</code>恢复为<code>id()</code>.</p><p><code>__gthread_join</code>定义如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">define</span> __gthrw_(name) __gthrw_ ## name</span><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span><br>__gthread_join (<span class="hljs-type">__gthread_t</span> __threadid, <span class="hljs-type">void</span> **__value_ptr)<br>&#123;<br>  <span class="hljs-keyword">return</span> __gthrw_(pthread_join) (__threadid, __value_ptr);<br>&#125;<br></code></pre></td></tr></table></figure><p>调用<code>__gthrw_pthread_join</code>,传入<code>_M_id._M_thread</code>和一个<code>0</code>.</p><p>我目前没有找到他的实现,猜测应该是<code>pthread_join</code>封装,以后找到了再补充.</p><h3 id="detach"><a class="markdownIt-Anchor" href="#detach"></a> detach</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">detach</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>他的实现如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">thread::detach</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> __e = EINVAL;<br>  <span class="hljs-keyword">if</span> (_M_id != <span class="hljs-built_in">id</span>())<br>    __e = __gthread_detach(_M_id._M_thread);<br>  <span class="hljs-keyword">if</span> (__e)<br>    __throw_system_error(__e);<br>  _M_id = <span class="hljs-built_in">id</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>也是和<code>join</code>只能找到这里</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">__gthread_detach (<span class="hljs-type">__gthread_t</span> __threadid)<br>&#123;<br>  <span class="hljs-keyword">return</span> __gthrw_(pthread_detach) (__threadid);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获取id"><a class="markdownIt-Anchor" href="#获取id"></a> 获取id</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">thread::id</span><br><span class="hljs-function"><span class="hljs-title">get_id</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-keyword">return</span> _M_id; &#125;<br><br><span class="hljs-comment">/** @pre thread is joinable</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">native_handle_type</span><br><span class="hljs-function"><span class="hljs-title">native_handle</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-keyword">return</span> _M_id._M_thread; &#125;<br></code></pre></td></tr></table></figure><h3 id="返回实现支持的并发线程数量"><a class="markdownIt-Anchor" href="#返回实现支持的并发线程数量"></a> 返回实现支持的并发线程数量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Returns a value that hints at the number of hardware thread contexts.</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span></span><br><span class="hljs-function"><span class="hljs-title">hardware_concurrency</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span>;<br></code></pre></td></tr></table></figure><p>实现如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span></span><br><span class="hljs-function"><span class="hljs-title">thread::hardware_concurrency</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> __n = _GLIBCXX_NPROCS;<br>  <span class="hljs-keyword">if</span> (__n &lt; <span class="hljs-number">0</span>)<br>    __n = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> __n;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="内部类-ii"><a class="markdownIt-Anchor" href="#内部类-ii"></a> 内部类 II</h2><h3 id="_state_impl"><a class="markdownIt-Anchor" href="#_state_impl"></a> _State_impl</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-keyword">private</span>:<br>   <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Callable&gt;<br>     <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_State_impl</span> : <span class="hljs-keyword">public</span> _State<br>     &#123;<br>_Callable_M_func;<br><br>_State_impl(_Callable&amp;&amp; __f) : _M_func(std::forward&lt;_Callable&gt;(__f))<br>&#123; &#125;<br><br><span class="hljs-type">void</span><br>_M_run() &#123; _M_func(); &#125;<br>     &#125;;<br></code></pre></td></tr></table></figure><p>这个类继承了<code>_State</code>并且有一个可执行对象作为成员.</p><p>将<code>_M_run()</code>实现为执行这个可执行对象.</p><p>在构造的位置,他把接收到的接收到的<code>_Invoker</code>,当作<code>_M_func</code>.</p><h2 id="一些内部函数"><a class="markdownIt-Anchor" href="#一些内部函数"></a> 一些内部函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">   <span class="hljs-type">void</span><br>   _M_start_thread(_State_ptr, <span class="hljs-built_in">void</span> (*)());<br><br>   <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Callable&gt;<br>     <span class="hljs-type">static</span> _State_ptr<br>     _S_make_state(_Callable&amp;&amp; __f)<br>     &#123;<br><span class="hljs-keyword">using</span> _Impl = _State_impl&lt;_Callable&gt;;<br><span class="hljs-keyword">return</span> _State_ptr&#123;<span class="hljs-keyword">new</span> _Impl&#123;std::forward&lt;_Callable&gt;(__f)&#125;&#125;;<br>     &#125;<br></code></pre></td></tr></table></figure><p>前面构造函数已经讲过.</p><h2 id="内部类-iii"><a class="markdownIt-Anchor" href="#内部类-iii"></a> 内部类 III</h2><h3 id="_impl_base"><a class="markdownIt-Anchor" href="#_impl_base"></a> _Impl_base</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">if</span> _GLIBCXX_THREAD_ABI_COMPAT</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_Impl_base</span>;<br>    <span class="hljs-keyword">typedef</span> shared_ptr&lt;_Impl_base&gt;__shared_base_type;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_Impl_base</span><br>    &#123;<br>      __shared_base_type_M_this_ptr;<br>      <span class="hljs-keyword">virtual</span> ~_Impl_base() = <span class="hljs-keyword">default</span>;<br>      <span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> _M_run() = <span class="hljs-number">0</span>;<br>    &#125;;<br></code></pre></td></tr></table></figure><p>这个<code>_Impl_base</code>持有一个指向<code>_Impl_base</code>的智能指针.目前意义不明,后面将会提到.</p><h4 id=""><a class="markdownIt-Anchor" href="#"></a> </h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">void</span><br>    _M_start_thread(__shared_base_type, <span class="hljs-built_in">void</span> (*)());<br><br>    <span class="hljs-type">void</span><br>    _M_start_thread(__shared_base_type);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>实现如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">if</span> _GLIBCXX_THREAD_ABI_COMPAT</span><br>  <span class="hljs-type">void</span><br>  thread::_M_start_thread(__shared_base_type __b)<br>  &#123;<br>    <span class="hljs-keyword">if</span> (!__gthread_active_p())<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> __cpp_exceptions</span><br>      <span class="hljs-keyword">throw</span> <span class="hljs-built_in">system_error</span>(<span class="hljs-built_in">make_error_code</span>(errc::operation_not_permitted),<br>                         <span class="hljs-string">&quot;Enable multithreading to use std::thread&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      __throw_system_error(<span class="hljs-built_in">int</span>(errc::operation_not_permitted));<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    _M_start_thread(std::<span class="hljs-built_in">move</span>(__b), <span class="hljs-literal">nullptr</span>);<br>  &#125;<br>  <span class="hljs-type">void</span><br>  thread::_M_start_thread(__shared_base_type __b, <span class="hljs-built_in">void</span> (*)())<br>  &#123;<br>    <span class="hljs-keyword">auto</span> ptr = __b.<span class="hljs-built_in">get</span>();<br>    <span class="hljs-comment">// Create a reference cycle that will be broken in the new thread.</span><br>    ptr-&gt;_M_this_ptr = std::<span class="hljs-built_in">move</span>(__b);<br>    <span class="hljs-type">int</span> __e = __gthread_create(&amp;_M_id._M_thread,<br>                               &amp;execute_native_thread_routine_compat, ptr);<br>    <span class="hljs-keyword">if</span> (__e)<br>    &#123;<br>      ptr-&gt;_M_this_ptr.<span class="hljs-built_in">reset</span>();  <span class="hljs-comment">// break reference cycle, destroying *ptr.</span><br>      __throw_system_error(__e);<br>    &#125;<br>  &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>他和前面提到的<code>thread::_M_start_thread(_State_ptr state, void (*)())</code>不同.</p><p>目前没看出来哪里会用到这个内部类,日后补充.</p><h3 id="_invoker"><a class="markdownIt-Anchor" href="#_invoker"></a> _Invoker</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-keyword">private</span>:<br>   <span class="hljs-comment">// A call wrapper that does INVOKE(forwarded tuple elements...)</span><br>   <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tuple&gt;<br>     <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_Invoker</span><br>     &#123;<br>_Tuple _M_t;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__result</span>;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Fn, <span class="hljs-keyword">typename</span>... _Args&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__result</span>&lt;tuple&lt;_Fn, _Args...&gt;&gt;<br>  : __invoke_result&lt;_Fn, _Args...&gt;<br>  &#123; &#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">size_t</span>... _Ind&gt;<br>  <span class="hljs-keyword">typename</span> __result&lt;_Tuple&gt;::type<br>  _M_invoke(_Index_tuple&lt;_Ind...&gt;)<br>  &#123; <span class="hljs-keyword">return</span> std::__invoke(std::<span class="hljs-built_in">get</span>&lt;_Ind&gt;(std::<span class="hljs-built_in">move</span>(_M_t))...); &#125;<br><br><span class="hljs-keyword">typename</span> __result&lt;_Tuple&gt;::<span class="hljs-function">type</span><br><span class="hljs-function"><span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">using</span> _Indices<br>    = <span class="hljs-keyword">typename</span> _Build_index_tuple&lt;tuple_size&lt;_Tuple&gt;::value&gt;::__type;<br>  <span class="hljs-keyword">return</span> _M_invoke(_Indices());<br>&#125;<br>     &#125;;<br></code></pre></td></tr></table></figure><h4 id="_m_invoke"><a class="markdownIt-Anchor" href="#_m_invoke"></a> _M_invoke</h4><p>这个函数把<code>_M_t</code>中的每个元素取出,传给<code>std::__invoke</code>以执行.</p><p>然后返回<code>__result&lt;_Tuple&gt;::type</code>类型的返回值.</p><p>这里的具体实现日后补充.</p><h4 id="__make_invoker-2"><a class="markdownIt-Anchor" href="#__make_invoker-2"></a> __make_invoker</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp">   <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... _Tp&gt;<br>     <span class="hljs-keyword">using</span> __decayed_tuple = tuple&lt;<span class="hljs-keyword">typename</span> decay&lt;_Tp&gt;::type...&gt;;<br><br> <span class="hljs-keyword">public</span>:<br>   <span class="hljs-comment">// Returns a call wrapper that stores</span><br>   <span class="hljs-comment">// tuple&#123;DECAY_COPY(__callable), DECAY_COPY(__args)...&#125;.</span><br>   <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Callable, <span class="hljs-keyword">typename</span>... _Args&gt;<br>     <span class="hljs-type">static</span> _Invoker&lt;__decayed_tuple&lt;_Callable, _Args...&gt;&gt;<br>     __make_invoker(_Callable&amp;&amp; __callable, _Args&amp;&amp;... __args)<br>     &#123;<br><span class="hljs-keyword">return</span> &#123; __decayed_tuple&lt;_Callable, _Args...&gt;&#123;<br>    std::forward&lt;_Callable&gt;(__callable), std::forward&lt;_Args&gt;(__args)...<br>&#125; &#125;;<br>     &#125;<br> &#125;;<br></code></pre></td></tr></table></figure><p>上面构造函数处已经介绍.</p><h2 id="线程比较操作"><a class="markdownIt-Anchor" href="#线程比较操作"></a> 线程比较操作</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">swap</span><span class="hljs-params">(thread&amp; __x, thread&amp; __y)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123; __x.<span class="hljs-built_in">swap</span>(__y); &#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span><br><span class="hljs-keyword">operator</span>==(thread::id __x, thread::id __y) <span class="hljs-keyword">noexcept</span><br>&#123;<br>  <span class="hljs-comment">// pthread_equal is undefined if either thread ID is not valid, so we</span><br>  <span class="hljs-comment">// can&#x27;t safely use __gthread_equal on default-constructed values (nor</span><br>  <span class="hljs-comment">// the non-zero value returned by this_thread::get_id() for</span><br>  <span class="hljs-comment">// single-threaded programs using GNU libc). Assume EqualityComparable.</span><br>  <span class="hljs-keyword">return</span> __x._M_thread == __y._M_thread;<br>&#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span><br><span class="hljs-keyword">operator</span>!=(thread::id __x, thread::id __y) <span class="hljs-keyword">noexcept</span><br>&#123; <span class="hljs-keyword">return</span> !(__x == __y); &#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span><br><span class="hljs-keyword">operator</span>&lt;(thread::id __x, thread::id __y) <span class="hljs-keyword">noexcept</span><br>&#123;<br>  <span class="hljs-comment">// Pthreads doesn&#x27;t define any way to do this, so we just have to</span><br>  <span class="hljs-comment">// assume native_handle_type is LessThanComparable.</span><br>  <span class="hljs-keyword">return</span> __x._M_thread &lt; __y._M_thread;<br>&#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span><br><span class="hljs-keyword">operator</span>&lt;=(thread::id __x, thread::id __y) <span class="hljs-keyword">noexcept</span><br>&#123; <span class="hljs-keyword">return</span> !(__y &lt; __x); &#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span><br><span class="hljs-keyword">operator</span>&gt;(thread::id __x, thread::id __y) <span class="hljs-keyword">noexcept</span><br>&#123; <span class="hljs-keyword">return</span> __y &lt; __x; &#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span><br><span class="hljs-keyword">operator</span>&gt;=(thread::id __x, thread::id __y) <span class="hljs-keyword">noexcept</span><br>&#123; <span class="hljs-keyword">return</span> !(__x &lt; __y); &#125;<br></code></pre></td></tr></table></figure><p>纯粹是在数值上对比线程id.</p><h2 id="哈希"><a class="markdownIt-Anchor" href="#哈希"></a> 哈希</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// DR 889.</span><br><span class="hljs-comment">/// std::hash specialization for thread::id.</span><br><span class="hljs-keyword">template</span>&lt;&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">hash</span>&lt;thread::id&gt;<br>  : <span class="hljs-keyword">public</span> __hash_base&lt;<span class="hljs-type">size_t</span>, thread::id&gt;<br>  &#123;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span></span><br><span class="hljs-function">    <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> thread::id&amp; __id)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> std::_Hash_impl::<span class="hljs-built_in">hash</span>(__id._M_thread); &#125;<br>  &#125;;<br></code></pre></td></tr></table></figure><p>关键的函数<code>_Hash_impl::hash</code>定义于<code>bits/functional_hash.h</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">_Hash_impl</span><br>&#123;<br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">size_t</span></span><br><span class="hljs-function">  <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* __ptr, <span class="hljs-type">size_t</span> __clength,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">size_t</span> __seed = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(<span class="hljs-number">0xc70f6907</span>UL))</span></span><br><span class="hljs-function">  </span>&#123; <span class="hljs-keyword">return</span> _Hash_bytes(__ptr, __clength, __seed); &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;</span><br><span class="hljs-function">    <span class="hljs-type">static</span> <span class="hljs-type">size_t</span></span><br><span class="hljs-function">    <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-type">const</span> _Tp&amp; __val)</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>(&amp;__val, <span class="hljs-built_in">sizeof</span>(__val)); &#125;<br><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>    <span class="hljs-type">static</span> <span class="hljs-type">size_t</span><br>    __hash_combine(<span class="hljs-type">const</span> _Tp&amp; __val, <span class="hljs-type">size_t</span> __hash)<br>    &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>(&amp;__val, <span class="hljs-built_in">sizeof</span>(__val), __hash); &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>他最终调用了<code>_Hash_bytes</code>.定义于<code>hash_bytes.cc</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp">_Hash_bytes(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* ptr, <span class="hljs-type">size_t</span> len, <span class="hljs-type">size_t</span> seed)<br>&#123;<br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> mul = (((<span class="hljs-type">size_t</span>) <span class="hljs-number">0xc6a4a793</span>UL) &lt;&lt; <span class="hljs-number">32UL</span>)<br>                            + (<span class="hljs-type">size_t</span>) <span class="hljs-number">0x5bd1e995</span>UL;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> buf = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(ptr);<br>  <span class="hljs-comment">// Remove the bytes not divisible by the sizeof(size_t).  This</span><br>  <span class="hljs-comment">// allows the main loop to process the data as 64-bit integers.</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> len_aligned = len &amp; ~<span class="hljs-number">0x7</span>;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> end = buf + len_aligned;<br>  <span class="hljs-type">size_t</span> hash = seed ^ (len * mul);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-type">char</span>* p = buf; p != end; p += <span class="hljs-number">8</span>)<br>    &#123;<br>      <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> data = <span class="hljs-built_in">shift_mix</span>(<span class="hljs-built_in">unaligned_load</span>(p) * mul) * mul;<br>      hash ^= data;<br>      hash *= mul;<br>    &#125;<br>  <span class="hljs-keyword">if</span> ((len &amp; <span class="hljs-number">0x7</span>) != <span class="hljs-number">0</span>)<br>    &#123;<br>      <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> data = <span class="hljs-built_in">load_bytes</span>(end, len &amp; <span class="hljs-number">0x7</span>);<br>      hash ^= data;<br>      hash *= mul;<br>    &#125;<br>  hash = <span class="hljs-built_in">shift_mix</span>(hash) * mul;<br>  hash = <span class="hljs-built_in">shift_mix</span>(hash);<br>  <span class="hljs-keyword">return</span> hash;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="打印线程"><a class="markdownIt-Anchor" href="#打印线程"></a> 打印线程</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_CharT</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">_Traits</span>&gt;<br>   <span class="hljs-keyword">inline</span> basic_ostream&lt;_CharT, _Traits&gt;&amp;<br>   <span class="hljs-keyword">operator</span>&lt;&lt;(basic_ostream&lt;_CharT, _Traits&gt;&amp; __out, thread::id __id)<br>   &#123;<br>     <span class="hljs-keyword">if</span> (__id == thread::<span class="hljs-built_in">id</span>())<br><span class="hljs-keyword">return</span> __out &lt;&lt; <span class="hljs-string">&quot;thread::id of a non-executing thread&quot;</span>;<br>     <span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> __out &lt;&lt; __id._M_thread;<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="this-thread"><a class="markdownIt-Anchor" href="#this-thread"></a> this thread</h2><p>以下是一些获取id,睡眠相关的函数.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <span class="hljs-keyword">namespace</span> this_thread<br>  &#123;<br>    <span class="hljs-comment">/// get_id</span><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> thread::id</span><br><span class="hljs-function">    <span class="hljs-title">get_id</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">    </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __GLIBC__</span><br>      <span class="hljs-comment">// For the GNU C library pthread_self() is usable without linking to</span><br>      <span class="hljs-comment">// libpthread.so but returns 0, so we cannot use it in single-threaded</span><br>      <span class="hljs-comment">// programs, because this_thread::get_id() != thread::id&#123;&#125; must be true.</span><br>      <span class="hljs-comment">// We know that pthread_t is an integral type in the GNU C library.</span><br>      <span class="hljs-keyword">if</span> (!__gthread_active_p())<br><span class="hljs-keyword">return</span> thread::<span class="hljs-built_in">id</span>(<span class="hljs-number">1</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>      <span class="hljs-keyword">return</span> thread::<span class="hljs-built_in">id</span>(__gthread_self());<br>    &#125;<br><br>    <span class="hljs-comment">/// yield</span><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span></span><br><span class="hljs-function">    <span class="hljs-title">yield</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">    </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _GLIBCXX_USE_SCHED_YIELD</span><br>      __gthread_yield();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;<br><br>    <span class="hljs-type">void</span><br>    __sleep_for(chrono::seconds, chrono::nanoseconds);<br><br>    <span class="hljs-comment">/// sleep_for</span><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Rep, <span class="hljs-keyword">typename</span> _Period&gt;</span><br><span class="hljs-function">      <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span></span><br><span class="hljs-function">      <span class="hljs-title">sleep_for</span><span class="hljs-params">(<span class="hljs-type">const</span> chrono::duration&lt;_Rep, _Period&gt;&amp; __rtime)</span></span><br><span class="hljs-function">      </span>&#123;<br><span class="hljs-keyword">if</span> (__rtime &lt;= __rtime.<span class="hljs-built_in">zero</span>())<br>  <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">auto</span> __s = chrono::<span class="hljs-built_in">duration_cast</span>&lt;chrono::seconds&gt;(__rtime);<br><span class="hljs-keyword">auto</span> __ns = chrono::<span class="hljs-built_in">duration_cast</span>&lt;chrono::nanoseconds&gt;(__rtime - __s);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _GLIBCXX_USE_NANOSLEEP</span><br><span class="hljs-type">__gthread_time_t</span> __ts =<br>  &#123;<br>    <span class="hljs-built_in">static_cast</span>&lt;std::<span class="hljs-type">time_t</span>&gt;(__s.<span class="hljs-built_in">count</span>()),<br>    <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">long</span>&gt;(__ns.<span class="hljs-built_in">count</span>())<br>  &#125;;<br><span class="hljs-keyword">while</span> (::<span class="hljs-built_in">nanosleep</span>(&amp;__ts, &amp;__ts) == <span class="hljs-number">-1</span> &amp;&amp; errno == EINTR)<br>  &#123; &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>__sleep_for(__s, __ns);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>      &#125;<br><br>    <span class="hljs-comment">/// sleep_until</span><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Clock, <span class="hljs-keyword">typename</span> _Duration&gt;</span><br><span class="hljs-function">      <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span></span><br><span class="hljs-function">      <span class="hljs-title">sleep_until</span><span class="hljs-params">(<span class="hljs-type">const</span> chrono::time_point&lt;_Clock, _Duration&gt;&amp; __atime)</span></span><br><span class="hljs-function">      </span>&#123;<br><span class="hljs-keyword">auto</span> __now = _Clock::<span class="hljs-built_in">now</span>();<br><span class="hljs-keyword">if</span> (_Clock::is_steady)<br>  &#123;<br>    <span class="hljs-keyword">if</span> (__now &lt; __atime)<br>      <span class="hljs-built_in">sleep_for</span>(__atime - __now);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><span class="hljs-keyword">while</span> (__now &lt; __atime)<br>  &#123;<br>    <span class="hljs-built_in">sleep_for</span>(__atime - __now);<br>    __now = _Clock::<span class="hljs-built_in">now</span>();<br>  &#125;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>细说CPP标准和stl源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>细说std源码</tag>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nokia N1刷惜旧官改ROM</title>
    <link href="/4f38d4d9/"/>
    <url>/4f38d4d9/</url>
    
    <content type="html"><![CDATA[<ul><li>解锁bootloader;</li><li>刷入twrp;</li><li>刷入ROM;</li></ul><span id="more"></span><h2 id="声明"><a class="markdownIt-Anchor" href="#声明"></a> 声明</h2><p>十分鸣谢制作惜旧ROM的大佬(QQ群:570160568).</p><p>更多相关文件可以进群下载,如果群满人也可以从这个<a href="https://1drv.ms/u/s!AlAdPSrz4UaPjGHq01n1flodaY8c?e=gaFuqD">onedrive链接下载</a>.</p><p>ROM带有以下软件</p><blockquote><p>google设置<br />黑域 补丁版<br />MT管理器<br />nova设置<br />play商店<br />QQ输入法<br />设置<br />时钟<br />superSU<br />图库<br />via<br />网速指示器<br />wps office<br />下载<br />google相机</p></blockquote><h2 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h2><h3 id="安装adb和fastboot"><a class="markdownIt-Anchor" href="#安装adb和fastboot"></a> 安装adb和fastboot</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install adb fastboot<br></code></pre></td></tr></table></figure><h3 id="下载所需的文件"><a class="markdownIt-Anchor" href="#下载所需的文件"></a> 下载所需的文件</h3><table><thead><tr><th>文件</th><th>作用</th></tr></thead><tbody><tr><td><code>twrp2.8.7.1-nokia-n1-zh-cn.img</code></td><td>recovery文件</td></tr><tr><td><code>Nokia_n1-B19(5.1)-惜旧新官改-MD5_c31812148c.zip</code></td><td>ROM包</td></tr></tbody></table><p><a href="https://1drv.ms/u/s!AlAdPSrz4UaPjGHq01n1flodaY8c?e=gaFuqD">下载链接</a>.</p><h2 id="进入twrp"><a class="markdownIt-Anchor" href="#进入twrp"></a> 进入twrp</h2><p>首先打开<code>开发者模式</code>,在<code>开发者模式</code>打开<code>USB调试</code>和<code>oem解锁</code>.</p><p>弹出<code>允许USB调试吗?</code>,选择<code>一律允许使用这台计算机进行调试</code>,然后<code>确认</code>.</p><p>输入以下命令进入<code>bootloader</code>.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb reboot bootloader<br></code></pre></td></tr></table></figure><p>输入以下命令解锁<code>bootloader</code></p><p><code>linux</code>需要使用<code>sudo</code>,其他系统可以不写<code>sudo</code>.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo fastboot oem unlock<br></code></pre></td></tr></table></figure><p>输入以下命令刷入<code>twrp</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo fastboot flash boot &lt;你存放的路径&gt;/twrp2.8.7.1-nokia-n1-zh-cn.img<br></code></pre></td></tr></table></figure><p>重启,就会进入<code>twrp</code>.</p><h2 id="刷入惜旧rom"><a class="markdownIt-Anchor" href="#刷入惜旧rom"></a> 刷入惜旧ROM</h2><p>在<code>twrp</code>中,选<code>清除-&gt;高级</code>,选择全部选项,滑动确认清除.</p><p>选<code>清楚-&gt;格式化data</code>,滑动确认清除.</p><h3 id="方法1-线刷"><a class="markdownIt-Anchor" href="#方法1-线刷"></a> 方法1 线刷</h3><p>选<code>高级-&gt;adb线刷</code>,确认开始.</p><p>电脑输入命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb sideload &lt;你存放的路径&gt;/Nokia_n1-B19(5.1)-惜旧新官改-MD5_c31812148c.zip<br></code></pre></td></tr></table></figure><h3 id="方法2-卡刷"><a class="markdownIt-Anchor" href="#方法2-卡刷"></a> 方法2 卡刷</h3><p>有可能你用<code>adb sideload</code>传不进去.</p><p>但是你的电脑识别到平板了,可以把<code>ROM</code>包传到平板上.</p><p>那么你可以直接在<code>twrp</code>内找到你传进去的包,然后直接安装,图形化得很.</p><p>一阵摇晃之后,就会进入系统.</p><p>第一次有点久,不要担心.</p>]]></content>
    
    
    <categories>
      
      <category>资源分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nokia n1</tag>
      
      <tag>惜旧</tag>
      
      <tag>android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux开启samba服务</title>
    <link href="/db95d7df/"/>
    <url>/db95d7df/</url>
    
    <content type="html"><![CDATA[<ul><li>samba安装;</li><li>添加用户;</li><li>配置文件;</li></ul><span id="more"></span><h2 id="安装samba"><a class="markdownIt-Anchor" href="#安装samba"></a> 安装samba</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install samba<br></code></pre></td></tr></table></figure><h2 id="添加samba用户"><a class="markdownIt-Anchor" href="#添加samba用户"></a> 添加samba用户</h2><p>我反正是懒得创建新用户了, 直接把自己在用的用户设置成了samba用户.</p><p>直接输入<code>smbpasswd</code>命令, 即将当前用户设置为samba用户, 并且设置samba密码.</p><p>你也可以使用<code>sudo smbpasswd -a &lt;用户名&gt;</code>来指定一个用户, 并且为其设置samba密码. (这个用户要已经存在, 你可以先用<code>useradd</code>创建一个).</p><h2 id="最简配置文件"><a class="markdownIt-Anchor" href="#最简配置文件"></a> 最简配置文件</h2><p>配置文件格式形如</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs prolog">[段落名]<br>  内容<br>  ...<br><br>[段落名]<br>  内容<br>  ...<br>...<br></code></pre></td></tr></table></figure><h4 id="全局设置"><a class="markdownIt-Anchor" href="#全局设置"></a> 全局设置</h4><p><code>[global]</code>段是全局设置.</p><p>你可以直接拷贝以下内容(是的我也看不懂)</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[<span class="hljs-keyword">global</span>]<br>    dns proxy = <span class="hljs-keyword">No</span><br>    map <span class="hljs-keyword">to</span> guest = Bad <span class="hljs-keyword">User</span><br>    netbios <span class="hljs-type">name</span> = ARCH LINUX<br>    <span class="hljs-keyword">security</span> = <span class="hljs-keyword">USER</span><br>    <span class="hljs-keyword">server</span> <span class="hljs-keyword">role</span> = standalone <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><h4 id="文件夹设置"><a class="markdownIt-Anchor" href="#文件夹设置"></a> 文件夹设置</h4><p>每个<code>[共享项目名称]</code>描述了一个共享文件夹的设置.</p><p>也就是你每需要设置一个共享文件夹, 就在这里加一段描述.</p><p>例如</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># 别人访问samba将会看到这个文件夹名&lt;home&gt;</span><br>[home]<br>    <span class="hljs-comment"># 文件夹的路径</span><br>    path = <span class="hljs-regexp">/home/</span>zzidun/<br>    <span class="hljs-comment"># 是否只读</span><br>    <span class="hljs-keyword">read</span> only = No<br>    <span class="hljs-comment"># 具有写入权限的用户()</span><br>    <span class="hljs-keyword">write</span> list = @zzidun<br></code></pre></td></tr></table></figure><h4 id="我的完整配置文件"><a class="markdownIt-Anchor" href="#我的完整配置文件"></a> 我的完整配置文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[global]<br>    dns proxy = No<br>    map to guest = Bad User<br>    netbios name = ARCH LINUX<br>    security = USER<br>    server role = standalone server<br><br>[home]<br>    path = /home/zzidun/<br>    read only = No<br>    write list = @zzidun<br></code></pre></td></tr></table></figure><h2 id="启动服务"><a class="markdownIt-Anchor" href="#启动服务"></a> 启动服务</h2><p>对于<code>archlinux</code>, 使用以下命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl enable samba<br>sudo systemctl enable smb.service<br><br></code></pre></td></tr></table></figure><p>之后就可以在局域网内的各个设备通过<code>ip</code>访问这个文件夹.</p>]]></content>
    
    
    <categories>
      
      <category>软件安装和配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>samba</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++模板元编程初步</title>
    <link href="/ef6ea057/"/>
    <url>/ef6ea057/</url>
    
    <content type="html"><![CDATA[<ul><li>integral_constant源码分析;</li><li>conditional源码分析;</li><li>__or_源码分析;</li></ul><span id="more"></span><h2 id="integral_constant"><a class="markdownIt-Anchor" href="#integral_constant"></a> integral_constant</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp, _Tp __v&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">integral_constant</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> _Tp                  value = __v;<br>    <span class="hljs-keyword">typedef</span> _Tp                           value_type;<br>    <span class="hljs-keyword">typedef</span> integral_constant&lt;_Tp, __v&gt;   type;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">value_type</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> value; &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> __cplusplus &gt; 201103L</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __cpp_lib_integral_constant_callable 201304</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> value_type <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> value; &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="constexpr"><a class="markdownIt-Anchor" href="#constexpr"></a> constexpr</h3><p>在编译期需要用到的值,必须能够在编译期确定.</p><p>如果像是这样:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_five</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;&#125;<br><br><span class="hljs-type">int</span> some_value[<span class="hljs-built_in">get_five</span>() + <span class="hljs-number">7</span>];<br></code></pre></td></tr></table></figure><p>因为<code>fet_five()+7</code>是一个需要在运行时才能确定的值.</p><p>而<code>somve_value</code>的大小必须要在编译期确定,所以以上代码会报错.</p><p><code>C++11</code>有了<code>constexpr</code>.</p><p>可以如果函数符合某些条件,以至于能够在编译期就确定他的返回值,那么加上<code>constexpr</code>能够在编译期使用这个函数的返回值.</p><p>就像上面的代码可以改为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">constexpr int get_five() &#123;return 5;&#125;<br><br>int some_value[get_five() + 7];<br></code></pre></td></tr></table></figure><h3 id="__cpp_lib_integral_constant_callable"><a class="markdownIt-Anchor" href="#__cpp_lib_integral_constant_callable"></a> __cpp_lib_integral_constant_callable</h3><p>这个宏表示这个函数重载了<code>operator()</code>,至于为什么要把<code>operator()</code>写在<code>#if __cplusplus &gt; 201103L</code>里面,我暂时不清楚.</p><h3 id="成员"><a class="markdownIt-Anchor" href="#成员"></a> 成员</h3><p>结构体定义了类型为<code>_Tp</code>的成员<code>value</code>,值为<code>__v</code>.</p><p>并且把<code>_Tp</code>定义为<code>value_type</code>,把这个结构体本身定义为<code>type</code>.</p><p>这些成员都是可以在编译期确定了,也就是可以写一个这样的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::integral_constant&lt;<span class="hljs-type">bool</span>, <span class="hljs-literal">true</span>&gt;::value_type the_bool<br>  = std::integral_constant&lt;<span class="hljs-type">bool</span>, <span class="hljs-literal">true</span>&gt;::value;<br></code></pre></td></tr></table></figure><p>这个代码虽然没啥卵用,但是这个用法是很有用的.</p><h3 id="operator-value_type"><a class="markdownIt-Anchor" href="#operator-value_type"></a> operator value_type()</h3><p>这个函数的作用是:当把这个结构体转成<code>value_type</code>类型时,实际上会返回这个函数的返回值.</p><p>类似的用法如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sample</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>；&#125;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">operator</span> <span class="hljs-built_in">float</span>() <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">2.0</span>; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    sample the_sample;<br>    std::cout &lt;&lt; <span class="hljs-built_in">float</span>(the_sample) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-built_in">double</span>(the_sample) &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="value_type-operator"><a class="markdownIt-Anchor" href="#value_type-operator"></a> value_type operator()()</h3><p>如果有一个类实现了<code>operator()()</code>,我们可以将这个类实例化的对象当成一个函数来用.</p><p>把这个对象当成函数来使用时,他就会执行函数<code>operator()()</code>.</p><p>例如这样:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sample</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    sample the_sample;<br>    std::cout &lt;&lt; <span class="hljs-built_in">the_sample</span>() &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-built_in">the_sample</span>(<span class="hljs-number">1</span>) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-built_in">the_sample</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>知道这几个特性之后,这个结构体的作用就非常明显了.</p><h3 id="true_type和false_type"><a class="markdownIt-Anchor" href="#true_type和false_type"></a> true_type和false_type</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/// The type used as a compile-time boolean with true value.</span><br><span class="hljs-keyword">typedef</span> integral_constant&lt;<span class="hljs-type">bool</span>, <span class="hljs-literal">true</span>&gt;     true_type;<br><br><span class="hljs-comment">/// The type used as a compile-time boolean with false value.</span><br><span class="hljs-keyword">typedef</span> integral_constant&lt;<span class="hljs-type">bool</span>, <span class="hljs-literal">false</span>&gt;    false_type;<br></code></pre></td></tr></table></figure><p>C++预先定义了这两个结构体,其他很多地方用到.</p><p>这里我们细说<code>true_type</code>,他的表现如下</p><table><thead><tr><th>用法</th><th>效果</th></tr></thead><tbody><tr><td><code>true_type().value</code></td><td>值<code>true</code></td></tr><tr><td><code>true_type::value_type</code></td><td>类型<code>bool</code></td></tr><tr><td><code>type</code></td><td>类型<code>integral_constant&lt;bool, true&gt;</code></td></tr><tr><td><code>bool(true_type())</code></td><td>值<code>true</code></td></tr><tr><td><code>true_type()()</code></td><td>值<code>true</code></td></tr></tbody></table><p>再次强调,这里几个成员,要不就是<code>constexpr</code>变量和函数,要不就是<code>typedef</code>定义的类型.他们都可以在编译期确定.</p><h2 id="conditional"><a class="markdownIt-Anchor" href="#conditional"></a> conditional</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">bool</span> _Cond, <span class="hljs-keyword">typename</span> _Iftrue, <span class="hljs-keyword">typename</span> _Iffalse&gt;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">conditional</span><br>    &#123; <span class="hljs-keyword">typedef</span> _Iftrue type; &#125;;<br><br><span class="hljs-comment">// Partial specialization for false.</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Iftrue, <span class="hljs-keyword">typename</span> _Iffalse&gt;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">conditional</span>&lt;<span class="hljs-literal">false</span>, _Iftrue, _Iffalse&gt;<br>    &#123; <span class="hljs-keyword">typedef</span> _Iffalse type; &#125;;<br></code></pre></td></tr></table></figure><p>以上代码根据<code>bool _Cond</code>的值,来决定<code>conditional::type</code>.</p><p>先定义一个模板类,无论如何都把<code>type</code>定义为<code>_Iftrue</code>.</p><p>然后特化这个模板,当<code>_Cond</code>传入<code>false</code>的时候,把<code>type</code>定义为<code>_Iffalse</code>.</p><p>上述的<code>conditonal</code>的第一个模板参数<code>_Cond</code>其实很有说法.</p><p>如果我们直接传布尔值,或者传一个很简单的表达式,那就浪费了.</p><p>因此,C++定义了<code>__or_</code>, <code>__and_</code>等等结构体,来实现复杂的判断.</p><h2 id="__or_"><a class="markdownIt-Anchor" href="#__or_"></a> __or_</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>...&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__or_</span>;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__or_</span>&lt;&gt;<br>  : <span class="hljs-keyword">public</span> false_type<br>  &#123; &#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _B1&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__or_</span>&lt;_B1&gt;<br>  : <span class="hljs-keyword">public</span> _B1<br>  &#123; &#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _B1, <span class="hljs-keyword">typename</span> _B2&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__or_</span>&lt;_B1, _B2&gt;<br>  : <span class="hljs-keyword">public</span> conditional&lt;_B1::value, _B1, _B2&gt;::type<br>  &#123; &#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _B1, <span class="hljs-keyword">typename</span> _B2, <span class="hljs-keyword">typename</span> _B3, <span class="hljs-keyword">typename</span>... _Bn&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__or_</span>&lt;_B1, _B2, _B3, _Bn...&gt;<br>  : <span class="hljs-keyword">public</span> conditional&lt;_B1::value, _B1, __or_&lt;_B2, _B3, _Bn...&gt;&gt;::type<br>  &#123; &#125;;<br></code></pre></td></tr></table></figure><p>这里细说<code>__or_</code>.</p><h3 id="__or_-2"><a class="markdownIt-Anchor" href="#__or_-2"></a> __or_&lt;&gt;</h3><p>当我们不给<code>__or_</code>传模板参数时,他就会直接继承一个<code>false_type</code>.</p><p>也就是说以下代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::__or_&lt;&gt; empty_or;<br>std::cout &lt;&lt; empty_or.value &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><p>会输出<code>0</code>.</p><h3 id="__or__b1"><a class="markdownIt-Anchor" href="#__or__b1"></a> __or_&lt;_B1&gt;</h3><p>当<code>__or_</code>接受一个模板参数的时候,他直接继承这个这个参数.</p><p>也就是如果这个参数继承了<code>true_type</code>,也就是<code>_B1::value</code>为<code>true</code>,那么<code>__or_</code>就会继承<code>_B1</code>,从而表现出<code>true_type</code>的特点.</p><p>同理,如果这个参数继承了<code>false_type</code>,那么<code>__or_</code>表现出<code>false_type</code>的特点.</p><p>这非常符合<code>or</code>的特征,当只接收一个布尔值时,计算结果就是这个布尔值.</p><h3 id="__or__b1-_b2"><a class="markdownIt-Anchor" href="#__or__b1-_b2"></a> __or_&lt;_B1, _B2&gt;</h3><p>如果<code>_B1::value</code>为<code>true</code>,那么<code>conditional&lt;_B1::value, _B1, _B2&gt;::type</code>将会返回<code>_B1</code>,<code>__or_</code>直接继承<code>_B1</code>,无视<code>_B2</code>.</p><p>否则就继承<code>_B2</code>.</p><p>继承<code>_B2</code>之后,<code>__or_</code>的<code>value</code>取决于<code>_B2::value</code>.</p><p>这和<code>or</code>运算的表现一模一样.</p><p>此外,<code>stl</code>的源码中还有<code>__and_</code>等等用于逻辑运算的模板类.实现方法也类似.</p><p>到这里我们发现一个特点,模板元编程能够在编译期执行一些条件判断.</p><p>他不能像指令式编程那样一条条语句往下写,反而很像函数式编程.</p><p>可以通过上面的方法来组合各个类,编译器一顿推导之后,就会返回我们想要的值.</p>]]></content>
    
    
    <categories>
      
      <category>细说CPP标准和stl源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>细说std源码</tag>
      
      <tag>模板元编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>命令行音乐播放器cmus入门</title>
    <link href="/357c031/"/>
    <url>/357c031/</url>
    
    <content type="html"><![CDATA[<ul><li>主要页面;</li><li>基本操作;</li></ul><span id="more"></span><h2 id="主要页面"><a class="markdownIt-Anchor" href="#主要页面"></a> 主要页面</h2><p>按下数字键,就会切换页面,有以下:</p><table><thead><tr><th>数字键</th><th>页面内容</th></tr></thead><tbody><tr><td><code>1</code></td><td>左边专辑,右边专辑内的内容</td></tr><tr><td><code>2</code></td><td>所有已加入的音频按</td></tr><tr><td><code>3</code></td><td>左边歌单,右边歌单内的内容</td></tr><tr><td><code>4</code></td><td>播放队列</td></tr><tr><td><code>5</code></td><td>文件管理器,可以在这里翻找歌曲</td></tr><tr><td><code>6</code></td><td>筛选条件</td></tr><tr><td><code>7</code></td><td>设置</td></tr></tbody></table><p>分多栏目的时候,左边是一级菜单,右边是二级菜单.</p><p>上下键选择菜单中的条目,<code>tab</code>键切换到当前条目的子菜单(也就是换到右边).</p><h2 id="添加歌曲"><a class="markdownIt-Anchor" href="#添加歌曲"></a> 添加歌曲</h2><h3 id="添加一个文件夹中的所有歌曲"><a class="markdownIt-Anchor" href="#添加一个文件夹中的所有歌曲"></a> 添加一个文件夹中的所有歌曲</h3><p>命令如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">:add &lt;路径&gt;<br></code></pre></td></tr></table></figure><h3 id="从文件管理器中选择"><a class="markdownIt-Anchor" href="#从文件管理器中选择"></a> 从文件管理器中选择</h3><p>按<code>5</code>进入文件管理器,把光标移动到你想要的歌曲,按<code>a</code>添加.</p><h2 id="基本播放操作"><a class="markdownIt-Anchor" href="#基本播放操作"></a> 基本播放操作</h2><p>以下按键区分大小写,也就是大写<code>A</code>相当于<code>shift a</code>.</p><table><thead><tr><th>按键</th><th>作用</th></tr></thead><tbody><tr><td>回车</td><td>播放所选歌曲或专辑或歌单</td></tr><tr><td>左右</td><td>调整进度</td></tr><tr><td><code>b</code></td><td>下一首</td></tr><tr><td><code>z</code></td><td>上一首</td></tr><tr><td><code>c</code></td><td>暂停和继续</td></tr><tr><td><code>v</code></td><td>停止播放</td></tr><tr><td><code>s</code></td><td>随机切歌</td></tr><tr><td><code>r</code></td><td>重复播放</td></tr><tr><td><code>-</code></td><td>降低音量</td></tr><tr><td><code>=</code></td><td>增加音量</td></tr><tr><td><code>/</code></td><td>搜索歌曲,就像<code>vim</code></td></tr><tr><td><code>q</code></td><td>退出</td></tr></tbody></table><h2 id="歌单"><a class="markdownIt-Anchor" href="#歌单"></a> 歌单</h2><h3 id="创建歌单"><a class="markdownIt-Anchor" href="#创建歌单"></a> 创建歌单</h3><p>命令如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">:pl-create &lt;名称&gt;<br></code></pre></td></tr></table></figure><h3 id="编辑歌单"><a class="markdownIt-Anchor" href="#编辑歌单"></a> 编辑歌单</h3><p>按<code>3</code>切换到歌单页,光标移动到想要编辑的歌单,空格标记他(他前面会有一个<code>*</code>).</p><h4 id="添加文件夹中的歌曲到歌单"><a class="markdownIt-Anchor" href="#添加文件夹中的歌曲到歌单"></a> 添加文件夹中的歌曲到歌单</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">:add -p &lt;路径&gt;<br></code></pre></td></tr></table></figure><h4 id="添加歌曲到歌单"><a class="markdownIt-Anchor" href="#添加歌曲到歌单"></a> 添加歌曲到歌单</h4><p>切换到歌曲页或文件管理器,光标移动到歌曲上,按<code>y</code>.</p><p>就会添加歌曲到你当前标记的歌单.</p><h4 id="移动或移除"><a class="markdownIt-Anchor" href="#移动或移除"></a> 移动或移除</h4><p>切到歌单页,光标移动到想要调整的歌单,按<code>tab</code>进入子菜单.</p><p>光标移动到歌曲上,按<code>D</code>从歌单中移除歌曲.</p><p>按<code>p</code>上移歌曲,按<code>P</code>下移歌曲.</p>]]></content>
    
    
    <categories>
      
      <category>经验和总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cmus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>各类总线协议总结</title>
    <link href="/c2cf85d2/"/>
    <url>/c2cf85d2/</url>
    
    <content type="html"><![CDATA[<ul><li>UART;</li><li>IIC;</li><li>SPI;</li><li>RS232;</li><li>RS485;</li></ul><span id="more"></span><h2 id="uart通用异步收发器"><a class="markdownIt-Anchor" href="#uart通用异步收发器"></a> UART(通用异步收发器)</h2><h3 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h3><p><code>UART</code>总线有两条线,一条接收<code>RXD</code>,一条发送<code>TXD</code>.</p><p>连接时两个设备交叉连接,甲的<code>RXD</code>连乙的<code>TXD</code>.</p><h3 id="帧格式"><a class="markdownIt-Anchor" href="#帧格式"></a> 帧格式</h3><p>一次只能发送一个字节,如果需要发送多个字节需要发送多次.</p><table><thead><tr><th>起始位</th><th>数据位</th><th>校验位</th><th>停止位</th></tr></thead><tbody><tr><td><code>1</code>个<code>0</code></td><td><code>5</code>到<code>8</code>位,先发低位</td><td><code>1</code>位</td><td><code>1~2</code>个<code>1</code></td></tr></tbody></table><p>从空闲状态发送一个字节的过程</p><p>首先发送一个起始位<code>0</code>,然后发送数据和校验位,最后停止位<code>1</code>.</p><p>停止位可以是<code>1</code> <code>1.5</code>或<code>2</code>位,这是因为发送一个字节之后可能会发送一点不同步,停止位可以让他们校准.</p><p>停止位越长,对不同步的容忍越大,但是速率也越慢.</p><h2 id="iic"><a class="markdownIt-Anchor" href="#iic"></a> IIC</h2><h3 id="简介-2"><a class="markdownIt-Anchor" href="#简介-2"></a> 简介</h3><p><code>IIC</code>有两根线,一根时钟线<code>SCL</code>,一根数据线<code>SDA</code>.</p><p><code>IIC</code>总线上的器件有一个<code>7</code>位的唯一地址,每个器件都可以作为主机和从机.</p><p>主机有权发起和结束一次通信,而从机只能被主机呼叫.</p><h3 id="通信过程"><a class="markdownIt-Anchor" href="#通信过程"></a> 通信过程</h3><pre><code class="mermaid" >graph TD    A[1:主机发送起始信号启用总线] --> B[2:主机发送一个字节数据,指明从机地址和后续字节的传送方向]    B --> C[3:被寻址的从机发送应答信号]    C --> E[4:发送器发送一个字节数据]    E --> F[5:接收器回应发送信号]    F --后续还有数据--> E[6:发送器发送一个字节数据]    F --发送完毕--> G[7:通信完成后主机发送停止信号释放总线]</code></pre><p>需要注意,发送和接送的过程中,不一定是主机发送从机接受.</p><p>具体接受发送方向由步骤<code>2</code>确定.</p><p>所以我们这里只能称呼发送方为发送器,接收方为接收器.</p><p>对于数据的传输过程</p><h3 id="帧格式-2"><a class="markdownIt-Anchor" href="#帧格式-2"></a> 帧格式</h3><ol><li>起始信号和结束信号</li></ol><p>当<code>SCL</code>处于高电平时,<code>SDA</code>从高变低表示起始信号.</p><p>当<code>SCL</code>位于高电平时,<code>SDA</code>从低变高表示停止信号.</p><ol start="2"><li>地址</li></ol><table><thead><tr><th>7位地址</th><th>1位方向位</th></tr></thead><tbody><tr><td>表示从机地址</td><td><code>0</code>表示主机发往从机,<code>1</code>表示从机发往主机</td></tr></tbody></table><ol start="3"><li>数据</li></ol><table><thead><tr><th>数据位</th><th>应答位</th></tr></thead><tbody><tr><td><code>8</code>数据,也就是<code>1</code>个字节,先发送高位,再发送低位</td><td>接收器发送<code>1</code>位应答位,$ A $是应答, $ \bar{A} $是非应答</td></tr></tbody></table><p>发送数据时,电平如下变化:</p><p>当<code>SCL</code>处于低电平时,<code>SDA</code>变化,这时候发送器向<code>SDA</code>发送<code>1</code>位数据.</p><p>当<code>SCL</code>处于高电平时,<code>SDA</code>不变化,这时候接收器从<code>SDA</code>读取<code>1</code>位数据.</p><p>相当于发送器在时钟线低电平的时候放进数据,接收器在始终线高电平的时候接收数据.</p><p>把收发时机这样确定下来,就不会发送接收器还没读,发送器就放下一个数据之类的问题.</p><h2 id="spi"><a class="markdownIt-Anchor" href="#spi"></a> SPI</h2><h3 id="简介-3"><a class="markdownIt-Anchor" href="#简介-3"></a> 简介</h3><p><code>SPI</code>总线至少需要<code>4</code>条线.</p><table><thead><tr><th>主机</th><th>从机</th><th>作用</th></tr></thead><tbody><tr><td><code>SCLK</code></td><td><code>SCLK</code></td><td>时钟线</td></tr><tr><td><code>MOSI</code></td><td><code>MOSI</code></td><td>主机输出,从机输入</td></tr><tr><td><code>MISO</code></td><td><code>MISO</code></td><td>主机输入,从机输出</td></tr><tr><td><code>CS</code></td><td><code>CS</code></td><td>使能</td></tr></tbody></table><p>当一个主机要对应多个从机的时候,主机上需要多条<code>CS</code>线,来进行寻址.</p><p>多个从机的<code>SCLK</code>,都是连接到主机的同一个<code>SCLK</code>上的.</p><p>多个从机的<code>MOSI</code>,都是连接到主机的同一个<code>MOSI</code>上的.</p><p>多个从机的<code>MISO</code>,都是连接到主机的同一个<code>MISO</code>上的.</p><p>但是为了寻址从机,每个从机都需要对应主机上的一个单独的<code>CS</code>,来分别使要使用的从机使能.</p><p>因此主机上可能不止有<code>4</code>条线.</p><h3 id="通信过程-2"><a class="markdownIt-Anchor" href="#通信过程-2"></a> 通信过程</h3><p>对于一个字节,先传高位,后传地位.</p><p>在时钟的边沿发送数据,在时钟的下一个边沿读取数据.</p><h3 id="极性cpol和相位cphl"><a class="markdownIt-Anchor" href="#极性cpol和相位cphl"></a> 极性(CPOL)和相位(CPHL)</h3><p><code>CPOL</code>为<code>0</code>,表示空闲时<code>SCLK</code>为低电平.</p><p><code>CPOL</code>为<code>1</code>,表示空闲时<code>SCLK</code>位高电平.</p><p><code>CPHA</code>为<code>0</code>,表示每个周期的第一个时钟沿采样.</p><p><code>CPHA</code>为<code>1</code>,表示每个周期的第二个时钟沿采样.</p><h2 id="rs232rs485"><a class="markdownIt-Anchor" href="#rs232rs485"></a> RS232/RS485</h2><p><code>UART</code>只是定义了时序,没有定义接口的电气特性.</p><p><code>UART</code>通信一般直接使用处理器的电平,<code>TTL</code>电平.抗干扰能力差.传输距离短.</p><p><code>UART</code>没有定义连接器的标准,需要自己探索各线的定义.</p><h3 id="rs232"><a class="markdownIt-Anchor" href="#rs232"></a> RS232</h3><p><code>RS232</code>提出了一个标准的连接器,定义了各个引脚作用,规定了电平.</p><p>最开始他有<code>25</code>线,后来变成<code>9</code>线,大多使用的只有<code>GND</code>,<code>RXD</code>,<code>TXD</code>.</p><p>信号<code>1</code>为<code>-5v</code>到<code>-15v</code>.</p><p>信号<code>0</code>为<code>5v</code>到<code>15v</code>.</p><p>传输距离可达<code>15m</code>.</p><h3 id="rs485"><a class="markdownIt-Anchor" href="#rs485"></a> RS485</h3><p><code>RS485</code>用两线的电压差表示数据.</p><p>相差<code>+2v</code>到<code>+6v</code>为<code>1</code>.</p><p>相差<code>-2v</code>到<code>-6v</code>为<code>0</code>.</p><p>在这种情况下,总线上可以存在多个设备,使用半双工通信.</p><p>传输距离达到<code>1500m</code></p>]]></content>
    
    
    <categories>
      
      <category>经验和总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UART</tag>
      
      <tag>IIC</tag>
      
      <tag>SPI</tag>
      
      <tag>RS232</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>路由器ttl连接方法</title>
    <link href="/edb033a1/"/>
    <url>/edb033a1/</url>
    
    <content type="html"><![CDATA[<ul><li>安装软件;</li><li>基本配置;</li><li>排针焊接和连线;</li></ul><span id="more"></span><h2 id="安装minicom和tftpd-hpa"><a class="markdownIt-Anchor" href="#安装minicom和tftpd-hpa"></a> 安装minicom和tftpd-hpa</h2><h3 id="安装软件"><a class="markdownIt-Anchor" href="#安装软件"></a> 安装软件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install minicom<br>sudo apt install tftpd-hpa<br>sudo apt install tftp<br></code></pre></td></tr></table></figure><h3 id="配置tftp"><a class="markdownIt-Anchor" href="#配置tftp"></a> 配置tftp</h3><p>查看<code>tftpd-hpa</code>状态.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo service ftfpd-hpa status<br></code></pre></td></tr></table></figure><p>备份配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo cp /etc/default/tftpd-hpa /etc/default/tftpd-hpa.bak<br></code></pre></td></tr></table></figure><p>编辑<code>/etc/default/tftpd-hpa</code>文件.</p><p>修改<code>TFTP_OPTIONS</code>的值改为<code>--create</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">TFTP_OPTIONS=&quot;--secure --create&quot;<br></code></pre></td></tr></table></figure><p>修改<code>TFTP_DIRECTORY</code>的的值为你想要分享的目录(绝对路径),例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">TFTP_DIRECTORY=&quot;/home/zzidun/tftp-file&quot;<br></code></pre></td></tr></table></figure><p>这个目录你要先创建出来.</p><p>修改那个目录的权限.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo chown -R 777 /home/zzidun/tftp-file<br></code></pre></td></tr></table></figure><p>重启<code>tftp</code>服务.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo service tftpd-hpa restart<br></code></pre></td></tr></table></figure><h2 id="电脑终端打开路由器命令行"><a class="markdownIt-Anchor" href="#电脑终端打开路由器命令行"></a> 电脑终端打开路由器命令行</h2><h3 id="连接"><a class="markdownIt-Anchor" href="#连接"></a> 连接</h3><p>拆开路由器,可能会找到一排孔,上面标有<code>GND TX RX 3.3V</code>等.</p><p>给这四排孔焊上针脚,就像这样:</p><p>然后接到<code>ttl</code>转<code>usb</code>的玩意上(比如淘宝上买的<code>ch340</code>).接线方法如下:</p><table><thead><tr><th>路由器</th><th>转接器</th></tr></thead><tbody><tr><td>GND</td><td>GND</td></tr><tr><td>TX</td><td>RX</td></tr><tr><td>RX</td><td>TX</td></tr></tbody></table><p>注意,<code>3.3v</code>不要接.</p><p>把任意<code>LAN</code>口用网线接到电脑,在电脑上设置有线网口<code>ip</code>为<code>192.168.1.2</code>,掩码为<code>255.255.255.0</code>,网关为<code>192.168.1.1</code>.</p><h3 id="minicom"><a class="markdownIt-Anchor" href="#minicom"></a> minicom</h3><p>打开minicom</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo minicom -s<br></code></pre></td></tr></table></figure><p>一定要<code>sudo</code>不然找不到设备的.</p><p>这时候进入一个界面:</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">+-----[configuration]------+<br>|<span class="hljs-string"> Filenames and paths      </span>|<br>|<span class="hljs-string"> File transfer protocols  </span>|<br>|<span class="hljs-string"> Serial port setup        </span>|<br>|<span class="hljs-string"> Modem and dialing        </span>|<br>|<span class="hljs-string"> Screen and keyboard      </span>|<br>|<span class="hljs-string"> Save setup as dfl        </span>|<br>|<span class="hljs-string"> Save setup as..          </span>|<br>|<span class="hljs-string"> Exit                     </span>|<br>|<span class="hljs-string"> Exit from Minicom        </span>|<br>+--------------------------+<br></code></pre></td></tr></table></figure><p>选择<code>Serial port setup</code>.</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">+-----------------------------------------------------------------------+<br>|<span class="hljs-string"> A -    Serial Device      : /dev/ttyUSB0                              </span>|<br>|<span class="hljs-string"> B - Lockfile Location     : /var/lock                                 </span>|<br>|<span class="hljs-string"> C -   Callin Program      :                                           </span>|<br>|<span class="hljs-string"> D -  Callout Program      :                                           </span>|<br>|<span class="hljs-string"> E -    Bps/Par/Bits       : 115200 8N1                                </span>|<br>|<span class="hljs-string"> F - Hardware Flow Control : Yes                                       </span>|<br>|<span class="hljs-string"> G - Software Flow Control : No                                        </span>|<br>|<span class="hljs-string">                                                                       </span>|<br>|<span class="hljs-string">    Change which setting?                                              </span>|<br>+-----------------------------------------------------------------------+<br></code></pre></td></tr></table></figure><p>按<code>a</code>跳到<code>Serial Device</code>选项,改为你的<code>usb</code>设备,一般是<code>/dev/ttyUSB0</code>,回车确认.</p><p>按<code>e</code>跳到<code>Bps/Par/Bits</code>选项,设置波特率为<code>115200</code>(通常是).</p><p>按回车一路确认回到第一个菜单,选择<code>Save setup as dfl</code>保存为默认配置.</p><p>然后选择<code>Exit</code>退出设置.</p><p>直接<code>sudo minicom</code>就连上了.</p>]]></content>
    
    
    <categories>
      
      <category>经验和总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ttl</tag>
      
      <tag>minicom</tag>
      
      <tag>tftp</tag>
      
      <tag>openwrt</tag>
      
      <tag>uboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tcp头后半段的那些选项</title>
    <link href="/ad7e6196/"/>
    <url>/ad7e6196/</url>
    
    <content type="html"><![CDATA[<ul><li>EOL &amp; NOP;</li><li>MSS;</li><li>WSOPT;</li><li>SACK;</li></ul><span id="more"></span><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>众所周知,TCP的头部有一个字段<code>Data offset</code>,表示数据从哪个位置开始.</p><p>也就是说在<code>offset</code>之前的信息,都是tcp的头部及其填充(因为<code>offset</code>的单位是4字节,头部大小不为4字节的倍数时需要填充到4字节的倍数).</p><p>这个<code>offset</code>有4位,可以表达0-15的大小,也就是头的长度最多是60.</p><p>前20个字节都已经确定.后面40个字节可以放置TL结构的选项.</p><table><thead><tr><th>type</th><th>length</th><th>value</th></tr></thead><tbody><tr><td>1 byte</td><td>1 byte</td><td>length byte</td></tr></tbody></table><p>我很长一段时间里面都无视了这个东西的作用,今天心血来潮想要了解和整理一下.</p><p>主要选项有</p><table><thead><tr><th>type</th><th>length</th><th>简称</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>EOL</td><td>选项列表结束</td></tr><tr><td>1</td><td>1</td><td>NOP</td><td>无操作</td></tr><tr><td>2</td><td>4</td><td>MSS</td><td>最大Segmegnt长度</td></tr><tr><td>3</td><td>3</td><td>WSOPT</td><td>窗口扩大系数</td></tr><tr><td>4</td><td>2</td><td>SACK-Permitted</td><td>表示支持SACK</td></tr><tr><td>5</td><td>mutable</td><td>SACK</td><td>确认区间</td></tr><tr><td>8</td><td>10</td><td>TSOPT</td><td>Timestamps</td></tr><tr><td>19</td><td>18</td><td>TCP-MD5</td><td>MD5认证</td></tr><tr><td>28</td><td>mutable</td><td>UTO</td><td>超过一定时间后拆除连接</td></tr></tbody></table><h2 id="eol和nop"><a class="markdownIt-Anchor" href="#eol和nop"></a> EOL和NOP</h2><p>这里的<code>length</code>,是包括<code>type</code>和<code>lenght</code>本身的长度的.</p><p>也就是如果<code>length</code>为<code>4</code>,那么留给<code>value</code>的空间只有<code>2</code>字节了.</p><p>那么只有一个字节长度的<code>EOL</code>和<code>NOP</code>,是什么情况?</p><p>他们是把<code>length</code>字段也省略了,只有一个<code>type</code>.</p><p><code>EOL</code>的作用是放在tcp头的最后一个选项后面,以表示选项已经结束.</p><p>那么就会有人疑问,直接根据tcp头的长度字段来指出结束位置不就好了吗,为什么还需要一个<code>EOL</code>.</p><p>那是因为tcp头不一定刚好在<code>4</code>字节的整数倍的位置结束,在这种情况下需要一个<code>EOL</code>来表示后续数据都是填充的<code>0</code>.</p><p>如果tcp头的长度刚好为4字节的倍数,那么就不需要EOL.</p><p><code>NOP</code>则是可以用在选项之间或结尾的填充位,比如<code>WSOPT</code>选项长度为<code>3</code>,有的机器可能会补一个<code>NOP</code>来让他<code>4</code>字节对齐.</p><h2 id="mss"><a class="markdownIt-Anchor" href="#mss"></a> MSS</h2><table><thead><tr><th>type</th><th>length</th><th>value</th></tr></thead><tbody><tr><td>0x02</td><td>0x04</td><td>长度</td></tr></tbody></table><p>Maximum segment size(MSS)是TCP期望从对端接收的最大的报文长度，自然也是对端在发送报文的时候的最大报文长度，注意MSS值仅指示TCP数据长度，并不包含关联的TCP头和IP头的长度。当连接在建立的时候，每个endpoint通常会在对应的SYN包中通过MSS option通告对方自己的MSS，按照RFC1122规定如果没有MSS选项提供则会使用默认的536bytes作为MSS(注意原始的RFC793协议是说没有提供MSS选项的时候可以发送任意大小的包，RFC1122修正了该说法)。还有一点需要注意由于目前网卡普遍支持TSO、GSO功能，在开启这些功能的前提下，协议栈中的TCP层可能会按照MSS的整数倍发包，然后再由网卡硬件来对TCP分段，这样减轻了CPU的处理压力。后面为了方便讨论窗口管理等特性，我们还是按照TCP层最大包不超过MSS来讨论。</p><p>在IPV6的jumbogram中(RFC2675)，如果接收端接收到的MSS值为65535时候，标识真实的MSS需要根据PMTU值来确定。即MSS=PMTU-60。(jumbogram是IPV6中一种发送超大IP报文的协议特性，PMTU是接收端和发送端链路之间所有设备的最小MTU。)</p><p>RFC6691重新澄清了MSS选项的相关说明，并修正了之前几个RFC的错误说法。RFC6691明确规定在MSS选项中传递的MSS值为MTU减去IP基本头(ipv4为20bytes，IPV6为40bytes)和TCP基本头(20bytes)的值，不考虑扩展头。发送端负责发送数据前在这个MSS值的基础上扣除扩展头长度得出真实传输数据的长度。</p><h2 id="wsopt"><a class="markdownIt-Anchor" href="#wsopt"></a> WSOPT</h2><table><thead><tr><th>type</th><th>length</th><th>value</th></tr></thead><tbody><tr><td>0x03</td><td>0x03</td><td>位移量</td></tr></tbody></table><p>在SYN和SYN-ACK中传输,当SYN报文表示可以支持时,SYN-ACK报文就可以发送这个选项.</p><p>在tcp头中,窗口大小是一个<code>16</code>位数字.</p><p>但是在系统中,保存窗口大小用的是一个<code>32</code>位数字.</p><p>如果在选项中加上这个偏移(最大为<code>14</code>,大于<code>14</code>时当作<code>14</code>处理),那么可以使用的窗口的大小能够扩展成<code>30</code>位数字.</p><p>只能设置成不大于<code>14</code>,是为了避免真的用上了整个<code>32</code>位的空间,导致所有序号都在窗口内.</p><p>tcp通过判断序列号是否在<code>第一个未确认序列号 -- 第一个未确认序列号+2^31</code>的范围内,来判断序列号是否是新序列号.</p><p>当窗口过大时将会出错.</p><h2 id="sack"><a class="markdownIt-Anchor" href="#sack"></a> SACK</h2><p>有时候接收方会收到几段不连续的数据(他们的编号不连续),这时候可以发送几个区间,告诉发送方自己收到了哪几段数据.</p><p><code>SACK-permiited</code>在带有SYN标志的包中传输,表示双方是否支持<code>SACK</code>.</p><table><thead><tr><th>type</th><th>length</th><th>value</th></tr></thead><tbody><tr><td>0x04</td><td>0x02</td><td>支持与否</td></tr></tbody></table><p><code>SACK</code>包含若干个区间的描述信息,表示已经收到了哪几个区间内的数据.</p><p>区间的起止都是一个<code>4</code>字节的数字.也就是表示一个区间需要用到<code>8</code>字节.</p><p>由于选项字段最多只有<code>40</code>字节的空间,所以顶多有<code>4</code>个区间</p><table><thead><tr><th>type</th><th>length</th><th>value</th></tr></thead><tbody><tr><td>0x05</td><td>mutable</td><td>区间信息</td></tr></tbody></table><p>未完待续</p>]]></content>
    
    
    <categories>
      
      <category>经验和总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tcp</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux桌面使用中的那些事</title>
    <link href="/17eed1d/"/>
    <url>/17eed1d/</url>
    
    <content type="html"><![CDATA[<ul><li>安装时分区注意;</li><li>使用tmpfs;</li><li>配置vnc和xrdp远程;</li><li>快捷方式;</li><li>应用商店报错修复;</li><li>常用软件安装(go,mariaDB,npm,firefox,安卓模拟器);</li></ul><span id="more"></span><h2 id="制作启动光盘"><a class="markdownIt-Anchor" href="#制作启动光盘"></a> 制作启动光盘</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">wodim -sao -v <span class="hljs-attribute">-speed</span>=1 <span class="hljs-attribute">dev</span>=/dev/&lt;光盘设备&gt; &lt;iso文件&gt;<br></code></pre></td></tr></table></figure><p>我留意到直接挂载是不能写入的,需要用wodim工具.</p><h2 id="安装时分区注意"><a class="markdownIt-Anchor" href="#安装时分区注意"></a> 安装时分区注意</h2><p>不要用默认分区,不要用默认分区,不要用默认分区.</p><p>比如,<code>deepin</code>默认分区只给根目录分配<code>15G</code>空间,一下子就满了,满了很难搞,非常折磨.</p><p>我的通常分区方式如下</p><table><thead><tr><th>挂在目录</th><th>文件系统</th><th>大小</th></tr></thead><tbody><tr><td><code>/boot/efi</code></td><td><code>fat32</code></td><td><code>100M</code></td></tr><tr><td><code>/</code></td><td><code>ext4</code></td><td><code>其余全部空间</code></td></tr><tr><td><code>&lt;无&gt;</code></td><td><code>linux-swap</code></td><td><code>8G</code></td></tr></tbody></table><p>以前我把<code>/boot</code>独立分区弄得很小(<code>400M</code>),然后某次更新竟然满了,做什么都失败.</p><p>只能进<code>live</code>里面用<code>gparted</code>改分区.</p><p>我其实觉得<code>/boot</code>分区不用单独分出来.</p><p>我心里觉得除非是某些目录需要特殊的文件系统比如<code>efi</code>需要<code>fat32</code>,否则同硬盘分区就是扯蛋:</p><ol><li>文件跨分区移动耗时很长,像是跨硬盘移动一样,哪怕他们实际上在同一个硬盘.</li><li>常常因为分区不合理,导致某一分区满了,其他分区还有很多空间,这时候调整非常麻烦.</li><li>实际上用文件夹就能取得和分区一样的效果,而且没有上面的缺点.</li><li>同一个硬盘的分区不会有什么保险的作用,硬盘损坏依旧是所有分区遭殃.</li></ol><p>可见,我们根本没有理由去划分他.</p><h2 id="移动tmp目录到tmpfs"><a class="markdownIt-Anchor" href="#移动tmp目录到tmpfs"></a> 移动/tmp目录到tmpfs</h2><p><code>/tmp</code>目录是缓存文件的目录,开关机就会被系统删除.</p><p>这东西显然应该放到内存,还能更快存取.实在没有必要放到硬盘.</p><p>编辑<code>/etc/fstab</code>文件,后面加上以下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">tmpfs /tmp tmpfs defaults 0 0<br>tmpfs /var/tmp tmpfs defaults 0 0<br></code></pre></td></tr></table></figure><h2 id="配置远程桌面"><a class="markdownIt-Anchor" href="#配置远程桌面"></a> 配置远程桌面</h2><a href="/70069604/" title="deepin开启远程桌面服务,使用vnc和rdp连接deepin">deepin开启远程桌面服务,使用vnc和rdp连接deepin</a><p>其他系统可以看这个<a href="https://www.hiroom2.com/ubuntu-2004-xrdp-kde-en">链接</a></p><h2 id="指定软件版本"><a class="markdownIt-Anchor" href="#指定软件版本"></a> 指定软件版本</h2><p>有时候我们可以同时安装多个版本的<code>gcc</code>,这时候可以使用<code>update-alternatives</code>命令来修改默认使用的<code>gcc</code>.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo update-alternatives --install /usr/bin/gcc gcc &lt;需要使用的gcc的路径&gt; &lt;足够大的数值&gt;<br></code></pre></td></tr></table></figure><p>这个足够大的数值只要确保比之前指定过的数值大就可以,从来没有指定过就设置为<code>1</code>也行.</p><h2 id="快捷方式"><a class="markdownIt-Anchor" href="#快捷方式"></a> 快捷方式</h2><h3 id="制作快捷方式"><a class="markdownIt-Anchor" href="#制作快捷方式"></a> 制作快捷方式</h3><p>当我们有一个可执行文件,希望能够在开始菜单直接打开他.</p><p>首先可以编写一个文件<code>&lt;文件名&gt;.desktop</code>,来制作快捷方式.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[Desktop Entry]<br>Exec=&lt;可执行文件地址&gt;<br>Name=&lt;快捷方式显示的名称&gt;<br>Icon=&lt;网上找的图标.svg&gt;<br>Type=Application<br></code></pre></td></tr></table></figure><p>以上都是绝对路径,比如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[Desktop Entry]<br>Name=Uengine<br>Exec=/home/zzidun/app/uengine/uengine.sh<br>Icon=/home/zzidun/app/uengine/anbox.svg<br>Type=Application<br></code></pre></td></tr></table></figure><h3 id="快捷方式移动到开始菜单"><a class="markdownIt-Anchor" href="#快捷方式移动到开始菜单"></a> 快捷方式移动到开始菜单</h3><p>复制到<code>/usr/share/applications</code>目录即可.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo cp &lt;xxx.desktop&gt; /usr/share/application/<br></code></pre></td></tr></table></figure><h2 id="应用商店安装到75报错"><a class="markdownIt-Anchor" href="#应用商店安装到75报错"></a> 应用商店安装到75%报错</h2><p>一般是由于卸载软件没有完成导致的,用以下命令可以解决:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get --fix-broken install -y<br></code></pre></td></tr></table></figure><h2 id="apt-install-xxx-"><a class="markdownIt-Anchor" href="#apt-install-xxx-"></a> apt install XXX-</h2><p>千万谨慎,不要在安装命令后面多写一个横杆<code>-</code>,这代表卸载.</p><p>某一次我想要看看软件源提供了哪些版本的<code>gcc</code>,于是输入了<code>sudo apt install gcc-</code>,然后按<code>tab</code>查看列出的软件包.</p><p>这时候列出的软件包列表是用回车翻页的,我一直按回车,没想到多按了几个.</p><p>然后就变成执行了<code>sudo apt install gcc-</code>,一堆软件被卸载了,我人也裂开了.</p><h2 id="休眠设置"><a class="markdownIt-Anchor" href="#休眠设置"></a> 休眠设置</h2><p>看这个<a href="https://xie.infoq.cn/article/af26942709c82ab1c7cd47f87">文章</a></p><p>和这个<a href="https://blog.csdn.net/defrag257/article/details/103997722">文章</a></p><h2 id="常用软件安装"><a class="markdownIt-Anchor" href="#常用软件安装"></a> 常用软件安装</h2><h3 id="git设置"><a class="markdownIt-Anchor" href="#git设置"></a> git设置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global user.email &quot;&lt;邮箱&gt;&quot;<br>git config --global user.name &quot;&lt;用户名&gt;&quot;<br>git config --global http.postBuffer 10000M<br></code></pre></td></tr></table></figure><h3 id="go"><a class="markdownIt-Anchor" href="#go"></a> go</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://dl.google.com/go/go1.13.linux-amd64.tar.gz<br><br>sudo tar -C /usr/local -xzf go1.13.linux-amd64.tar.gz<br></code></pre></td></tr></table></figure><p>然后修改文件<code>~/.bashrc</code></p><p>加上这一句</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">export PATH=$PATH:/usr/local/go/bin<br></code></pre></td></tr></table></figure><p>然后</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">source ~/.bashrc<br></code></pre></td></tr></table></figure><p>检查是否安装完成</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">go version<br></code></pre></td></tr></table></figure><h3 id="npm"><a class="markdownIt-Anchor" href="#npm"></a> npm</h3><a href="/917b256a/" title="自行安装nodejs和npm,解决apt源版本不兼容问题">自行安装nodejs和npm,解决apt源版本不兼容问题</a><h3 id="mariadb"><a class="markdownIt-Anchor" href="#mariadb"></a> mariaDB</h3><a href="/a738e98a/" title="安装和配置mariaDB">安装和配置mariaDB</a><h3 id="firefox"><a class="markdownIt-Anchor" href="#firefox"></a> firefox</h3><p>缩小顶边栏</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">顶部右键 -&gt; Customisze Firefox -&gt; 屏幕靠下TitleBar取消打勾<br></code></pre></td></tr></table></figure><p>使用内存作为缓存</p><p>火狐地址栏输入<code>about:config</code>,进入配置页面.</p><p>搜索栏输入<code>browser.cache.disk.enable</code>设置为<code>false</code>.</p><p>搜索栏输入<code>browser.cache.memory.enable</code>设置为<code>true</code>.</p><p>搜索栏输入<code>browser.cache.memory.capacity</code>设置为<code>-1</code>.</p><p>触屏</p><p>修改<code>/etc/security/pam_env.conf</code>,在最后增加一行<code>MOZ_USE_XINPUT2 DEFAULT=1</code><br />在Firefox中，地址栏输入<code>about:config</code>，修改<code>dom.w3c_touch_events.enabled</code>为<code>1</code>。最后重启电脑。</p><h3 id="platformio"><a class="markdownIt-Anchor" href="#platformio"></a> platformIO</h3><p>直接<code>vscode</code>安装对应插件.</p><p>重新启动<code>vscode</code>.</p><p>默认情况下,platformIO会把新建的项目放到C盘用户文件里面某个很深的路径.</p><p>修改新建项目时保存路径(在pio的终端输入)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pio settings set projects_dir &lt;路径&gt;<br></code></pre></td></tr></table></figure><h3 id="minicom和fastboot找不到设备"><a class="markdownIt-Anchor" href="#minicom和fastboot找不到设备"></a> minicom和fastboot找不到设备</h3><p>他们需要<code>sudo</code>.</p><h3 id="anbox"><a class="markdownIt-Anchor" href="#anbox"></a> anbox</h3><p>官方的教程中,找不到<code>binder</code>是正常的,<code>ubuntu20</code>之后都找不到的.</p><p>接着下一步就好.</p><p><code>anbox.appmgr</code>启动不了,显示以下错误,是需要设置环境变量.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[ 2022-01-06 05:29:58] [launch.cpp:168@operator()] Session manager is not yet running, trying to start it<br>[ 2022-01-06 05:29:58] [launch.cpp:117@launch_session_manager] Started session manager, will now try to connect ..<br>[ 2022-01-06 05:29:59] [splash_screen.cpp:55@SplashScreen] Window has no associated renderer yet, creating one ...<br>[ 2022-01-06 05:30:04] [daemon.cpp:61@Run] [org.freedesktop.DBus.Error.ServiceUnknown] The name org.anbox was not provided by any .service files<br></code></pre></td></tr></table></figure><p>只需要在<code>~/.bashrc</code>文件末尾加上这个:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">export EGL_PLATFORM=x11<br></code></pre></td></tr></table></figure><p>重新打开终端,输入<code>anbox.appmgr</code>就可以打开了.</p><h3 id="steam"><a class="markdownIt-Anchor" href="#steam"></a> steam</h3><p>需要安装以下软件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install libgl1-mesa-dri:i386 libgl1:i386<br></code></pre></td></tr></table></figure><p><code>~/.profile</code>末尾加上变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">PROTON_USE_WINED3D=1<br></code></pre></td></tr></table></figure><h3 id="kvm"><a class="markdownIt-Anchor" href="#kvm"></a> kvm</h3><p>以下方法转载自<a href="https://linux.cn/article-11151-1.html">这个博客</a></p><p>打开<code>/etc/libvirt/libvirtd.conf</code>进行编辑：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vi /etc/libvirt/libvirtd.conf<br></code></pre></td></tr></table></figure><p>将<code>UNIX</code>域套接字组所有者设置为<code>libvirt</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">unix_sock_group = &quot;libvirt&quot;<br></code></pre></td></tr></table></figure><p>调整<code>UNIX</code>域套接字的读写权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">unix_sock_rw_perms = &quot;0770&quot;<br></code></pre></td></tr></table></figure><p>步骤 3：启动并启用<code>libvirtd</code>服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl start libvirtd<br>sudo systemctl enable libvirtd<br></code></pre></td></tr></table></figure><p>添加用户到<code>libvirt</code>组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo usermod -a -G libvirt $(whoami)<br></code></pre></td></tr></table></figure><h3 id="qbittorent增强版"><a class="markdownIt-Anchor" href="#qbittorent增强版"></a> qbittorent增强版</h3><p>可以防止迅雷吸血.</p><p>迅雷得到网上其他bt软件的用户分享的资源,却不给别人分享.</p><p>这样自私自利的软件需要我们一起抵制.</p><p>下面命令安装的版本,可以禁止向迅雷,qq等吸血软件分享.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">sudo add-apt-repository ppa:poplite/qbittorrent-enhanced<br>sudo apt-get update<br>sudo apt install qbittorrent-enhanced<br></code></pre></td></tr></table></figure><p><code>工具-&gt;首选项-&gt;高级-&gt;上传连接策略-&gt;反吸血</code></p>]]></content>
    
    
    <categories>
      
      <category>软件安装和配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>anbox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ffmpeg命令行视频转音频 剪辑音频</title>
    <link href="/ca9c0f8d/"/>
    <url>/ca9c0f8d/</url>
    
    <content type="html"><![CDATA[<ul><li>ffmpeg命令行视频转音频</li><li>简单剪辑</li></ul><span id="more"></span><p>首先推荐一个<a href="https://bilibili.iiilab.com/">下载B站视频的网站</a></p><p>当我们想要把某些up主音乐视频保存到本地方便之后听的时候.</p><p>可以从上面下载下来.</p><h3 id="视频转音频"><a class="markdownIt-Anchor" href="#视频转音频"></a> 视频转音频</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ffmpeg -i &lt;视频文件.mp4&gt; &lt;音频文件.mp3&gt;<br></code></pre></td></tr></table></figure><p>一阵摇晃之后,就会产生一个音频文件.</p><h3 id="音频的简单剪辑"><a class="markdownIt-Anchor" href="#音频的简单剪辑"></a> 音频的简单剪辑</h3><p>我们通常需要剪出其中的一段.</p><p>可以这样,其中开始位置结束位置的格式形如<code>时:分:秒.百分之一秒</code>,比如<code>00:01:02.33</code>.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ffmpeg  -i &lt;音频文件.mp3&gt;  -vn -acodec copy -ss &lt;开始位置&gt; -t &lt;结束位置&gt; &lt;输出音频文件.mp3&gt;<br></code></pre></td></tr></table></figure><p>拼接两个音频</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ffmpeg -i &quot;concat:&lt;音频文件1.mp3&gt;|&lt;音频文件2.mp3&gt;&quot; -acodec copy &lt;音频文件3.mp3&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>经验和总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ffmpeg</tag>
      
      <tag>bilibili</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux下使用nuclei-sdk编译longan-nano程序并获取串口打印信息</title>
    <link href="/213a381f/"/>
    <url>/213a381f/</url>
    
    <content type="html"><![CDATA[<ul><li>下载nuclei sdk及其他工具;</li><li>编译helloworld程序;</li><li>dfu下载可执行文件;</li><li>usb-jtag使用</li><li>minicom接收打印信息;</li></ul><span id="more"></span><h2 id="准备nuclei-sdk"><a class="markdownIt-Anchor" href="#准备nuclei-sdk"></a> 准备nuclei-sdk</h2><h3 id="riscv工具链"><a class="markdownIt-Anchor" href="#riscv工具链"></a> riscv工具链</h3><p>从<a href="https://www.nucleisys.com/download.php">nuclei官网</a>下载riscv gnu toolchain.</p><p>选择<code>centos/ubuntu x86-64</code>版本.</p><p>把里面的<code>gcc</code>目录解压,某个目录(暂时把这个目录记做<code>dir1</code>)</p><h3 id="openocd工具"><a class="markdownIt-Anchor" href="#openocd工具"></a> openocd工具</h3><p>从<a href="https://www.nucleisys.com/download.php">nuclei官网</a>下载openocd.</p><p>选择<code>centos/ubuntu x86-64</code>版本.</p><p>解压之后目录结构如下</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 1c">Nuclei<br><span class="hljs-string">|- openocd</span><br>   <span class="hljs-string">|- 0.10.0-15</span><br>      <span class="hljs-string">|- bin</span><br>      <span class="hljs-string">|- ...</span><br></code></pre></td></tr></table></figure><p>首先我们需要调整他的目录,把<code>0.10.0-15/</code>里的文件都直接移到<code>openocd/</code>.去掉<code>0.10.0-15/</code>这一级目录.</p><p>然后把<code>openocd</code>也移动到上文的<code>dir1</code>.</p><p>现在<code>dir1</code>的街镇应该如下:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 1c">dir1<br><span class="hljs-string">|- gcc</span><br>   <span class="hljs-string">|- bin</span><br>   <span class="hljs-string">|- ...</span><br><span class="hljs-string">|- openocd</span><br>   <span class="hljs-string">|- bin</span><br>   <span class="hljs-string">|- ...</span><br></code></pre></td></tr></table></figure><h3 id="dfu-util工具"><a class="markdownIt-Anchor" href="#dfu-util工具"></a> dfu-util工具</h3><p>我们使用<code>dfu-util</code>工具将程序刷入<code>longan nano</code>.</p><p>这里不要使用官网到版本,也不要apt安装</p><p>他们可以刷入,但无效果,<a href="https://bbs.21ic.com/icview-3069966-1-1.html">详情见</a></p><p>建议从<a href="https://sourceforge.net/projects/dfu-util/files/">这个网站</a>下载最新的<a href="https://sourceforge.net/projects/dfu-util/files/dfu-util-0.11.tar.gz/download">dfu-util-0.11-binaries.tar.xz</a></p><p>解压后,里面有一个目录<code>linux-amd64</code>,其中有我们需要的4个可执行文件.</p><p>直接在命令行用<code>.绝对路径/dfu-util</code>的方式可以执行他.</p><p>如果你嫌麻烦的话,可以把它加到环境变量,在<code>~/.bashrc</code>文件末尾加上一行.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">export PATH=$PATH:&lt;你的dfu-util所在目录的绝对路径&gt;<br></code></pre></td></tr></table></figure><p>加上这一行重新打开终端,就可以直接使用<code>dfu-util</code>.</p><h3 id="nuclei源码"><a class="markdownIt-Anchor" href="#nuclei源码"></a> nuclei源码</h3><p>从gitee下载nuclei-sdk源码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://gitee.com/Nuclei-Software/nuclei-sdk<br></code></pre></td></tr></table></figure><h2 id="编译"><a class="markdownIt-Anchor" href="#编译"></a> 编译</h2><h3 id="设置工具目录"><a class="markdownIt-Anchor" href="#设置工具目录"></a> 设置工具目录</h3><p>进入<code>nuclei-sdk</code>,里面有一个脚本<code>setup.sh</code>.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">NUCLEI_TOOL_ROOT=~/Nuclei<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># Create your setup_config.sh</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># and define NUCLEI_TOOL_ROOT like below</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># NUCLEI_TOOL_ROOT=/home/develop/Software/Nuclei</span></span><br>SETUP_CONFIG=setup_config.sh<br><br>[ -f $SETUP_CONFIG ] &amp;&amp; source $SETUP_CONFIG<br><br>[ -f .ci/build_sdk.sh ] &amp;&amp; source .ci/build_sdk.sh<br>[ -f .ci/build_applications.sh ] &amp;&amp; source .ci/build_applications.sh<br><br>echo &quot;Setup Nuclei SDK Tool Environment&quot;<br>echo &quot;NUCLEI_TOOL_ROOT=$NUCLEI_TOOL_ROOT&quot;<br><br>export PATH=$NUCLEI_TOOL_ROOT/gcc/bin:$NUCLEI_TOOL_ROOT/openocd/bin:$NUCLEI_TOOL_ROOT/qemu:$PATH<br></code></pre></td></tr></table></figure><p>观察发现,他会从<code>setup_config.sh</code>文件获取<code>SETUP_CONFIG</code>的值,如果获取不到就用<code>~/Nuclei</code>(这显然是个错误的路径).</p><p>获取之后,他就会在<code>$SETUP_CONFIG</code>目录寻找工具链和<code>openocd</code>.</p><p>所以这里我们需要把它设置成上文所说到<code>dir1</code>.</p><p>所以我们需要在<code>nuclei-sdk</code>中创建一个文件<code>setup_config.sh</code>,内容如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">NUCLEI_TOOL_ROOT=&lt;你的dir1的绝对路径&gt;<br></code></pre></td></tr></table></figure><h3 id="设置环境"><a class="markdownIt-Anchor" href="#设置环境"></a> 设置环境</h3><p>写好上面的脚本之后,每次进入<code>nuclei-sdk</code>目录编译之前都要运行<code>setup.sh</code>脚本.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">source setup.sh<br></code></pre></td></tr></table></figure><p>运行之后,就可以直接使用<code>riscv-nuclei-elf-gcc</code>等工具.</p><h3 id="编译helloworld"><a class="markdownIt-Anchor" href="#编译helloworld"></a> 编译helloworld</h3><p>使用<code>make</code>,编译<code>application/baremetal/helloworld</code>目录下的程序.参数需要设置<code>SOC</code>类型和板类型.</p><p>命令如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make PROGRAM=application/baremetal/helloworld SOC=gd32vf103 BOARD=gd32vf103c_longan_nano all<br></code></pre></td></tr></table></figure><p>执行之后会在<code>application/baremetal/helloworld</code>产生一个<code>helloworld.elf</code>文件.</p><p>使用以下命令,把它编成<code>helloworld.bin</code>.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make PROGRAM=application/baremetal/helloworld SOC=gd32vf103 BOARD=gd32vf103c_longan_nano bin<br></code></pre></td></tr></table></figure><h2 id="下载"><a class="markdownIt-Anchor" href="#下载"></a> 下载</h2><h3 id="安装驱动"><a class="markdownIt-Anchor" href="#安装驱动"></a> 安装驱动</h3><p>在下载和运行之前,为了使<code>USB</code>工作正常,我们也许需要安装以下软件.</p><p>也可能不需要,但还是装吧.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install libusb-0.1-4 libftdi1 libhidapi-hidraw0<br></code></pre></td></tr></table></figure><h3 id="dfu查看设备列表"><a class="markdownIt-Anchor" href="#dfu查看设备列表"></a> dfu查看设备列表</h3><p>通过<code>typec</code>口将电脑和<code>longan nano</code>连接.</p><p><code>longan nano</code>上电之后,按住<code>boot</code>,同时按一下<code>reset</code>,松开<code>reset</code>之后再松开<code>boot</code>.</p><p>这时<code>longan nano</code>就会进入下载模式,等待刷入程序.</p><p>执行命令<code>dfu-util -l</code>查看当前已连接设备,你会发现权限不足.</p><p>先用<code>su root</code>切换到<code>root</code>用户.</p><p>注意<code>deepin</code>的<code>root</code>用户默认密码是空,你需要<code>sudo passwd</code>设置密码之后才能登录.</p><p>进入<code>root</code>之后,再次执行<code>dfu-util -l</code>,正常来说可以显示你插入到设备.</p><p>如果你的还是没有显示,那就不知道为什么了.</p><h3 id="dfu下载程序"><a class="markdownIt-Anchor" href="#dfu下载程序"></a> dfu下载程序</h3><p>惨案</p><p>输入以下命令下载程序到<code>longan nano</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo ./dfu-util -D &lt;你的bin文件路径&gt; -s 0x08000000<br></code></pre></td></tr></table></figure><p>一阵摇晃之后,程序就下载好了,这时候可以按<code>reset</code>启动.</p><h2 id="运行"><a class="markdownIt-Anchor" href="#运行"></a> 运行</h2><p>由于这个程序是通过串口打印一些信息,我们要用电脑连到串口,来得知他到底有没有正常打印.</p><p>这时候就需要连接<code>jtag</code>.</p><h3 id="jtag接线"><a class="markdownIt-Anchor" href="#jtag接线"></a> jtag接线</h3><p>调试器和<code>longan nano</code>的连接方式如下:</p><table><thead><tr><th>调试器</th><th>longan</th></tr></thead><tbody><tr><td>GND</td><td>GND</td></tr><tr><td>RXD</td><td>T0</td></tr><tr><td>TXD</td><td>R0</td></tr><tr><td>TDI</td><td>JTDI</td></tr><tr><td>RST</td><td>RST</td></tr><tr><td>TMS</td><td>JTMS</td></tr><tr><td>TDO</td><td>JTDO</td></tr><tr><td>TCK</td><td>JTCK</td></tr></tbody></table><p>这里有3个问题:</p><ol><li>网上的旧版本外壳错误</li></ol><p>在网上找到的大部分<code>sipeed jtag</code>图片,外壳上标有两个<code>GND</code>和一个<code>NC</code>.</p><p>但我手上的却只有一个<code>GND</code>,并且有<code>3.3V</code>和<code>5V</code>.这让我非常困惑.</p><p>直到后来搜到一个<a href="https://k4zukdiyelec.blogspot.com/2019/09/sipeed-tang-primer-hummingbird.html">博客</a>.</p><p>貌似是网上的版本标记错了,我的才是正确的.</p><ol start="2"><li>调试器上的引脚和外壳标记的引脚如何对应?</li></ol><p>可以观察到引脚那一圈塑料有一个缺口,外壳的表格在<code>TMS</code>位置有一个记号.</p><p>显然有缺口的位置是<code>TMS</code>,这样就能确定调试器上的引脚分别是什么引脚了.</p><ol start="3"><li>longan nano的RST在哪?</li></ol><p>他不在尾部,看文档可以得知,他在typec接口的旁边.</p><p>最终接线如图</p><p><img src="/images/20211225192004.png" alt="" /></p><h3 id="连接电脑"><a class="markdownIt-Anchor" href="#连接电脑"></a> 连接电脑</h3><p>安装<code>minicom</code>.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install minicom<br></code></pre></td></tr></table></figure><p>把<code>jtag</code>调试器插入电脑,同时用<code>typec</code>给<code>longan nano</code>供电.</p><p>这时候在<code>/dev</code>目录会出现<code>ttyUSB0</code>.</p><p>这时候使用<code>minicom</code>连接<code>/dev/ttyUSB1</code>,命令如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo minicom -D /dev/ttyUSB1 -b 115200<br></code></pre></td></tr></table></figure><h3 id="输出结果"><a class="markdownIt-Anchor" href="#输出结果"></a> 输出结果</h3><p>打开<code>minicom</code>之后,按<code>longan nano</code>的<code>reset</code>,会重新执行程序并且在终端打印一些信息.</p><p>如果你没有<code>ttyUSB1</code>或者没有输出,我觉得插口接触不良是很大的可能.</p><p><img src="/images/20211225193027.png" alt="" /></p>]]></content>
    
    
    <categories>
      
      <category>经验和总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>riscv</tag>
      
      <tag>longan</tag>
      
      <tag>nuclei</tag>
      
      <tag>gd32vf103</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>deepin开启远程桌面服务,使用vnc和rdp连接deepin</title>
    <link href="/70069604/"/>
    <url>/70069604/</url>
    
    <content type="html"><![CDATA[<ul><li>安装openssh;</li><li>安装和配置x11vnc;</li><li>安装和配置xrdp;</li><li>设置开机启动;</li></ul><span id="more"></span><p>要注意的是,以下操作对于其他打debian系发行版并不通用.</p><h2 id="安装和启动sshd"><a class="markdownIt-Anchor" href="#安装和启动sshd"></a> 安装和启动sshd</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install openssh-server<br>sudo systemctl enable ssh.service<br></code></pre></td></tr></table></figure><h2 id="安装和配置x11vnc"><a class="markdownIt-Anchor" href="#安装和配置x11vnc"></a> 安装和配置x11vnc</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install x11vnc<br></code></pre></td></tr></table></figure><p>设置密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">x11vnc -storepasswd<br></code></pre></td></tr></table></figure><p>输入两次密码然后输入<code>y</code>确认把密码相关文件保存到文件<code>/home/&lt;用户名&gt;/.vnc/passwd</code></p><p>拷贝上述文件到目录<code>/etc/x11vnc.pass</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo cp /home/&lt;用户名&gt;/.vnc/passwd /etc/x11vnc.pass<br></code></pre></td></tr></table></figure><p>然后编辑文件<code>/lib/systemd/system/x11vnc.service</code></p><p>内容如下</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>=Start x11vnc at startup.<br><span class="hljs-attr">After</span>=multi-user.target<br><span class="hljs-section">[Service]</span><br><span class="hljs-attr">Type</span>=simple<br><span class="hljs-attr">ExecStart</span>=/usr/bin/x11vnc -auth guess -forever -loop -noxdamage -repeat -rfbauth /etc/x11vnc.pass -rfbport <span class="hljs-number">5900</span> -shared<br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span>=multi-user.target<br></code></pre></td></tr></table></figure><p>上面的<code>ExecStart</code>一项,里面有一个<code>/etc/x11vnc.pass</code>,这个是前面到密码文件的路径,你也可以不拷贝到<code>/etc</code>目录,而是直接设置成<code>/home/&lt;用户名&gt;/.vnc/passwd</code></p><h2 id="设置开机启动"><a class="markdownIt-Anchor" href="#设置开机启动"></a> 设置开机启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl enable x11vnc.service<br></code></pre></td></tr></table></figure><p>这时候重启,就可以用vnc软件连接到电脑了.</p><h2 id="安装xrdp并配置开机启动"><a class="markdownIt-Anchor" href="#安装xrdp并配置开机启动"></a> 安装xrdp并配置开机启动</h2><p>(需要先完成以上步骤</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install xrdp<br>sudo systemctl enable xrdp<br></code></pre></td></tr></table></figure><p>重启之后就可以用windows到rdp客户端连接到电脑了</p><p>注意选择<code>VNC-any</code>协议,端口选择<code>5900</code></p>]]></content>
    
    
    <categories>
      
      <category>软件安装和配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>deepin</tag>
      
      <tag>vnc</tag>
      
      <tag>rdp</tag>
      
      <tag>xrdp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自行安装nodejs和npm,解决apt源版本不兼容问题</title>
    <link href="/917b256a/"/>
    <url>/917b256a/</url>
    
    <content type="html"><![CDATA[<ul><li>安装nvm;</li><li>使用nvm安装新版本nodejs和npm</li></ul><span id="more"></span><p>debian系发行版有一个逆天的地方,那就是apt安装的nodejs很老,npm却很新.</p><p>它们居然tmb不匹配.</p><p>想要安装自己需要的版本可以这样做.</p><p>安装nvm</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash<br></code></pre></td></tr></table></figure><p>查看所有nvm版本,以下命令会列出所有版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nvm ls-remove<br></code></pre></td></tr></table></figure><p>安装想要的版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nvm install v12.22.6<br></code></pre></td></tr></table></figure><p>查看当前使用的nodejs版本.箭头指着的就是现在用的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nvm ls<br></code></pre></td></tr></table></figure><p>切换当前使用的nodejs版本.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nvm use v[版本号]<br></code></pre></td></tr></table></figure><p>设置默认使用的版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nvm alias default [版本号]<br></code></pre></td></tr></table></figure><p>安装cnpm</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install -g cnpm --registry=https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure><p>安装vue-cli</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install -g @vue/cli<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者 cnpm install -g @vue/cli</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件安装和配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>deepin</tag>
      
      <tag>vue</tag>
      
      <tag>nodejs</tag>
      
      <tag>npm</tag>
      
      <tag>debian</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安装和配置mariaDB</title>
    <link href="/a738e98a/"/>
    <url>/a738e98a/</url>
    
    <content type="html"><![CDATA[<ul><li>安装mariaDB;</li><li>配置root密码;</li><li>创建新用户并配置权限;</li></ul><span id="more"></span><h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2><p>输入以下命令安装mariadb</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install mariadb-server mariadb-client<br></code></pre></td></tr></table></figure><p>输入以下命令启动mariadb</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl start mariadb<br></code></pre></td></tr></table></figure><h2 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h2><h3 id="设置系统的root帐号的密码"><a class="markdownIt-Anchor" href="#设置系统的root帐号的密码"></a> 设置系统的root帐号的密码</h3><p>一开始登录mysql需要用root用户登录</p><p>deepin默认root密码为空,需要先输入以下命令设置root用户密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo passwd<br></code></pre></td></tr></table></figure><h3 id="登录mysql"><a class="markdownIt-Anchor" href="#登录mysql"></a> 登录mysql</h3><p>切换到root用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">su root<br></code></pre></td></tr></table></figure><p>首先设置mysql密码,在root下输入这个命令,会让输入新密码并确认.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysql_secure_installation<br></code></pre></td></tr></table></figure><p>登录使用命令<code>mysql -u&lt;用户名&gt; -p&lt;密码&gt;</code>,这里是mysql的用户,不是linux系统的用户.</p><p>现在只有root用户,所以登录root.注意<code>-u</code>和用户名之间没有空格,<code>-p</code>和密码之间没有空格.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysql -uroot -p&lt;密码&gt;<br></code></pre></td></tr></table></figure><h3 id="添加新用户并授权"><a class="markdownIt-Anchor" href="#添加新用户并授权"></a> 添加新用户并授权</h3><p>首先打开<code>mysql</code>数据库.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">use mysql;<br></code></pre></td></tr></table></figure><p>查询目前的用户表.</p><p>可以发现只有root用户,密码显示的是一串经过加密的代码,host是允许用户从哪个ip登录.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> host,<span class="hljs-keyword">user</span>,password <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span>;<br></code></pre></td></tr></table></figure><p>我们假设已经创建了想要的数据库,比如这样</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE vforum;<br></code></pre></td></tr></table></figure><p>可以设置允许哪个用户从哪些ip登录,使用什么密码,有什么权限,访问哪些数据库数据表.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>数据库<span class="hljs-operator">&gt;</span>.<span class="hljs-operator">&lt;</span>数据表<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;&lt;用户&gt;&#x27;</span>@<span class="hljs-string">&#x27;&lt;登录ip&gt;&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;&lt;密码&gt;&#x27;</span> <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> OPTION;<br></code></pre></td></tr></table></figure><p>比如,如果我们创建一个用户<code>asd</code>,</p><p>密码为<code>asdasd0</code>,</p><p>允许从任意ip登录,也就是ip填上通配符<code>%</code>,</p><p>允许说有权限,也就是<code>ALL</code>,</p><p>允许访问数据库<code>vforum</code>中的所有表,也就是<code>vforum.*</code></p><p>那么命令如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">ON</span> vforum.<span class="hljs-operator">*</span> <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;asd&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;asdasd0&#x27;</span> <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> OPTION;<br></code></pre></td></tr></table></figure><p>最后刷新权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">FLUSH privileges;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件安装和配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mariaDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过国内镜像下载riscv工具链源码并自行编译</title>
    <link href="/4b33f3aa/"/>
    <url>/4b33f3aa/</url>
    
    <content type="html"><![CDATA[<ul><li>设置git选项避免失败;</li><li>通过gitee下载主仓;</li><li>修改.gitmodule为国内镜像,加速下载子仓;</li><li>编译rv64工具链并设置环境变量;</li></ul><span id="more"></span><h2 id="下载工具链源码"><a class="markdownIt-Anchor" href="#下载工具链源码"></a> 下载工具链源码</h2><h3 id="设置git选项"><a class="markdownIt-Anchor" href="#设置git选项"></a> 设置git选项</h3><p>首先,设置<code>http.postBuffer</code>选项为<code>2000M</code>,我也不知道是什么作用,但我猜测他是一个库的文件大小的上限?</p><p>我设置成<code>1000M</code>的时候,一旦下载到大于1G的内容,就会显示出现异常的<code>EOF</code>.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global http.postBuffer 2000M<br></code></pre></td></tr></table></figure><h3 id="下载代码"><a class="markdownIt-Anchor" href="#下载代码"></a> 下载代码</h3><p>这个命令只是下载了主仓,如果你想要同时递归下载所有子仓的话,可以加上参数<code>--recursive</code>.也可以下载完主仓之后再另外下载子仓.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/riscv/riscv-gnu-toolchain<br></code></pre></td></tr></table></figure><p><code>cd</code>进入源码目录后,输入以下命令下载子仓,其中到<code>--progress</code>命令可以显示下载进度.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git submodule update --init --recursive --progress<br></code></pre></td></tr></table></figure><h3 id="加速下载"><a class="markdownIt-Anchor" href="#加速下载"></a> 加速下载</h3><p>如果下载实在很慢,可以修改源码目录下的<code>.gitmodules</code>文件,</p><p>其中的github仓库,在gitee都有镜像.只需要把地址改成<code>https://gitee.com/mirrors/&lt;仓库&gt;</code></p><p>比如<code>https://github.com/riscv-collab/riscv-binutils-gdb.git</code>可以改成<code>https://gitee.com/mirrors/riscv-binutils-gdb.git</code></p><p>其中<code>qemu</code>在<code>gitee</code>上没有镜像,但是北京外国语大学提供了镜像.我们可以把那一项的地址改成<code>url = https://mirrors.bfsu.edu.cn/git/qemu.git</code></p><p>修改完上述内容之后,先执行以下命令刷新,然后再去下载子仓.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo git submodule sync<br></code></pre></td></tr></table></figure><h2 id="编译"><a class="markdownIt-Anchor" href="#编译"></a> 编译</h2><p>在编译之前,需要安装一些工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install autoconf automake autotools-dev curl python3  libmpc-dev libmpfr-dev libgmp-dev gawk build-essential bison flex  texinfo gperf libtool patchutils bc zlib1g-dev libexpat-dev<br></code></pre></td></tr></table></figure><p>在<code>/opt</code>目录下创建一个<code>riscv</code>目录,用以存放工具链.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir /opt/riscv<br></code></pre></td></tr></table></figure><p>开始编译,以下命令编译的是64位,如果想要编译其他版本,可以看<code>readme</code>文档的说明来设置对应参数.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">./configure --prefix=/opt/riscv<br>make <br></code></pre></td></tr></table></figure><p>编译完成后,<code>/opt/riscv/bin</code>中会出现一些可执行文件.</p><p>为了方便调用他们,可以修改<code>~/.bashrc</code>脚本,每次启动终端时自动将这个目录添加到环境变量.</p><p>在<code>~/.bashrc</code>的最末尾,加上这句话.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">export PATH=$PATH:/opt/riscv/bin<br></code></pre></td></tr></table></figure><p>如果你的工具链放在其他位置,那么就把上文到<code>/opt/riscv/bin</code>改成你的工具链的可执行文件的路径即可.</p><p>这时候重新启动终端,就可以直接在命令行使用你编译的riscv工具链.</p>]]></content>
    
    
    <categories>
      
      <category>经验和总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>riscv</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
